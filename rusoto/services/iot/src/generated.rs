// =================================================================
//
//                           * WARNING *
//
//                    This file is generated!
//
//  Changes made to this file will be overwritten. If changes are
//  required to the generated code, the service_crategen project
//  must be updated to generate the changes.
//
// =================================================================

use std::error::Error;
use std::fmt;
use std::io;

#[allow(warnings)]
use futures::future;
use futures::Future;
use rusoto_core::region;
use rusoto_core::request::{BufferedHttpResponse, DispatchSignedRequest};
use rusoto_core::{Client, RusotoFuture};

use rusoto_core::credential::{CredentialsError, ProvideAwsCredentials};
use rusoto_core::request::HttpDispatchError;

use rusoto_core::param::{Params, ServiceParams};
use rusoto_core::signature::SignedRequest;
use serde_json;
use serde_json::from_slice;
use serde_json::Value as SerdeJsonValue;
/// <p>The input for the AcceptCertificateTransfer operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AcceptCertificateTransferRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>Specifies whether the certificate is active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
}

/// <p>Describes the actions associated with a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Action {
    /// <p>Change the state of a CloudWatch alarm.</p>
    #[serde(rename = "cloudwatchAlarm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cloudwatch_alarm: Option<CloudwatchAlarmAction>,
    /// <p>Capture a CloudWatch metric.</p>
    #[serde(rename = "cloudwatchMetric")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cloudwatch_metric: Option<CloudwatchMetricAction>,
    /// <p>Write to a DynamoDB table.</p>
    #[serde(rename = "dynamoDB")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamo_db: Option<DynamoDBAction>,
    /// <p>Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.</p>
    #[serde(rename = "dynamoDBv2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamo_d_bv_2: Option<DynamoDBv2Action>,
    /// <p>Write data to an Amazon Elasticsearch Service domain.</p>
    #[serde(rename = "elasticsearch")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<ElasticsearchAction>,
    /// <p>Write to an Amazon Kinesis Firehose stream.</p>
    #[serde(rename = "firehose")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub firehose: Option<FirehoseAction>,
    /// <p>Sends message data to an AWS IoT Analytics channel.</p>
    #[serde(rename = "iotAnalytics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iot_analytics: Option<IotAnalyticsAction>,
    /// <p>Write data to an Amazon Kinesis stream.</p>
    #[serde(rename = "kinesis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<KinesisAction>,
    /// <p>Invoke a Lambda function.</p>
    #[serde(rename = "lambda")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lambda: Option<LambdaAction>,
    /// <p>Publish to another MQTT topic.</p>
    #[serde(rename = "republish")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub republish: Option<RepublishAction>,
    /// <p>Write to an Amazon S3 bucket.</p>
    #[serde(rename = "s3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_3: Option<S3Action>,
    /// <p>Send a message to a Salesforce IoT Cloud Input Stream.</p>
    #[serde(rename = "salesforce")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub salesforce: Option<SalesforceAction>,
    /// <p>Publish to an Amazon SNS topic.</p>
    #[serde(rename = "sns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sns: Option<SnsAction>,
    /// <p>Publish to an Amazon SQS queue.</p>
    #[serde(rename = "sqs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sqs: Option<SqsAction>,
    /// <p>Starts execution of a Step Functions state machine.</p>
    #[serde(rename = "stepFunctions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub step_functions: Option<StepFunctionsAction>,
}

/// <p>Information about an active Device Defender security profile behavior violation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ActiveViolation {
    /// <p>The behavior which is being violated.</p>
    #[serde(rename = "behavior")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behavior: Option<Behavior>,
    /// <p>The time the most recent violation occurred.</p>
    #[serde(rename = "lastViolationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_violation_time: Option<f64>,
    /// <p>The value of the metric (the measurement) which caused the most recent violation.</p>
    #[serde(rename = "lastViolationValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_violation_value: Option<MetricValue>,
    /// <p>The security profile whose behavior is in violation.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The name of the thing responsible for the active violation.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The ID of the active violation.</p>
    #[serde(rename = "violationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_id: Option<String>,
    /// <p>The time the violation started.</p>
    #[serde(rename = "violationStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_start_time: Option<f64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AddThingToThingGroupRequest {
    /// <p>The ARN of the thing to add to a group.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The ARN of the group to which you are adding a thing.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The name of the group to which you are adding a thing.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
    /// <p>The name of the thing to add to a group.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AddThingToThingGroupResponse {}

/// <p>A structure containing the alert target ARN and the role ARN.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertTarget {
    /// <p>The ARN of the notification target to which alerts are sent.</p>
    #[serde(rename = "alertTargetArn")]
    pub alert_target_arn: String,
    /// <p>The ARN of the role that grants permission to send alerts to the notification target.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>Contains information that allowed the authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct Allowed {
    /// <p>A list of policies that allowed the authentication.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AssociateTargetsWithJobRequest {
    /// <p>An optional comment string describing why the job was associated with the targets.</p>
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>A list of thing group ARNs that define the targets of the job.</p>
    #[serde(rename = "targets")]
    pub targets: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AssociateTargetsWithJobResponse {
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>An ARN identifying the job.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachPolicyRequest {
    /// <p>The name of the policy to attach.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The identity to which the policy is attached.</p>
    #[serde(rename = "target")]
    pub target: String,
}

/// <p>The input for the AttachPrincipalPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachPrincipalPolicyRequest {
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachSecurityProfileRequest {
    /// <p>The security profile that is attached.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
    /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
    #[serde(rename = "securityProfileTargetArn")]
    pub security_profile_target_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AttachSecurityProfileResponse {}

/// <p>The input for the AttachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachThingPrincipalRequest {
    /// <p>The principal, such as a certificate or other credential.</p>
    #[serde(rename = "principal")]
    pub principal: String,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the AttachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AttachThingPrincipalResponse {}

/// <p>The attribute payload.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AttributePayload {
    /// <p>A JSON string containing up to three key-value pair in JSON format. For example:</p> <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p><p>Specifies whether the list of attributes provided in the <code>AttributePayload</code> is merged with the attributes stored in the registry, instead of overwriting them.</p> <p>To remove an attribute, call <code>UpdateThing</code> with an empty attribute value.</p> <note> <p>The <code>merge</code> attribute is only valid when calling <code>UpdateThing</code>.</p> </note></p>
    #[serde(rename = "merge")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub merge: Option<bool>,
}

/// <p>Which audit checks are enabled and disabled for this account.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuditCheckConfiguration {
    /// <p>True if this audit check is enabled for this account.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// <p>Information about the audit check.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AuditCheckDetails {
    /// <p>True if the check completed and found all resources compliant.</p>
    #[serde(rename = "checkCompliant")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_compliant: Option<bool>,
    /// <p>The completion status of this check, one of "IN_PROGRESS", "WAITING_FOR_DATA_COLLECTION", "CANCELED", "COMPLETED_COMPLIANT", "COMPLETED_NON_COMPLIANT", or "FAILED".</p>
    #[serde(rename = "checkRunStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_run_status: Option<String>,
    /// <p>The code of any error encountered when performing this check during this audit. One of "INSUFFICIENT_PERMISSIONS", or "AUDIT_CHECK_DISABLED".</p>
    #[serde(rename = "errorCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    /// <p>The message associated with any error encountered when performing this check during this audit.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// <p>The number of resources that the check found non-compliant.</p>
    #[serde(rename = "nonCompliantResourcesCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_compliant_resources_count: Option<i64>,
    /// <p>The number of resources on which the check was performed.</p>
    #[serde(rename = "totalResourcesCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_resources_count: Option<i64>,
}

/// <p>The findings (results) of the audit.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AuditFinding {
    /// <p>The audit check that generated this result.</p>
    #[serde(rename = "checkName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_name: Option<String>,
    /// <p>The time the result (finding) was discovered.</p>
    #[serde(rename = "findingTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding_time: Option<f64>,
    /// <p>The resource that was found to be non-compliant with the audit check.</p>
    #[serde(rename = "nonCompliantResource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_compliant_resource: Option<NonCompliantResource>,
    /// <p>The reason the resource was non-compliant.</p>
    #[serde(rename = "reasonForNonCompliance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason_for_non_compliance: Option<String>,
    /// <p>A code which indicates the reason that the resource was non-compliant.</p>
    #[serde(rename = "reasonForNonComplianceCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason_for_non_compliance_code: Option<String>,
    /// <p>The list of related resources.</p>
    #[serde(rename = "relatedResources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub related_resources: Option<Vec<RelatedResource>>,
    /// <p>The severity of the result (finding).</p>
    #[serde(rename = "severity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
    /// <p>The ID of the audit that generated this result (finding)</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The time the audit started.</p>
    #[serde(rename = "taskStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_start_time: Option<f64>,
}

/// <p>Information about the targets to which audit notifications are sent.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuditNotificationTarget {
    /// <p>True if notifications to the target are enabled.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// <p>The ARN of the role that grants permission to send notifications to the target.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The ARN of the target (SNS topic) to which audit notifications are sent.</p>
    #[serde(rename = "targetArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_arn: Option<String>,
}

/// <p>The audits that were performed.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AuditTaskMetadata {
    /// <p>The ID of this audit.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The status of this audit: one of "IN_PROGRESS", "COMPLETED", "FAILED" or "CANCELED".</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
    /// <p>The type of this audit: one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
    #[serde(rename = "taskType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_type: Option<String>,
}

/// <p>A collection of authorization information.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuthInfo {
    /// <p>The type of action for which the principal is being authorized.</p>
    #[serde(rename = "actionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_type: Option<String>,
    /// <p>The resources for which the principal is being authorized to perform the specified action.</p>
    #[serde(rename = "resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

/// <p>The authorizer result.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AuthResult {
    /// <p>The policies and statements that allowed the specified action.</p>
    #[serde(rename = "allowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed: Option<Allowed>,
    /// <p>The final authorization decision of this scenario. Multiple statements are taken into account when determining the authorization decision. An explicit deny statement can override multiple allow statements.</p>
    #[serde(rename = "authDecision")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_decision: Option<String>,
    /// <p>Authorization information.</p>
    #[serde(rename = "authInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_info: Option<AuthInfo>,
    /// <p>The policies and statements that denied the specified action.</p>
    #[serde(rename = "denied")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub denied: Option<Denied>,
    /// <p>Contains any missing context values found while evaluating policy.</p>
    #[serde(rename = "missingContextValues")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub missing_context_values: Option<Vec<String>>,
}

/// <p>The authorizer description.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AuthorizerDescription {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer's Lambda function ARN.</p>
    #[serde(rename = "authorizerFunctionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_function_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
    /// <p>The UNIX timestamp of when the authorizer was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The UNIX timestamp of when the authorizer was last updated.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The status of the authorizer.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The key used to extract the token from the HTTP headers.</p>
    #[serde(rename = "tokenKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_key_name: Option<String>,
    /// <p>The public keys used to validate the token signature returned by your custom authentication service.</p>
    #[serde(rename = "tokenSigningPublicKeys")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_signing_public_keys: Option<::std::collections::HashMap<String, String>>,
}

/// <p>The authorizer summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct AuthorizerSummary {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

/// <p>A Device Defender security profile behavior.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Behavior {
    /// <p>The criteria that determine if a device is behaving normally in regard to the <code>metric</code>.</p>
    #[serde(rename = "criteria")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub criteria: Option<BehaviorCriteria>,
    /// <p>What is measured by the behavior.</p>
    #[serde(rename = "metric")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metric: Option<String>,
    /// <p>The name you have given to the behavior.</p>
    #[serde(rename = "name")]
    pub name: String,
}

/// <p>The criteria by which the behavior is determined to be normal.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BehaviorCriteria {
    /// <p>The operator that relates the thing measured (<code>metric</code>) to the criteria (<code>value</code>).</p>
    #[serde(rename = "comparisonOperator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comparison_operator: Option<String>,
    /// <p>Use this to specify the period of time over which the behavior is evaluated, for those criteria which have a time dimension (for example, <code>NUM_MESSAGES_SENT</code>).</p>
    #[serde(rename = "durationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration_seconds: Option<i64>,
    /// <p>The value to be compared with the <code>metric</code>.</p>
    #[serde(rename = "value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<MetricValue>,
}

/// <p>A CA certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CACertificate {
    /// <p>The ARN of the CA certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the CA certificate.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The date the CA certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The status of the CA certificate.</p> <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>Describes a CA certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CACertificateDescription {
    /// <p>Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"</p>
    #[serde(rename = "autoRegistrationStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_registration_status: Option<String>,
    /// <p>The CA certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The CA certificate ID.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The CA certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The date the CA certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The customer version of the CA certificate.</p>
    #[serde(rename = "customerVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer_version: Option<i64>,
    /// <p>The generation ID of the CA certificate.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>The date the CA certificate was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The owner of the CA certificate.</p>
    #[serde(rename = "ownedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owned_by: Option<String>,
    /// <p>The status of a CA certificate.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>When the CA certificate is valid.</p>
    #[serde(rename = "validity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity: Option<CertificateValidity>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelAuditTaskRequest {
    /// <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CancelAuditTaskResponse {}

/// <p>The input for the CancelCertificateTransfer operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelCertificateTransferRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelJobExecutionRequest {
    /// <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The ID of the job to be canceled.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
    #[serde(rename = "statusDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_details: Option<::std::collections::HashMap<String, String>>,
    /// <p>The name of the thing whose execution of the job will be canceled.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelJobRequest {
    /// <p>An optional comment string describing why the job was canceled.</p>
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CancelJobResponse {
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The job ARN.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

/// <p>Information about a certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct Certificate {
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The date and time the certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The status of the certificate.</p> <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>Describes a certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CertificateDescription {
    /// <p>The certificate ID of the CA certificate used to sign this certificate.</p>
    #[serde(rename = "caCertificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ca_certificate_id: Option<String>,
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The date and time the certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The customer version of the certificate.</p>
    #[serde(rename = "customerVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer_version: Option<i64>,
    /// <p>The generation ID of the certificate.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>The date and time the certificate was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ID of the AWS account that owns the certificate.</p>
    #[serde(rename = "ownedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owned_by: Option<String>,
    /// <p>The ID of the AWS account of the previous owner of the certificate.</p>
    #[serde(rename = "previousOwnedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_owned_by: Option<String>,
    /// <p>The status of the certificate.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The transfer data.</p>
    #[serde(rename = "transferData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_data: Option<TransferData>,
    /// <p>When the certificate is valid.</p>
    #[serde(rename = "validity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity: Option<CertificateValidity>,
}

/// <p>When the certificate is valid.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CertificateValidity {
    /// <p>The certificate is not valid after this date.</p>
    #[serde(rename = "notAfter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_after: Option<f64>,
    /// <p>The certificate is not valid before this date.</p>
    #[serde(rename = "notBefore")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_before: Option<f64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ClearDefaultAuthorizerRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ClearDefaultAuthorizerResponse {}

/// <p>Describes an action that updates a CloudWatch alarm.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CloudwatchAlarmAction {
    /// <p>The CloudWatch alarm name.</p>
    #[serde(rename = "alarmName")]
    pub alarm_name: String,
    /// <p>The IAM role that allows access to the CloudWatch alarm.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The reason for the alarm change.</p>
    #[serde(rename = "stateReason")]
    pub state_reason: String,
    /// <p>The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.</p>
    #[serde(rename = "stateValue")]
    pub state_value: String,
}

/// <p>Describes an action that captures a CloudWatch metric.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CloudwatchMetricAction {
    /// <p>The CloudWatch metric name.</p>
    #[serde(rename = "metricName")]
    pub metric_name: String,
    /// <p>The CloudWatch metric namespace name.</p>
    #[serde(rename = "metricNamespace")]
    pub metric_namespace: String,
    /// <p>An optional <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp">Unix timestamp</a>.</p>
    #[serde(rename = "metricTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metric_timestamp: Option<String>,
    /// <p>The <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit">metric unit</a> supported by CloudWatch.</p>
    #[serde(rename = "metricUnit")]
    pub metric_unit: String,
    /// <p>The CloudWatch metric value.</p>
    #[serde(rename = "metricValue")]
    pub metric_value: String,
    /// <p>The IAM role that allows access to the CloudWatch metric.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>Describes the method to use when code signing a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSigning {
    /// <p>The ID of the AWSSignerJob which was created to sign the file.</p>
    #[serde(rename = "awsSignerJobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_signer_job_id: Option<String>,
    /// <p>A custom method for code signing a file.</p>
    #[serde(rename = "customCodeSigning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_code_signing: Option<CustomCodeSigning>,
}

/// <p>Describes the certificate chain being used when code signing a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSigningCertificateChain {
    /// <p>The name of the certificate.</p>
    #[serde(rename = "certificateName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_name: Option<String>,
    /// <p>A base64 encoded binary representation of the code signing certificate chain.</p>
    #[serde(rename = "inlineDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inline_document: Option<String>,
    /// <p>A stream of the certificate chain files.</p>
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream: Option<Stream>,
}

/// <p>Describes the signature for a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSigningSignature {
    /// <p>A base64 encoded binary representation of the code signing signature.</p>
    #[serde(rename = "inlineDocument")]
    #[serde(
        deserialize_with = "::rusoto_core::serialization::SerdeBlob::deserialize_blob",
        serialize_with = "::rusoto_core::serialization::SerdeBlob::serialize_blob",
        default
    )]
    pub inline_document: Option<Vec<u8>>,
    /// <p>A stream of the code signing signature.</p>
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream: Option<Stream>,
}

/// <p>Configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Configuration {
    /// <p>True to enable the configuration.</p>
    #[serde(rename = "Enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateAuthorizerRequest {
    /// <p>The ARN of the authorizer's Lambda function.</p>
    #[serde(rename = "authorizerFunctionArn")]
    pub authorizer_function_arn: String,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
    /// <p>The status of the create authorizer request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
    #[serde(rename = "tokenKeyName")]
    pub token_key_name: String,
    /// <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
    #[serde(rename = "tokenSigningPublicKeys")]
    pub token_signing_public_keys: ::std::collections::HashMap<String, String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateAuthorizerResponse {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer's name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

/// <p>The input for the CreateCertificateFromCsr operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateCertificateFromCsrRequest {
    /// <p>The certificate signing request (CSR).</p>
    #[serde(rename = "certificateSigningRequest")]
    pub certificate_signing_request: String,
    /// <p>Specifies whether the certificate is active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
}

/// <p>The output from the CreateCertificateFromCsr operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateCertificateFromCsrResponse {
    /// <p>The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate. Certificate management operations only take a certificateId.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateJobRequest {
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The job document.</p>
    #[serde(rename = "document")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document: Option<String>,
    /// <p>An S3 link to the job document.</p>
    #[serde(rename = "documentSource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document_source: Option<String>,
    /// <p>Allows you to create a staged rollout of the job.</p>
    #[serde(rename = "jobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_executions_rollout_config: Option<JobExecutionsRolloutConfig>,
    /// <p>A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    #[serde(rename = "presignedUrlConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presigned_url_config: Option<PresignedUrlConfig>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>A list of things and thing groups to which the job should be sent.</p>
    #[serde(rename = "targets")]
    pub targets: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateJobResponse {
    /// <p>The job description.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The job ARN.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

/// <p>The input for the CreateKeysAndCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateKeysAndCertificateRequest {
    /// <p>Specifies whether the certificate is active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
}

/// <p>The output of the CreateKeysAndCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateKeysAndCertificateResponse {
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate. AWS IoT issues a default subject name for the certificate (for example, AWS IoT Certificate).</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The generated key pair.</p>
    #[serde(rename = "keyPair")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_pair: Option<KeyPair>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateOTAUpdateRequest {
    /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
    #[serde(rename = "additionalParameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_parameters: Option<::std::collections::HashMap<String, String>>,
    /// <p>The description of the OTA update.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files to be streamed by the OTA update.</p>
    #[serde(rename = "files")]
    pub files: Vec<OTAUpdateFile>,
    /// <p>The ID of the OTA update to be created.</p>
    #[serde(rename = "otaUpdateId")]
    pub ota_update_id: String,
    /// <p>The IAM role that allows access to the AWS IoT Jobs service.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>The targeted devices to receive OTA updates.</p>
    #[serde(rename = "targets")]
    pub targets: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateOTAUpdateResponse {
    /// <p>The AWS IoT job ARN associated with the OTA update.</p>
    #[serde(rename = "awsIotJobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_arn: Option<String>,
    /// <p>The AWS IoT job ID associated with the OTA update.</p>
    #[serde(rename = "awsIotJobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_id: Option<String>,
    /// <p>The OTA update ARN.</p>
    #[serde(rename = "otaUpdateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_arn: Option<String>,
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_id: Option<String>,
    /// <p>The OTA update status.</p>
    #[serde(rename = "otaUpdateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_status: Option<String>,
}

/// <p>The input for the CreatePolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreatePolicyRequest {
    /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
    #[serde(rename = "policyDocument")]
    pub policy_document: String,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the CreatePolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreatePolicyResponse {
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

/// <p>The input for the CreatePolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreatePolicyVersionRequest {
    /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
    #[serde(rename = "policyDocument")]
    pub policy_document: String,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    #[serde(rename = "setAsDefault")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_default: Option<bool>,
}

/// <p>The output of the CreatePolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreatePolicyVersionResponse {
    /// <p>Specifies whether the policy version is the default.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateRoleAliasRequest {
    /// <p>How long (in seconds) the credentials will be valid.</p>
    #[serde(rename = "credentialDurationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential_duration_seconds: Option<i64>,
    /// <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
    /// <p>The role ARN.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateRoleAliasResponse {
    /// <p>The role alias.</p>
    #[serde(rename = "roleAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias: Option<String>,
    /// <p>The role alias ARN.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateScheduledAuditRequest {
    /// <p>The day of the month on which the scheduled audit takes place. Can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to "MONTHLY". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit takes place. Can be one of "SUN", "MON", "TUE", "WED", "THU", "FRI" or "SAT". This field is required if the "frequency" parameter is set to "WEEKLY" or "BIWEEKLY".</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place. Can be one of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The actual start time of each audit is determined by the system.</p>
    #[serde(rename = "frequency")]
    pub frequency: String,
    /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    #[serde(rename = "targetCheckNames")]
    pub target_check_names: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateScheduledAuditResponse {
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateSecurityProfileRequest {
    /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    pub behaviors: Vec<Behavior>,
    /// <p>A description of the security profile.</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name you are giving to the security profile.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateSecurityProfileResponse {
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "securityProfileArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_arn: Option<String>,
    /// <p>The name you gave to the security profile.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateStreamRequest {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files to stream.</p>
    #[serde(rename = "files")]
    pub files: Vec<StreamFile>,
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateStreamResponse {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The version of the stream.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateThingGroupRequest {
    /// <p>The name of the parent thing group.</p>
    #[serde(rename = "parentGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group_name: Option<String>,
    /// <p>The thing group name to create.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
    /// <p>The thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_properties: Option<ThingGroupProperties>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateThingGroupResponse {
    /// <p>The thing group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The thing group ID.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>The thing group name.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
}

/// <p>The input for the CreateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateThingRequest {
    /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p> <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
    #[serde(rename = "attributePayload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_payload: Option<AttributePayload>,
    /// <p>The name of the thing to create.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
    /// <p>The name of the thing type associated with the new thing.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output of the CreateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateThingResponse {
    /// <p>The ARN of the new thing.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The thing ID.</p>
    #[serde(rename = "thingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_id: Option<String>,
    /// <p>The name of the new thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

/// <p>The input for the CreateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateThingTypeRequest {
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
    /// <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
    #[serde(rename = "thingTypeProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_properties: Option<ThingTypeProperties>,
}

/// <p>The output of the CreateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct CreateThingTypeResponse {
    /// <p>The Amazon Resource Name (ARN) of the thing type.</p>
    #[serde(rename = "thingTypeArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_arn: Option<String>,
    /// <p>The thing type ID.</p>
    #[serde(rename = "thingTypeId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_id: Option<String>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The input for the CreateTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
    /// <p>The rule payload.</p>
    #[serde(rename = "topicRulePayload")]
    pub topic_rule_payload: TopicRulePayload,
}

/// <p>Describes a custom method used to code sign a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomCodeSigning {
    /// <p>The certificate chain.</p>
    #[serde(rename = "certificateChain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_chain: Option<CodeSigningCertificateChain>,
    /// <p>The hash algorithm used to code sign the file.</p>
    #[serde(rename = "hashAlgorithm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hash_algorithm: Option<String>,
    /// <p>The signature for the file.</p>
    #[serde(rename = "signature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<CodeSigningSignature>,
    /// <p>The signature algorithm used to code sign the file.</p>
    #[serde(rename = "signatureAlgorithm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature_algorithm: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteAccountAuditConfigurationRequest {
    /// <p>If true, all scheduled audits are deleted.</p>
    #[serde(rename = "deleteScheduledAudits")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_scheduled_audits: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteAccountAuditConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteAuthorizerRequest {
    /// <p>The name of the authorizer to delete.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteAuthorizerResponse {}

/// <p>Input for the DeleteCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteCACertificateRequest {
    /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

/// <p>The output for the DeleteCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteCACertificateResponse {}

/// <p>The input for the DeleteCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>Forces a certificate request to be deleted.</p>
    #[serde(rename = "forceDelete")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_delete: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteJobExecutionRequest {
    /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
    #[serde(rename = "executionNumber")]
    pub execution_number: i64,
    /// <p><p>(Optional) When true, you can delete a job execution which is &quot;IN<em>PROGRESS&quot;. Otherwise, you can only delete a job execution which is in a terminal state (&quot;SUCCEEDED&quot;, &quot;FAILED&quot;, &quot;REJECTED&quot;, &quot;REMOVED&quot; or &quot;CANCELED&quot;) or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is &quot;IN</em>PROGRESS&quot;, will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note></p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>The name of the thing whose job execution will be deleted.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteJobRequest {
    /// <p><p>(Optional) When true, you can delete a job which is &quot;IN<em>PROGRESS&quot;. Otherwise, you can only delete a job which is in a terminal state (&quot;COMPLETED&quot; or &quot;CANCELED&quot;) or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is &quot;IN</em>PROGRESS&quot;, will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note></p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteOTAUpdateRequest {
    /// <p>The OTA update ID to delete.</p>
    #[serde(rename = "otaUpdateId")]
    pub ota_update_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteOTAUpdateResponse {}

/// <p>The input for the DeletePolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeletePolicyRequest {
    /// <p>The name of the policy to delete.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The input for the DeletePolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeletePolicyVersionRequest {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    pub policy_version_id: String,
}

/// <p>The input for the DeleteRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteRegistrationCodeRequest {}

/// <p>The output for the DeleteRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteRegistrationCodeResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteRoleAliasRequest {
    /// <p>The role alias to delete.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteRoleAliasResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteScheduledAuditRequest {
    /// <p>The name of the scheduled audit you want to delete.</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteScheduledAuditResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteSecurityProfileRequest {
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different than the actual version, a <code>VersionConflictException</code> is thrown.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the security profile to be deleted.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteSecurityProfileResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteStreamRequest {
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteStreamResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteThingGroupRequest {
    /// <p>The expected version of the thing group to delete.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the thing group to delete.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteThingGroupResponse {}

/// <p>The input for the DeleteThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteThingRequest {
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the thing to delete.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output of the DeleteThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteThingResponse {}

/// <p>The input for the DeleteThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteThingTypeRequest {
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
}

/// <p>The output for the DeleteThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeleteThingTypeResponse {}

/// <p>The input for the DeleteTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteV2LoggingLevelRequest {
    /// <p>The name of the resource for which you are configuring logging.</p>
    #[serde(rename = "targetName")]
    pub target_name: String,
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    #[serde(rename = "targetType")]
    pub target_type: String,
}

/// <p>Contains information that denied the authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct Denied {
    /// <p>Information that explicitly denies the authorization. </p>
    #[serde(rename = "explicitDeny")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_deny: Option<ExplicitDeny>,
    /// <p>Information that implicitly denies the authorization. When a policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.</p>
    #[serde(rename = "implicitDeny")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub implicit_deny: Option<ImplicitDeny>,
}

/// <p>The input for the DeprecateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeprecateThingTypeRequest {
    /// <p>The name of the thing type to deprecate.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
    /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
    #[serde(rename = "undoDeprecate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub undo_deprecate: Option<bool>,
}

/// <p>The output for the DeprecateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DeprecateThingTypeResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAccountAuditConfigurationRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeAccountAuditConfigurationResponse {
    /// <p>Which audit checks are enabled and disabled for this account.</p>
    #[serde(rename = "auditCheckConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_check_configurations:
        Option<::std::collections::HashMap<String, AuditCheckConfiguration>>,
    /// <p>Information about the targets to which audit notifications are sent for this account.</p>
    #[serde(rename = "auditNotificationTargetConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_notification_target_configurations:
        Option<::std::collections::HashMap<String, AuditNotificationTarget>>,
    /// <p>The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates and other items as necessary when performing an audit.</p> <p>On the first call to <code>UpdateAccountAuditConfiguration</code> this parameter is required.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAuditTaskRequest {
    /// <p>The ID of the audit whose information you want to get.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeAuditTaskResponse {
    /// <p>Detailed information about each check performed during this audit.</p>
    #[serde(rename = "auditDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_details: Option<::std::collections::HashMap<String, AuditCheckDetails>>,
    /// <p>The name of the scheduled audit (only if the audit was a scheduled audit).</p>
    #[serde(rename = "scheduledAuditName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_name: Option<String>,
    /// <p>The time the audit started.</p>
    #[serde(rename = "taskStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_start_time: Option<f64>,
    /// <p>Statistical information about the audit.</p>
    #[serde(rename = "taskStatistics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_statistics: Option<TaskStatistics>,
    /// <p>The status of the audit: one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
    /// <p>The type of audit: "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
    #[serde(rename = "taskType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAuthorizerRequest {
    /// <p>The name of the authorizer to describe.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeAuthorizerResponse {
    /// <p>The authorizer description.</p>
    #[serde(rename = "authorizerDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_description: Option<AuthorizerDescription>,
}

/// <p>The input for the DescribeCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeCACertificateRequest {
    /// <p>The CA certificate identifier.</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

/// <p>The output from the DescribeCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeCACertificateResponse {
    /// <p>The CA certificate description.</p>
    #[serde(rename = "certificateDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_description: Option<CACertificateDescription>,
    /// <p>Information about the registration configuration.</p>
    #[serde(rename = "registrationConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_config: Option<RegistrationConfig>,
}

/// <p>The input for the DescribeCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

/// <p>The output of the DescribeCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeCertificateResponse {
    /// <p>The description of the certificate.</p>
    #[serde(rename = "certificateDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_description: Option<CertificateDescription>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeDefaultAuthorizerRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeDefaultAuthorizerResponse {
    /// <p>The default authorizer's description.</p>
    #[serde(rename = "authorizerDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_description: Option<AuthorizerDescription>,
}

/// <p>The input for the DescribeEndpoint operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeEndpointRequest {
    /// <p>The endpoint type.</p>
    #[serde(rename = "endpointType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_type: Option<String>,
}

/// <p>The output from the DescribeEndpoint operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeEndpointResponse {
    /// <p>The endpoint. The format of the endpoint is as follows: <i>identifier</i>.iot.<i>region</i>.amazonaws.com.</p>
    #[serde(rename = "endpointAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_address: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeEventConfigurationsRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeEventConfigurationsResponse {
    /// <p>The creation date of the event configuration.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The event configurations.</p>
    #[serde(rename = "eventConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_configurations: Option<::std::collections::HashMap<String, Configuration>>,
    /// <p>The date the event configurations were last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeIndexRequest {
    /// <p>The index name.</p>
    #[serde(rename = "indexName")]
    pub index_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeIndexResponse {
    /// <p>The index name.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The index status.</p>
    #[serde(rename = "indexStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_status: Option<String>,
    /// <p><p>Contains a value that specifies the type of indexing performed. Valid values are:</p> <ol> <li> <p>REGISTRY – Your thing index will contain only registry data.</p> </li> <li> <p>REGISTRY<em>AND</em>SHADOW - Your thing index will contain registry and shadow data.</p> </li> </ol></p>
    #[serde(rename = "schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeJobExecutionRequest {
    /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
    #[serde(rename = "executionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_number: Option<i64>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>The name of the thing on which the job execution is running.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeJobExecutionResponse {
    /// <p>Information about the job execution.</p>
    #[serde(rename = "execution")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution: Option<JobExecution>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeJobRequest {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeJobResponse {
    /// <p>An S3 link to the job document.</p>
    #[serde(rename = "documentSource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document_source: Option<String>,
    /// <p>Information about the job.</p>
    #[serde(rename = "job")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job: Option<Job>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeRoleAliasRequest {
    /// <p>The role alias to describe.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeRoleAliasResponse {
    /// <p>The role alias description.</p>
    #[serde(rename = "roleAliasDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_description: Option<RoleAliasDescription>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeScheduledAuditRequest {
    /// <p>The name of the scheduled audit whose information you want to get.</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeScheduledAuditResponse {
    /// <p>The day of the month on which the scheduled audit takes place. Will be "1" through "31" or "LAST". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit takes place. One of "SUN", "MON", "TUE", "WED", "THU", "FRI" or "SAT".</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place. One of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The actual start time of each audit is determined by the system.</p>
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<String>,
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
    /// <p>The name of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_name: Option<String>,
    /// <p>Which checks are performed during the scheduled audit. (Note that checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    #[serde(rename = "targetCheckNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_check_names: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeSecurityProfileRequest {
    /// <p>The name of the security profile whose information you want to get.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeSecurityProfileResponse {
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>The time the security profile was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The time the security profile was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "securityProfileArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_arn: Option<String>,
    /// <p>A description of the security profile (associated with the security profile when it was created or updated).</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name of the security profile.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The version of the security profile. A new version is generated whenever the security profile is updated.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeStreamRequest {
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeStreamResponse {
    /// <p>Information about the stream.</p>
    #[serde(rename = "streamInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_info: Option<StreamInfo>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingGroupRequest {
    /// <p>The name of the thing group.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeThingGroupResponse {
    /// <p>The thing group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The thing group ID.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>Thing group metadata.</p>
    #[serde(rename = "thingGroupMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_metadata: Option<ThingGroupMetadata>,
    /// <p>The name of the thing group.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
    /// <p>The thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_properties: Option<ThingGroupProperties>,
    /// <p>The version of the thing group.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingRegistrationTaskRequest {
    /// <p>The task ID.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeThingRegistrationTaskResponse {
    /// <p>The task creation date.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The number of things that failed to be provisioned.</p>
    #[serde(rename = "failureCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failure_count: Option<i64>,
    /// <p>The S3 bucket that contains the input file.</p>
    #[serde(rename = "inputFileBucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_file_bucket: Option<String>,
    /// <p>The input file key.</p>
    #[serde(rename = "inputFileKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_file_key: Option<String>,
    /// <p>The date when the task was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// <p>The progress of the bulk provisioning task expressed as a percentage.</p>
    #[serde(rename = "percentageProgress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percentage_progress: Option<i64>,
    /// <p>The role ARN that grants access to the input file bucket.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The status of the bulk thing provisioning task.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The number of things successfully provisioned.</p>
    #[serde(rename = "successCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success_count: Option<i64>,
    /// <p>The task ID.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The task's template.</p>
    #[serde(rename = "templateBody")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_body: Option<String>,
}

/// <p>The input for the DescribeThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingRequest {
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the DescribeThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeThingResponse {
    /// <p>The thing attributes.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The default client ID.</p>
    #[serde(rename = "defaultClientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_client_id: Option<String>,
    /// <p>The ARN of the thing to describe.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The ID of the thing to describe.</p>
    #[serde(rename = "thingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_id: Option<String>,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The thing type name.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p><p>The current version of the thing record in the registry.</p> <note> <p>To avoid unintentional changes to the information in the registry, you can pass the version information in the <code>expectedVersion</code> parameter of the <code>UpdateThing</code> and <code>DeleteThing</code> calls.</p> </note></p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// <p>The input for the DescribeThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingTypeRequest {
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
}

/// <p>The output for the DescribeThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DescribeThingTypeResponse {
    /// <p>The thing type ARN.</p>
    #[serde(rename = "thingTypeArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_arn: Option<String>,
    /// <p>The thing type ID.</p>
    #[serde(rename = "thingTypeId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_id: Option<String>,
    /// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.</p>
    #[serde(rename = "thingTypeMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_metadata: Option<ThingTypeMetadata>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p>The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.</p>
    #[serde(rename = "thingTypeProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_properties: Option<ThingTypeProperties>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachPolicyRequest {
    /// <p>The policy to detach.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The target from which the policy will be detached.</p>
    #[serde(rename = "target")]
    pub target: String,
}

/// <p>The input for the DetachPrincipalPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachPrincipalPolicyRequest {
    /// <p>The name of the policy to detach.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachSecurityProfileRequest {
    /// <p>The security profile that is detached.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
    /// <p>The ARN of the thing group from which the security profile is detached.</p>
    #[serde(rename = "securityProfileTargetArn")]
    pub security_profile_target_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DetachSecurityProfileResponse {}

/// <p>The input for the DetachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachThingPrincipalRequest {
    /// <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
    #[serde(rename = "principal")]
    pub principal: String,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the DetachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct DetachThingPrincipalResponse {}

/// <p>The input for the DisableTopicRuleRequest operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DisableTopicRuleRequest {
    /// <p>The name of the rule to disable.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

/// <p>Describes an action to write to a DynamoDB table.</p> <p>The <code>tableName</code>, <code>hashKeyField</code>, and <code>rangeKeyField</code> values must match the values used when you created the table.</p> <p>The <code>hashKeyValue</code> and <code>rangeKeyvalue</code> fields use a substitution template syntax. These templates provide data at runtime. The syntax is as follows: ${<i>sql-expression</i>}.</p> <p>You can specify any valid expression in a WHERE or SELECT clause, including JSON properties, comparisons, calculations, and functions. For example, the following field uses the third level of the topic:</p> <p> <code>"hashKeyValue": "${topic(3)}"</code> </p> <p>The following field uses the timestamp:</p> <p> <code>"rangeKeyValue": "${timestamp()}"</code> </p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DynamoDBAction {
    /// <p>The hash key name.</p>
    #[serde(rename = "hashKeyField")]
    pub hash_key_field: String,
    /// <p>The hash key type. Valid values are "STRING" or "NUMBER"</p>
    #[serde(rename = "hashKeyType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hash_key_type: Option<String>,
    /// <p>The hash key value.</p>
    #[serde(rename = "hashKeyValue")]
    pub hash_key_value: String,
    /// <p>The type of operation to be performed. This follows the substitution template, so it can be <code>${operation}</code>, but the substitution must result in one of the following: <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
    #[serde(rename = "operation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// <p>The action payload. This name can be customized.</p>
    #[serde(rename = "payloadField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payload_field: Option<String>,
    /// <p>The range key name.</p>
    #[serde(rename = "rangeKeyField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range_key_field: Option<String>,
    /// <p>The range key type. Valid values are "STRING" or "NUMBER"</p>
    #[serde(rename = "rangeKeyType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range_key_type: Option<String>,
    /// <p>The range key value.</p>
    #[serde(rename = "rangeKeyValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range_key_value: Option<String>,
    /// <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the DynamoDB table.</p>
    #[serde(rename = "tableName")]
    pub table_name: String,
}

/// <p>Describes an action to write to a DynamoDB table.</p> <p>This DynamoDB action writes each attribute in the message payload into it's own column in the DynamoDB table.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DynamoDBv2Action {
    /// <p>Specifies the DynamoDB table to which the message data will be written. For example:</p> <p> <code>{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }</code> </p> <p>Each attribute in the message payload will be written to a separate column in the DynamoDB database.</p>
    #[serde(rename = "putItem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub put_item: Option<PutItemInput>,
    /// <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>The policy that has the effect on the authorization results.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct EffectivePolicy {
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The IAM policy document.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}

/// <p>Describes an action that writes data to an Amazon Elasticsearch Service domain.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ElasticsearchAction {
    /// <p>The endpoint of your Elasticsearch domain.</p>
    #[serde(rename = "endpoint")]
    pub endpoint: String,
    /// <p>The unique identifier for the document you are storing.</p>
    #[serde(rename = "id")]
    pub id: String,
    /// <p>The Elasticsearch index where you want to store your data.</p>
    #[serde(rename = "index")]
    pub index: String,
    /// <p>The IAM role ARN that has access to Elasticsearch.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The type of document you are storing.</p>
    #[serde(rename = "type")]
    pub type_: String,
}

/// <p>The input for the EnableTopicRuleRequest operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct EnableTopicRuleRequest {
    /// <p>The name of the topic rule to enable.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

/// <p>Error information.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ErrorInfo {
    /// <p>The error code.</p>
    #[serde(rename = "code")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// <p>The error message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// <p>Information that explicitly denies authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ExplicitDeny {
    /// <p>The policies that denied the authorization.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>Describes an action that writes data to an Amazon Kinesis Firehose stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FirehoseAction {
    /// <p>The delivery stream name.</p>
    #[serde(rename = "deliveryStreamName")]
    pub delivery_stream_name: String,
    /// <p>The IAM role that grants access to the Amazon Kinesis Firehose stream.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).</p>
    #[serde(rename = "separator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetEffectivePoliciesRequest {
    /// <p>The Cognito identity pool ID.</p>
    #[serde(rename = "cognitoIdentityPoolId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cognito_identity_pool_id: Option<String>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principal: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetEffectivePoliciesResponse {
    /// <p>The effective policies.</p>
    #[serde(rename = "effectivePolicies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub effective_policies: Option<Vec<EffectivePolicy>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetIndexingConfigurationRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetIndexingConfigurationResponse {
    /// <p>Thing indexing configuration.</p>
    #[serde(rename = "thingIndexingConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_indexing_configuration: Option<ThingIndexingConfiguration>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetJobDocumentRequest {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetJobDocumentResponse {
    /// <p>The job document content.</p>
    #[serde(rename = "document")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document: Option<String>,
}

/// <p>The input for the GetLoggingOptions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetLoggingOptionsRequest {}

/// <p>The output from the GetLoggingOptions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetLoggingOptionsResponse {
    /// <p>The logging level.</p>
    #[serde(rename = "logLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_level: Option<String>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetOTAUpdateRequest {
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    pub ota_update_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetOTAUpdateResponse {
    /// <p>The OTA update info.</p>
    #[serde(rename = "otaUpdateInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_info: Option<OTAUpdateInfo>,
}

/// <p>The input for the GetPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetPolicyRequest {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the GetPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetPolicyResponse {
    /// <p>The date the policy was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The default policy version ID.</p>
    #[serde(rename = "defaultVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_version_id: Option<String>,
    /// <p>The generation ID of the policy.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>The date the policy was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}

/// <p>The input for the GetPolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetPolicyVersionRequest {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    pub policy_version_id: String,
}

/// <p>The output from the GetPolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetPolicyVersionResponse {
    /// <p>The date the policy version was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The generation ID of the policy version.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>Specifies whether the policy version is the default.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The date the policy version was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

/// <p>The input to the GetRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetRegistrationCodeRequest {}

/// <p>The output from the GetRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetRegistrationCodeResponse {
    /// <p>The CA certificate registration code.</p>
    #[serde(rename = "registrationCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_code: Option<String>,
}

/// <p>The input for the GetTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

/// <p>The output from the GetTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetTopicRuleResponse {
    /// <p>The rule.</p>
    #[serde(rename = "rule")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule: Option<TopicRule>,
    /// <p>The rule ARN.</p>
    #[serde(rename = "ruleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetV2LoggingOptionsRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GetV2LoggingOptionsResponse {
    /// <p>The default log level.</p>
    #[serde(rename = "defaultLogLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_log_level: Option<String>,
    /// <p>Disables all logs.</p>
    #[serde(rename = "disableAllLogs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_all_logs: Option<bool>,
    /// <p>The IAM role ARN AWS IoT uses to write to your CloudWatch logs.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>The name and ARN of a group.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct GroupNameAndArn {
    /// <p>The group ARN.</p>
    #[serde(rename = "groupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_arn: Option<String>,
    /// <p>The group name.</p>
    #[serde(rename = "groupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_name: Option<String>,
}

/// <p>Information that implicitly denies authorization. When policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ImplicitDeny {
    /// <p>Policies that don't contain a matching allow or deny statement for the specified action on the specified resource. </p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>Sends messge data to an AWS IoT Analytics channel.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IotAnalyticsAction {
    /// <p>(deprecated) The ARN of the IoT Analytics channel to which message data will be sent.</p>
    #[serde(rename = "channelArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_arn: Option<String>,
    /// <p>The name of the IoT Analytics channel to which message data will be sent.</p>
    #[serde(rename = "channelName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_name: Option<String>,
    /// <p>The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>The <code>Job</code> object contains details about a job.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct Job {
    /// <p>If the job was updated, describes the reason for the update.</p>
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// <p>The time, in milliseconds since the epoch, when the job was completed.</p>
    #[serde(rename = "completedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<f64>,
    /// <p>The time, in milliseconds since the epoch, when the job was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>Will be <code>true</code> if the job was canceled with the optional <code>force</code> parameter set to <code>true</code>.</p>
    #[serde(rename = "forceCanceled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_canceled: Option<bool>,
    /// <p>An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>Allows you to create a staged rollout of a job.</p>
    #[serde(rename = "jobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_executions_rollout_config: Option<JobExecutionsRolloutConfig>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
    /// <p>Details about the job process.</p>
    #[serde(rename = "jobProcessDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_process_details: Option<JobProcessDetails>,
    /// <p>The time, in milliseconds since the epoch, when the job was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>Configuration for pre-signed S3 URLs.</p>
    #[serde(rename = "presignedUrlConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presigned_url_config: Option<PresignedUrlConfig>,
    /// <p>The status of the job, one of <code>IN_PROGRESS</code>, <code>CANCELED</code>, or <code>COMPLETED</code>. </p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a device when the thing representing the device is added to a target group, even after the job was completed by all things originally in the group. </p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>A list of IoT things and thing groups to which the job should be sent.</p>
    #[serde(rename = "targets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// <p>The job execution object represents the execution of a job on a particular device.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobExecution {
    /// <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used in commands which return or update job execution information. </p>
    #[serde(rename = "executionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_number: Option<i64>,
    /// <p>Will be <code>true</code> if the job execution was canceled with the optional <code>force</code> parameter set to <code>true</code>.</p>
    #[serde(rename = "forceCanceled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_canceled: Option<bool>,
    /// <p>The unique identifier you assigned to the job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
    /// <p>The time, in milliseconds since the epoch, when the job execution was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>The time, in milliseconds since the epoch, when the job execution was queued.</p>
    #[serde(rename = "queuedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub queued_at: Option<f64>,
    /// <p>The time, in milliseconds since the epoch, when the job execution started.</p>
    #[serde(rename = "startedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<f64>,
    /// <p>The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCESS, CANCELED, or REJECTED).</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>A collection of name/value pairs that describe the status of the job execution.</p>
    #[serde(rename = "statusDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_details: Option<JobExecutionStatusDetails>,
    /// <p>The ARN of the thing on which the job execution is running.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The version of the job execution. Job execution versions are incremented each time they are updated by a device.</p>
    #[serde(rename = "versionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_number: Option<i64>,
}

/// <p>Details of the job execution status.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobExecutionStatusDetails {
    /// <p>The job execution status.</p>
    #[serde(rename = "detailsMap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details_map: Option<::std::collections::HashMap<String, String>>,
}

/// <p>The job execution summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobExecutionSummary {
    /// <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used later in commands which return or update job execution information.</p>
    #[serde(rename = "executionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_number: Option<i64>,
    /// <p>The time, in milliseconds since the epoch, when the job execution was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>The time, in milliseconds since the epoch, when the job execution was queued.</p>
    #[serde(rename = "queuedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub queued_at: Option<f64>,
    /// <p>The time, in milliseconds since the epoch, when the job execution started.</p>
    #[serde(rename = "startedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<f64>,
    /// <p>The status of the job execution.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>Contains a summary of information about job executions for a specific job.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobExecutionSummaryForJob {
    /// <p>Contains a subset of information about a job execution.</p>
    #[serde(rename = "jobExecutionSummary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_execution_summary: Option<JobExecutionSummary>,
    /// <p>The ARN of the thing on which the job execution is running.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
}

/// <p>The job execution summary for a thing.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobExecutionSummaryForThing {
    /// <p>Contains a subset of information about a job execution.</p>
    #[serde(rename = "jobExecutionSummary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_execution_summary: Option<JobExecutionSummary>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

/// <p>Allows you to create a staged rollout of a job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct JobExecutionsRolloutConfig {
    /// <p>The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.</p>
    #[serde(rename = "maximumPerMinute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum_per_minute: Option<i64>,
}

/// <p>The job process details.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobProcessDetails {
    /// <p>The number of things that cancelled the job.</p>
    #[serde(rename = "numberOfCanceledThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_canceled_things: Option<i64>,
    /// <p>The number of things that failed executing the job.</p>
    #[serde(rename = "numberOfFailedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_failed_things: Option<i64>,
    /// <p>The number of things currently executing the job.</p>
    #[serde(rename = "numberOfInProgressThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_in_progress_things: Option<i64>,
    /// <p>The number of things that are awaiting execution of the job.</p>
    #[serde(rename = "numberOfQueuedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_queued_things: Option<i64>,
    /// <p>The number of things that rejected the job.</p>
    #[serde(rename = "numberOfRejectedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_rejected_things: Option<i64>,
    /// <p>The number of things that are no longer scheduled to execute the job because they have been deleted or have been removed from the group that was a target of the job.</p>
    #[serde(rename = "numberOfRemovedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_removed_things: Option<i64>,
    /// <p>The number of things which successfully completed the job.</p>
    #[serde(rename = "numberOfSucceededThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_succeeded_things: Option<i64>,
    /// <p>The target devices to which the job execution is being rolled out. This value will be null after the job execution has finished rolling out to all the target devices.</p>
    #[serde(rename = "processingTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub processing_targets: Option<Vec<String>>,
}

/// <p>The job summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct JobSummary {
    /// <p>The time, in milliseconds since the epoch, when the job completed.</p>
    #[serde(rename = "completedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<f64>,
    /// <p>The time, in milliseconds since the epoch, when the job was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The job ARN.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
    /// <p>The time, in milliseconds since the epoch, when the job was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>The job summary status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>The ID of the thing group.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
}

/// <p>Describes a key pair.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct KeyPair {
    /// <p>The private key.</p>
    #[serde(rename = "PrivateKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub private_key: Option<String>,
    /// <p>The public key.</p>
    #[serde(rename = "PublicKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public_key: Option<String>,
}

/// <p>Describes an action to write data to an Amazon Kinesis stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KinesisAction {
    /// <p>The partition key.</p>
    #[serde(rename = "partitionKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key: Option<String>,
    /// <p>The ARN of the IAM role that grants access to the Amazon Kinesis stream.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the Amazon Kinesis stream.</p>
    #[serde(rename = "streamName")]
    pub stream_name: String,
}

/// <p>Describes an action to invoke a Lambda function.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LambdaAction {
    /// <p>The ARN of the Lambda function.</p>
    #[serde(rename = "functionArn")]
    pub function_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListActiveViolationsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the Device Defender security profile for which violations are listed.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The name of the thing whose active violations are listed.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListActiveViolationsResponse {
    /// <p>The list of active violations.</p>
    #[serde(rename = "activeViolations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active_violations: Option<Vec<ActiveViolation>>,
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAttachedPoliciesRequest {
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to be returned per request.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>When true, recursively list attached policies.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
    /// <p>The group for which the policies will be listed.</p>
    #[serde(rename = "target")]
    pub target: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListAttachedPoliciesResponse {
    /// <p>The token to retrieve the next set of results, or ``null`` if there are no more results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The policies.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuditFindingsRequest {
    /// <p>A filter to limit results to the findings for the specified audit check.</p>
    #[serde(rename = "checkName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_name: Option<String>,
    /// <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    #[serde(rename = "endTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<f64>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>Information identifying the non-compliant resource.</p>
    #[serde(rename = "resourceIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_identifier: Option<ResourceIdentifier>,
    /// <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<f64>,
    /// <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListAuditFindingsResponse {
    /// <p>The findings (results) of the audit.</p>
    #[serde(rename = "findings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub findings: Option<Vec<AuditFinding>>,
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuditTasksRequest {
    /// <p>The end of the time period.</p>
    #[serde(rename = "endTime")]
    pub end_time: f64,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The beginning of the time period. Note that audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
    #[serde(rename = "startTime")]
    pub start_time: f64,
    /// <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED" or "CANCELED".</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
    /// <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
    #[serde(rename = "taskType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListAuditTasksResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The audits that were performed during the specified time period.</p>
    #[serde(rename = "tasks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tasks: Option<Vec<AuditTaskMetadata>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuthorizersRequest {
    /// <p>Return the list of authorizers in ascending alphabetical order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The status of the list authorizers request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListAuthorizersResponse {
    /// <p>The authorizers.</p>
    #[serde(rename = "authorizers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizers: Option<Vec<AuthorizerSummary>>,
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

/// <p>Input for the ListCACertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListCACertificatesRequest {
    /// <p>Determines the order of the results.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output from the ListCACertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListCACertificatesResponse {
    /// <p>The CA certificates registered in your AWS account.</p>
    #[serde(rename = "certificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<CACertificate>>,
    /// <p>The current position within the list of CA certificates.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

/// <p>The input to the ListCertificatesByCA operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListCertificatesByCARequest {
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
    #[serde(rename = "caCertificateId")]
    pub ca_certificate_id: String,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output of the ListCertificatesByCA operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListCertificatesByCAResponse {
    /// <p>The device certificates signed by the specified CA certificate.</p>
    #[serde(rename = "certificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<Certificate>>,
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

/// <p>The input for the ListCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListCertificatesRequest {
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output of the ListCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListCertificatesResponse {
    /// <p>The descriptions of the certificates.</p>
    #[serde(rename = "certificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<Certificate>>,
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListIndicesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListIndicesResponse {
    /// <p>The index names.</p>
    #[serde(rename = "indexNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_names: Option<Vec<String>>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListJobExecutionsForJobRequest {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>The maximum number of results to be returned per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The status of the job.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListJobExecutionsForJobResponse {
    /// <p>A list of job execution summaries.</p>
    #[serde(rename = "executionSummaries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_summaries: Option<Vec<JobExecutionSummaryForJob>>,
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListJobExecutionsForThingRequest {
    /// <p>The maximum number of results to be returned per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListJobExecutionsForThingResponse {
    /// <p>A list of job execution summaries.</p>
    #[serde(rename = "executionSummaries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_summaries: Option<Vec<JobExecutionSummaryForThing>>,
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListJobsRequest {
    /// <p>The maximum number of results to return per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListJobsResponse {
    /// <p>A list of jobs.</p>
    #[serde(rename = "jobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jobs: Option<Vec<JobSummary>>,
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListOTAUpdatesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token used to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The OTA update job status.</p>
    #[serde(rename = "otaUpdateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListOTAUpdatesResponse {
    /// <p>A token to use to get the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of OTA update jobs.</p>
    #[serde(rename = "otaUpdates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_updates: Option<Vec<OTAUpdateSummary>>,
}

/// <p>The input to the ListOutgoingCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListOutgoingCertificatesRequest {
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output from the ListOutgoingCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListOutgoingCertificatesResponse {
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The certificates that are being transferred but not yet accepted.</p>
    #[serde(rename = "outgoingCertificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outgoing_certificates: Option<Vec<OutgoingCertificate>>,
}

/// <p>The input for the ListPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPoliciesRequest {
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output from the ListPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListPoliciesResponse {
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The descriptions of the policies.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>The input for the ListPolicyPrincipals operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPolicyPrincipalsRequest {
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the ListPolicyPrincipals operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListPolicyPrincipalsResponse {
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The descriptions of the principals.</p>
    #[serde(rename = "principals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principals: Option<Vec<String>>,
}

/// <p>The input for the ListPolicyVersions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPolicyVersionsRequest {
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the ListPolicyVersions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListPolicyVersionsResponse {
    /// <p>The policy versions.</p>
    #[serde(rename = "policyVersions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_versions: Option<Vec<PolicyVersion>>,
}

/// <p>The input for the ListPrincipalPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPrincipalPoliciesRequest {
    /// <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

/// <p>The output from the ListPrincipalPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListPrincipalPoliciesResponse {
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The policies.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>The input for the ListPrincipalThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPrincipalThingsRequest {
    /// <p>The maximum number of results to return in this operation.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

/// <p>The output from the ListPrincipalThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListPrincipalThingsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListRoleAliasesRequest {
    /// <p>Return the list of role aliases in ascending alphabetical order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListRoleAliasesResponse {
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The role aliases.</p>
    #[serde(rename = "roleAliases")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_aliases: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListScheduledAuditsRequest {
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListScheduledAuditsResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The list of scheduled audits.</p>
    #[serde(rename = "scheduledAudits")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audits: Option<Vec<ScheduledAuditMetadata>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListSecurityProfilesForTargetRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>If true, return child groups as well.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
    /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
    #[serde(rename = "securityProfileTargetArn")]
    pub security_profile_target_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListSecurityProfilesForTargetResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of security profiles and their associated targets.</p>
    #[serde(rename = "securityProfileTargetMappings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_target_mappings: Option<Vec<SecurityProfileTargetMapping>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListSecurityProfilesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListSecurityProfilesResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of security profile identifiers (names and ARNs).</p>
    #[serde(rename = "securityProfileIdentifiers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_identifiers: Option<Vec<SecurityProfileIdentifier>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListStreamsRequest {
    /// <p>Set to true to return the list of streams in ascending order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The maximum number of results to return at a time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token used to get the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListStreamsResponse {
    /// <p>A token used to get the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of streams.</p>
    #[serde(rename = "streams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<StreamSummary>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTargetsForPolicyRequest {
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListTargetsForPolicyResponse {
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The policy targets.</p>
    #[serde(rename = "targets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTargetsForSecurityProfileRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The security profile.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListTargetsForSecurityProfileResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups to which the security profile is attached.</p>
    #[serde(rename = "securityProfileTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_targets: Option<Vec<SecurityProfileTarget>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingGroupsForThingRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingGroupsForThingResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups.</p>
    #[serde(rename = "thingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups: Option<Vec<GroupNameAndArn>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingGroupsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A filter that limits the results to those with the specified name prefix.</p>
    #[serde(rename = "namePrefixFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name_prefix_filter: Option<String>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A filter that limits the results to those with the specified parent group.</p>
    #[serde(rename = "parentGroup")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group: Option<String>,
    /// <p>If true, return child groups as well.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingGroupsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups.</p>
    #[serde(rename = "thingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups: Option<Vec<GroupNameAndArn>>,
}

/// <p>The input for the ListThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingPrincipalsRequest {
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the ListThingPrincipals operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingPrincipalsResponse {
    /// <p>The principals associated with the thing.</p>
    #[serde(rename = "principals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principals: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingRegistrationTaskReportsRequest {
    /// <p>The maximum number of results to return per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The type of task report.</p>
    #[serde(rename = "reportType")]
    pub report_type: String,
    /// <p>The id of the task.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingRegistrationTaskReportsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The type of task report.</p>
    #[serde(rename = "reportType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report_type: Option<String>,
    /// <p>Links to the task resources.</p>
    #[serde(rename = "resourceLinks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_links: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingRegistrationTasksRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The status of the bulk thing provisioning task.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingRegistrationTasksResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of bulk thing provisioning task IDs.</p>
    #[serde(rename = "taskIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_ids: Option<Vec<String>>,
}

/// <p>The input for the ListThingTypes operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingTypesRequest {
    /// <p>The maximum number of results to return in this operation.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output for the ListThingTypes operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingTypesResponse {
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing types.</p>
    #[serde(rename = "thingTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_types: Option<Vec<ThingTypeDefinition>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingsInThingGroupRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>When true, list things in this thing group and in all child groups as well.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
    /// <p>The thing group name.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingsInThingGroupResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things in the specified thing group.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<String>>,
}

/// <p>The input for the ListThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingsRequest {
    /// <p>The attribute name used to search for things.</p>
    #[serde(rename = "attributeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_name: Option<String>,
    /// <p>The attribute value used to search for things.</p>
    #[serde(rename = "attributeValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_value: Option<String>,
    /// <p>The maximum number of results to return in this operation.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the thing type used to search for things.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output from the ListThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListThingsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<ThingAttribute>>,
}

/// <p>The input for the ListTopicRules operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTopicRulesRequest {
    /// <p>The maximum number of results to return.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token used to retrieve the next value.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The topic.</p>
    #[serde(rename = "topic")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// <p>The output from the ListTopicRules operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListTopicRulesResponse {
    /// <p>A token used to retrieve the next value.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The rules.</p>
    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<TopicRuleListItem>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListV2LoggingLevelsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    #[serde(rename = "targetType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListV2LoggingLevelsResponse {
    /// <p>The logging configuration for a target.</p>
    #[serde(rename = "logTargetConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_target_configurations: Option<Vec<LogTargetConfiguration>>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListViolationEventsRequest {
    /// <p>The end time for the alerts to be listed.</p>
    #[serde(rename = "endTime")]
    pub end_time: f64,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The start time for the alerts to be listed.</p>
    #[serde(rename = "startTime")]
    pub start_time: f64,
    /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ListViolationEventsResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The security profile violation alerts issued for this account during the given time frame, potentially filtered by security profile, behavior violated, or thing (device) violating.</p>
    #[serde(rename = "violationEvents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_events: Option<Vec<ViolationEvent>>,
}

/// <p>A log target.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogTarget {
    /// <p>The target name.</p>
    #[serde(rename = "targetName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_name: Option<String>,
    /// <p>The target type.</p>
    #[serde(rename = "targetType")]
    pub target_type: String,
}

/// <p>The target configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct LogTargetConfiguration {
    /// <p>The logging level.</p>
    #[serde(rename = "logLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_level: Option<String>,
    /// <p>A log target</p>
    #[serde(rename = "logTarget")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_target: Option<LogTarget>,
}

/// <p>Describes the logging options payload.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct LoggingOptionsPayload {
    /// <p>The log level.</p>
    #[serde(rename = "logLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_level: Option<String>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>The value to be compared with the <code>metric</code>.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MetricValue {
    /// <p>If the <code>comparisonOperator</code> calls for a set of CIDRs, use this to specify that set to be compared with the <code>metric</code>.</p>
    #[serde(rename = "cidrs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cidrs: Option<Vec<String>>,
    /// <p>If the <code>comparisonOperator</code> calls for a numeric value, use this to specify that numeric value to be compared with the <code>metric</code>.</p>
    #[serde(rename = "count")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// <p>If the <code>comparisonOperator</code> calls for a set of ports, use this to specify that set to be compared with the <code>metric</code>.</p>
    #[serde(rename = "ports")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<i64>>,
}

/// <p>Information about the resource that was non-compliant with the audit check.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct NonCompliantResource {
    /// <p>Additional information about the non-compliant resource.</p>
    #[serde(rename = "additionalInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_info: Option<::std::collections::HashMap<String, String>>,
    /// <p>Information identifying the non-compliant resource.</p>
    #[serde(rename = "resourceIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_identifier: Option<ResourceIdentifier>,
    /// <p>The type of the non-compliant resource.</p>
    #[serde(rename = "resourceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_type: Option<String>,
}

/// <p>Describes a file to be associated with an OTA update.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OTAUpdateFile {
    /// <p>A list of name/attribute pairs.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The code signing method of the file.</p>
    #[serde(rename = "codeSigning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_signing: Option<CodeSigning>,
    /// <p>The name of the file.</p>
    #[serde(rename = "fileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_name: Option<String>,
    /// <p>The source of the file.</p>
    #[serde(rename = "fileSource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_source: Option<Stream>,
    /// <p>The file version.</p>
    #[serde(rename = "fileVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_version: Option<String>,
}

/// <p>Information about an OTA update.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct OTAUpdateInfo {
    /// <p>A collection of name/value pairs</p>
    #[serde(rename = "additionalParameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_parameters: Option<::std::collections::HashMap<String, String>>,
    /// <p>The AWS IoT job ARN associated with the OTA update.</p>
    #[serde(rename = "awsIotJobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_arn: Option<String>,
    /// <p>The AWS IoT job ID associated with the OTA update.</p>
    #[serde(rename = "awsIotJobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_id: Option<String>,
    /// <p>The date when the OTA update was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>A description of the OTA update.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>Error information associated with the OTA update.</p>
    #[serde(rename = "errorInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_info: Option<ErrorInfo>,
    /// <p>The date when the OTA update was last updated.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The OTA update ARN.</p>
    #[serde(rename = "otaUpdateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_arn: Option<String>,
    /// <p>A list of files associated with the OTA update.</p>
    #[serde(rename = "otaUpdateFiles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_files: Option<Vec<OTAUpdateFile>>,
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_id: Option<String>,
    /// <p>The status of the OTA update.</p>
    #[serde(rename = "otaUpdateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_status: Option<String>,
    /// <p>Specifies whether the OTA update will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the OTA update (SNAPSHOT). If continuous, the OTA update may also be run on a thing when a change is detected in a target. For example, an OTA update will run on a thing when the thing is added to a target group, even after the OTA update was completed by all things originally in the group. </p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>The targets of the OTA update.</p>
    #[serde(rename = "targets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// <p>An OTA update summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct OTAUpdateSummary {
    /// <p>The date when the OTA update was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The OTA update ARN.</p>
    #[serde(rename = "otaUpdateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_arn: Option<String>,
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_id: Option<String>,
}

/// <p>A certificate that has been transferred but not yet accepted.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct OutgoingCertificate {
    /// <p>The certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The certificate ID.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate creation date.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The date the transfer was initiated.</p>
    #[serde(rename = "transferDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_date: Option<f64>,
    /// <p>The transfer message.</p>
    #[serde(rename = "transferMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_message: Option<String>,
    /// <p>The AWS account to which the transfer was made.</p>
    #[serde(rename = "transferredTo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transferred_to: Option<String>,
}

/// <p>Describes an AWS IoT policy.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct Policy {
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}

/// <p>Describes a policy version.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct PolicyVersion {
    /// <p>The date and time the policy was created.</p>
    #[serde(rename = "createDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub create_date: Option<f64>,
    /// <p>Specifies whether the policy version is the default.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<String>,
}

/// <p>Information about the version of the policy associated with the resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PolicyVersionIdentifier {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    /// <p>The ID of the version of the policy associated with the resource.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

/// <p>Configuration for pre-signed S3 URLs.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PresignedUrlConfig {
    /// <p>How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.</p>
    #[serde(rename = "expiresInSec")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_in_sec: Option<i64>,
    /// <p>The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>The input for the DynamoActionVS action that specifies the DynamoDB table to which the message data will be written.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutItemInput {
    /// <p>The table where the message data will be written</p>
    #[serde(rename = "tableName")]
    pub table_name: String,
}

/// <p>The input to the RegisterCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RegisterCACertificateRequest {
    /// <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
    #[serde(rename = "allowAutoRegistration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_auto_registration: Option<bool>,
    /// <p>The CA certificate.</p>
    #[serde(rename = "caCertificate")]
    pub ca_certificate: String,
    /// <p>Information about the registration configuration.</p>
    #[serde(rename = "registrationConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_config: Option<RegistrationConfig>,
    /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
    /// <p>The private key verification certificate.</p>
    #[serde(rename = "verificationCertificate")]
    pub verification_certificate: String,
}

/// <p>The output from the RegisterCACertificateResponse operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct RegisterCACertificateResponse {
    /// <p>The CA certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The CA certificate identifier.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
}

/// <p>The input to the RegisterCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RegisterCertificateRequest {
    /// <p>The CA certificate used to sign the device certificate being registered.</p>
    #[serde(rename = "caCertificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ca_certificate_pem: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    pub certificate_pem: String,
    /// <p>The status of the register certificate request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>The output from the RegisterCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct RegisterCertificateResponse {
    /// <p>The certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The certificate identifier.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RegisterThingRequest {
    /// <p>The parameters for provisioning a thing. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html">Programmatic Provisioning</a> for more information.</p>
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<::std::collections::HashMap<String, String>>,
    /// <p>The provisioning template. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html">Programmatic Provisioning</a> for more information.</p>
    #[serde(rename = "templateBody")]
    pub template_body: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct RegisterThingResponse {
    /// <p>.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>ARNs for the generated resources.</p>
    #[serde(rename = "resourceArns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_arns: Option<::std::collections::HashMap<String, String>>,
}

/// <p>The registration configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RegistrationConfig {
    /// <p>The ARN of the role.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The template body.</p>
    #[serde(rename = "templateBody")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_body: Option<String>,
}

/// <p>The input for the RejectCertificateTransfer operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RejectCertificateTransferRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The reason the certificate transfer was rejected.</p>
    #[serde(rename = "rejectReason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

/// <p>Information about a related resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct RelatedResource {
    /// <p>Additional information about the resource.</p>
    #[serde(rename = "additionalInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_info: Option<::std::collections::HashMap<String, String>>,
    /// <p>Information identifying the resource.</p>
    #[serde(rename = "resourceIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_identifier: Option<ResourceIdentifier>,
    /// <p>The type of resource.</p>
    #[serde(rename = "resourceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RemoveThingFromThingGroupRequest {
    /// <p>The ARN of the thing to remove from the group.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The group name.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
    /// <p>The name of the thing to remove from the group.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct RemoveThingFromThingGroupResponse {}

/// <p>The input for the ReplaceTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ReplaceTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
    /// <p>The rule payload.</p>
    #[serde(rename = "topicRulePayload")]
    pub topic_rule_payload: TopicRulePayload,
}

/// <p>Describes an action to republish to another topic.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepublishAction {
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the MQTT topic.</p>
    #[serde(rename = "topic")]
    pub topic: String,
}

/// <p>Information identifying the non-compliant resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResourceIdentifier {
    /// <p>The account with which the resource is associated.</p>
    #[serde(rename = "account")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account: Option<String>,
    /// <p>The ID of the CA certificate used to authorize the certificate.</p>
    #[serde(rename = "caCertificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ca_certificate_id: Option<String>,
    /// <p>The client ID.</p>
    #[serde(rename = "clientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    /// <p>The ID of the Cognito Identity Pool.</p>
    #[serde(rename = "cognitoIdentityPoolId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cognito_identity_pool_id: Option<String>,
    /// <p>The ID of the certificate attached to the resource.</p>
    #[serde(rename = "deviceCertificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub device_certificate_id: Option<String>,
    /// <p>The version of the policy associated with the resource.</p>
    #[serde(rename = "policyVersionIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_identifier: Option<PolicyVersionIdentifier>,
}

/// <p>Role alias description.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct RoleAliasDescription {
    /// <p>The UNIX timestamp of when the role alias was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The number of seconds for which the credential is valid.</p>
    #[serde(rename = "credentialDurationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential_duration_seconds: Option<i64>,
    /// <p>The UNIX timestamp of when the role alias was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The role alias owner.</p>
    #[serde(rename = "owner")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<String>,
    /// <p>The role alias.</p>
    #[serde(rename = "roleAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias: Option<String>,
    /// <p>The ARN of the role alias.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
    /// <p>The role ARN.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>Describes an action to write data to an Amazon S3 bucket.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct S3Action {
    /// <p>The Amazon S3 bucket.</p>
    #[serde(rename = "bucketName")]
    pub bucket_name: String,
    /// <p>The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">S3 canned ACLs</a>.</p>
    #[serde(rename = "cannedAcl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canned_acl: Option<String>,
    /// <p>The object key.</p>
    #[serde(rename = "key")]
    pub key: String,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>The location in S3 the contains the files to stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct S3Location {
    /// <p>The S3 bucket that contains the file to stream.</p>
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// <p>The name of the file within the S3 bucket to stream.</p>
    #[serde(rename = "key")]
    pub key: String,
    /// <p>The file version.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// <p>Describes an action to write a message to a Salesforce IoT Cloud Input Stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SalesforceAction {
    /// <p>The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The token is available from the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
    #[serde(rename = "token")]
    pub token: String,
    /// <p>The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
    #[serde(rename = "url")]
    pub url: String,
}

/// <p>Information about the scheduled audit.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ScheduledAuditMetadata {
    /// <p>The day of the month on which the scheduled audit is run (if the <code>frequency</code> is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit is run (if the <code>frequency</code> is "WEEKLY" or "BIWEEKLY").</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place.</p>
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<String>,
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
    /// <p>The name of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SearchIndexRequest {
    /// <p>The search index name.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The search query string.</p>
    #[serde(rename = "queryString")]
    pub query_string: String,
    /// <p>The query version.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct SearchIndexResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things that match the search query.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<ThingDocument>>,
}

/// <p>Identifying information for a Device Defender security profile.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct SecurityProfileIdentifier {
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "arn")]
    pub arn: String,
    /// <p>The name you have given to the security profile.</p>
    #[serde(rename = "name")]
    pub name: String,
}

/// <p>A target to which an alert is sent when a security profile behavior is violated.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct SecurityProfileTarget {
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "arn")]
    pub arn: String,
}

/// <p>Information about a security profile and the target associated with it.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct SecurityProfileTargetMapping {
    /// <p>Information that identifies the security profile.</p>
    #[serde(rename = "securityProfileIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_identifier: Option<SecurityProfileIdentifier>,
    /// <p>Information about the target (thing group) associated with the security profile.</p>
    #[serde(rename = "target")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<SecurityProfileTarget>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetDefaultAuthorizerRequest {
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct SetDefaultAuthorizerResponse {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

/// <p>The input for the SetDefaultPolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetDefaultPolicyVersionRequest {
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    pub policy_version_id: String,
}

/// <p>The input for the SetLoggingOptions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetLoggingOptionsRequest {
    /// <p>The logging options payload.</p>
    #[serde(rename = "loggingOptionsPayload")]
    pub logging_options_payload: LoggingOptionsPayload,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetV2LoggingLevelRequest {
    /// <p>The log level.</p>
    #[serde(rename = "logLevel")]
    pub log_level: String,
    /// <p>The log target.</p>
    #[serde(rename = "logTarget")]
    pub log_target: LogTarget,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetV2LoggingOptionsRequest {
    /// <p>The default logging level.</p>
    #[serde(rename = "defaultLogLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_log_level: Option<String>,
    /// <p>If true all logs are disabled. The default is false.</p>
    #[serde(rename = "disableAllLogs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_all_logs: Option<bool>,
    /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>Describes an action to publish to an Amazon SNS topic.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SnsAction {
    /// <p>(Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see <a href="http://docs.aws.amazon.com/sns/latest/dg/json-formats.html">http://docs.aws.amazon.com/sns/latest/dg/json-formats.html</a> refer to their official documentation.</p>
    #[serde(rename = "messageFormat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_format: Option<String>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The ARN of the SNS topic.</p>
    #[serde(rename = "targetArn")]
    pub target_arn: String,
}

/// <p>Describes an action to publish data to an Amazon SQS queue.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SqsAction {
    /// <p>The URL of the Amazon SQS queue.</p>
    #[serde(rename = "queueUrl")]
    pub queue_url: String,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>Specifies whether to use Base64 encoding.</p>
    #[serde(rename = "useBase64")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub use_base_64: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StartOnDemandAuditTaskRequest {
    /// <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
    #[serde(rename = "targetCheckNames")]
    pub target_check_names: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct StartOnDemandAuditTaskResponse {
    /// <p>The ID of the on-demand audit you started.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StartThingRegistrationTaskRequest {
    /// <p>The S3 bucket that contains the input file.</p>
    #[serde(rename = "inputFileBucket")]
    pub input_file_bucket: String,
    /// <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
    #[serde(rename = "inputFileKey")]
    pub input_file_key: String,
    /// <p>The IAM role ARN that grants permission the input file.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The provisioning template.</p>
    #[serde(rename = "templateBody")]
    pub template_body: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct StartThingRegistrationTaskResponse {
    /// <p>The bulk thing provisioning task ID.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

/// <p>Starts execution of a Step Functions state machine.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StepFunctionsAction {
    /// <p>(Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.</p>
    #[serde(rename = "executionNamePrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_name_prefix: Option<String>,
    /// <p>The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the Step Functions state machine whose execution will be started.</p>
    #[serde(rename = "stateMachineName")]
    pub state_machine_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StopThingRegistrationTaskRequest {
    /// <p>The bulk thing provisioning task ID.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct StopThingRegistrationTaskResponse {}

/// <p>Describes a group of files that can be streamed.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Stream {
    /// <p>The ID of a file associated with a stream.</p>
    #[serde(rename = "fileId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<i64>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
}

/// <p>Represents a file to stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StreamFile {
    /// <p>The file ID.</p>
    #[serde(rename = "fileId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<i64>,
    /// <p>The location of the file in S3.</p>
    #[serde(rename = "s3Location")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_3_location: Option<S3Location>,
}

/// <p>Information about a stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct StreamInfo {
    /// <p>The date when the stream was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files to stream.</p>
    #[serde(rename = "files")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<StreamFile>>,
    /// <p>The date when the stream was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>An IAM role AWS IoT assumes to access your S3 files.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The stream version.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

/// <p>A summary of a stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct StreamSummary {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The stream version.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

/// <p>Statistics for the checks performed during the audit.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TaskStatistics {
    /// <p>The number of checks that did not run because the audit was canceled.</p>
    #[serde(rename = "canceledChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canceled_checks: Option<i64>,
    /// <p>The number of checks that found compliant resources.</p>
    #[serde(rename = "compliantChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compliant_checks: Option<i64>,
    /// <p>The number of checks </p>
    #[serde(rename = "failedChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failed_checks: Option<i64>,
    /// <p>The number of checks in progress.</p>
    #[serde(rename = "inProgressChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub in_progress_checks: Option<i64>,
    /// <p>The number of checks that found non-compliant resources.</p>
    #[serde(rename = "nonCompliantChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_compliant_checks: Option<i64>,
    /// <p>The number of checks in this audit.</p>
    #[serde(rename = "totalChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_checks: Option<i64>,
    /// <p>The number of checks waiting for data collection.</p>
    #[serde(rename = "waitingForDataCollectionChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub waiting_for_data_collection_checks: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TestAuthorizationRequest {
    /// <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
    #[serde(rename = "authInfos")]
    pub auth_infos: Vec<AuthInfo>,
    /// <p>The MQTT client ID.</p>
    #[serde(rename = "clientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    /// <p>The Cognito identity pool ID.</p>
    #[serde(rename = "cognitoIdentityPoolId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cognito_identity_pool_id: Option<String>,
    /// <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
    #[serde(rename = "policyNamesToAdd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_names_to_add: Option<Vec<String>>,
    /// <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
    #[serde(rename = "policyNamesToSkip")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_names_to_skip: Option<Vec<String>>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principal: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TestAuthorizationResponse {
    /// <p>The authentication results.</p>
    #[serde(rename = "authResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_results: Option<Vec<AuthResult>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TestInvokeAuthorizerRequest {
    /// <p>The custom authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
    /// <p>The token returned by your custom authentication service.</p>
    #[serde(rename = "token")]
    pub token: String,
    /// <p>The signature made with the token and your custom authentication service's private key.</p>
    #[serde(rename = "tokenSignature")]
    pub token_signature: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TestInvokeAuthorizerResponse {
    /// <p>The number of seconds after which the connection is terminated.</p>
    #[serde(rename = "disconnectAfterInSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disconnect_after_in_seconds: Option<i64>,
    /// <p>True if the token is authenticated, otherwise false.</p>
    #[serde(rename = "isAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_authenticated: Option<bool>,
    /// <p>IAM policy documents.</p>
    #[serde(rename = "policyDocuments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_documents: Option<Vec<String>>,
    /// <p>The principal ID.</p>
    #[serde(rename = "principalId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,
    /// <p>The number of seconds after which the temporary credentials are refreshed.</p>
    #[serde(rename = "refreshAfterInSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refresh_after_in_seconds: Option<i64>,
}

/// <p>The properties of the thing, including thing name, thing type name, and a list of thing attributes.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ThingAttribute {
    /// <p>A list of thing attributes which are name-value pairs.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The thing ARN.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The name of the thing type, if the thing has been associated with a type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p>The version of the thing record in the registry.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// <p>The thing search index document.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ThingDocument {
    /// <p>The attributes.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The shadow.</p>
    #[serde(rename = "shadow")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shadow: Option<String>,
    /// <p>Thing group names.</p>
    #[serde(rename = "thingGroupNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_names: Option<Vec<String>>,
    /// <p>The thing ID.</p>
    #[serde(rename = "thingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_id: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The thing type name.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>Thing group metadata.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ThingGroupMetadata {
    /// <p>The UNIX timestamp of when the thing group was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The parent thing group name.</p>
    #[serde(rename = "parentGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group_name: Option<String>,
    /// <p>The root parent thing group.</p>
    #[serde(rename = "rootToParentThingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub root_to_parent_thing_groups: Option<Vec<GroupNameAndArn>>,
}

/// <p>Thing group properties.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingGroupProperties {
    /// <p>The thing group attributes in JSON format.</p>
    #[serde(rename = "attributePayload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_payload: Option<AttributePayload>,
    /// <p>The thing group description.</p>
    #[serde(rename = "thingGroupDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_description: Option<String>,
}

/// <p>Thing indexing configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingIndexingConfiguration {
    /// <p><p>Thing indexing mode. Valid values are: </p> <ul> <li> <p>REGISTRY – Your thing index will contain only registry data.</p> </li> <li> <p>REGISTRY<em>AND</em>SHADOW - Your thing index will contain registry and shadow data.</p> </li> <li> <p>OFF - Thing indexing is disabled.</p> </li> </ul></p>
    #[serde(rename = "thingIndexingMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_indexing_mode: Option<String>,
}

/// <p>The definition of the thing type, including thing type name and description.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ThingTypeDefinition {
    /// <p>The thing type ARN.</p>
    #[serde(rename = "thingTypeArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_arn: Option<String>,
    /// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.</p>
    #[serde(rename = "thingTypeMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_metadata: Option<ThingTypeMetadata>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p>The ThingTypeProperties for the thing type.</p>
    #[serde(rename = "thingTypeProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_properties: Option<ThingTypeProperties>,
}

/// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when time was deprecated.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ThingTypeMetadata {
    /// <p>The date and time when the thing type was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>Whether the thing type is deprecated. If <b>true</b>, no new things could be associated with this type.</p>
    #[serde(rename = "deprecated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<bool>,
    /// <p>The date and time when the thing type was deprecated.</p>
    #[serde(rename = "deprecationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deprecation_date: Option<f64>,
}

/// <p>The ThingTypeProperties contains information about the thing type including: a thing type description, and a list of searchable thing attribute names.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingTypeProperties {
    /// <p>A list of searchable thing attribute names.</p>
    #[serde(rename = "searchableAttributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub searchable_attributes: Option<Vec<String>>,
    /// <p>The description of the thing type.</p>
    #[serde(rename = "thingTypeDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_description: Option<String>,
}

/// <p>Describes a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TopicRule {
    /// <p>The actions associated with the rule.</p>
    #[serde(rename = "actions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<Action>>,
    /// <p>The version of the SQL rules engine to use when evaluating the rule.</p>
    #[serde(rename = "awsIotSqlVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_sql_version: Option<String>,
    /// <p>The date and time the rule was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The description of the rule.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The action to perform when an error occurs.</p>
    #[serde(rename = "errorAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_action: Option<Action>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
    /// <p>The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.</p>
    #[serde(rename = "sql")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sql: Option<String>,
}

/// <p>Describes a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TopicRuleListItem {
    /// <p>The date and time the rule was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The rule ARN.</p>
    #[serde(rename = "ruleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_arn: Option<String>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
    /// <p>The pattern for the topic names that apply.</p>
    #[serde(rename = "topicPattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_pattern: Option<String>,
}

/// <p>Describes a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TopicRulePayload {
    /// <p>The actions associated with the rule.</p>
    #[serde(rename = "actions")]
    pub actions: Vec<Action>,
    /// <p>The version of the SQL rules engine to use when evaluating the rule.</p>
    #[serde(rename = "awsIotSqlVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_sql_version: Option<String>,
    /// <p>The description of the rule.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The action to take when an error occurs.</p>
    #[serde(rename = "errorAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_action: Option<Action>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The SQL statement used to query the topic. For more information, see <a href="http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference">AWS IoT SQL Reference</a> in the <i>AWS IoT Developer Guide</i>.</p>
    #[serde(rename = "sql")]
    pub sql: String,
}

/// <p>The input for the TransferCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TransferCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The AWS account.</p>
    #[serde(rename = "targetAwsAccount")]
    pub target_aws_account: String,
    /// <p>The transfer message.</p>
    #[serde(rename = "transferMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_message: Option<String>,
}

/// <p>The output from the TransferCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TransferCertificateResponse {
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "transferredCertificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transferred_certificate_arn: Option<String>,
}

/// <p>Data used to transfer a certificate to an AWS account.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct TransferData {
    /// <p>The date the transfer was accepted.</p>
    #[serde(rename = "acceptDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub accept_date: Option<f64>,
    /// <p>The date the transfer was rejected.</p>
    #[serde(rename = "rejectDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject_date: Option<f64>,
    /// <p>The reason why the transfer was rejected.</p>
    #[serde(rename = "rejectReason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
    /// <p>The date the transfer took place.</p>
    #[serde(rename = "transferDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_date: Option<f64>,
    /// <p>The transfer message.</p>
    #[serde(rename = "transferMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_message: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateAccountAuditConfigurationRequest {
    /// <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are currently enabled.</p> <p>Note that some data collection may begin immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p> <p>You cannot disable a check if it is used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p> <p>On the first call to <code>UpdateAccountAuditConfiguration</code> this parameter is required and must specify at least one enabled check.</p>
    #[serde(rename = "auditCheckConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_check_configurations:
        Option<::std::collections::HashMap<String, AuditCheckConfiguration>>,
    /// <p>Information about the targets to which audit notifications are sent.</p>
    #[serde(rename = "auditNotificationTargetConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_notification_target_configurations:
        Option<::std::collections::HashMap<String, AuditNotificationTarget>>,
    /// <p>The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates and other items as necessary when performing an audit.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateAccountAuditConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateAuthorizerRequest {
    /// <p>The ARN of the authorizer's Lambda function.</p>
    #[serde(rename = "authorizerFunctionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_function_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
    /// <p>The status of the update authorizer request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The key used to extract the token from the HTTP headers. </p>
    #[serde(rename = "tokenKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_key_name: Option<String>,
    /// <p>The public keys used to verify the token signature.</p>
    #[serde(rename = "tokenSigningPublicKeys")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_signing_public_keys: Option<::std::collections::HashMap<String, String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateAuthorizerResponse {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

/// <p>The input to the UpdateCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateCACertificateRequest {
    /// <p>The CA certificate identifier.</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
    #[serde(rename = "newAutoRegistrationStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_auto_registration_status: Option<String>,
    /// <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "newStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_status: Option<String>,
    /// <p>Information about the registration configuration.</p>
    #[serde(rename = "registrationConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_config: Option<RegistrationConfig>,
    /// <p>If true, remove auto registration.</p>
    #[serde(rename = "removeAutoRegistration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_auto_registration: Option<bool>,
}

/// <p>The input for the UpdateCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "newStatus")]
    pub new_status: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateEventConfigurationsRequest {
    /// <p>The new event configuration values.</p>
    #[serde(rename = "eventConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_configurations: Option<::std::collections::HashMap<String, Configuration>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateEventConfigurationsResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateIndexingConfigurationRequest {
    /// <p>Thing indexing configuration.</p>
    #[serde(rename = "thingIndexingConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_indexing_configuration: Option<ThingIndexingConfiguration>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateIndexingConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateRoleAliasRequest {
    /// <p>The number of seconds the credential will be valid.</p>
    #[serde(rename = "credentialDurationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential_duration_seconds: Option<i64>,
    /// <p>The role alias to update.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
    /// <p>The role ARN.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateRoleAliasResponse {
    /// <p>The role alias.</p>
    #[serde(rename = "roleAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias: Option<String>,
    /// <p>The role alias ARN.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateScheduledAuditRequest {
    /// <p>The day of the month on which the scheduled audit takes place. Can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to "MONTHLY". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit takes place. Can be one of "SUN", "MON", "TUE", "WED", "THU", "FRI" or "SAT". This field is required if the "frequency" parameter is set to "WEEKLY" or "BIWEEKLY".</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place. Can be one of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The actual start time of each audit is determined by the system.</p>
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<String>,
    /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    #[serde(rename = "targetCheckNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_check_names: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateScheduledAuditResponse {
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateSecurityProfileRequest {
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different than the actual version, a <code>VersionConflictException</code> is thrown.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>A description of the security profile.</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name of the security profile you want to update.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateSecurityProfileResponse {
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>The time the security profile was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The time the security profile was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the security profile that was updated.</p>
    #[serde(rename = "securityProfileArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_arn: Option<String>,
    /// <p>The description of the security profile.</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name of the security profile that was updated.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The updated version of the security profile.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateStreamRequest {
    /// <p>The description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files associated with the stream.</p>
    #[serde(rename = "files")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<StreamFile>>,
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateStreamResponse {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The stream version.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateThingGroupRequest {
    /// <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The thing group to update.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
    /// <p>The thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    pub thing_group_properties: ThingGroupProperties,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateThingGroupResponse {
    /// <p>The version of the updated thing group.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateThingGroupsForThingRequest {
    /// <p>The groups to which the thing will be added.</p>
    #[serde(rename = "thingGroupsToAdd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups_to_add: Option<Vec<String>>,
    /// <p>The groups from which the thing will be removed.</p>
    #[serde(rename = "thingGroupsToRemove")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups_to_remove: Option<Vec<String>>,
    /// <p>The thing whose group memberships will be updated.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateThingGroupsForThingResponse {}

/// <p>The input for the UpdateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateThingRequest {
    /// <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p> <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p> <p>This data is used to add new attributes or update existing attributes.</p>
    #[serde(rename = "attributePayload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_payload: Option<AttributePayload>,
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
    #[serde(rename = "removeThingType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_thing_type: Option<bool>,
    /// <p>The name of the thing to update.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output from the UpdateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct UpdateThingResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ValidateSecurityProfileBehaviorsRequest {
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    pub behaviors: Vec<Behavior>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ValidateSecurityProfileBehaviorsResponse {
    /// <p>True if the behaviors were valid.</p>
    #[serde(rename = "valid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid: Option<bool>,
    /// <p>The list of any errors found in the behaviors.</p>
    #[serde(rename = "validationErrors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validation_errors: Option<Vec<ValidationError>>,
}

/// <p>Information about an error found in a behavior specification.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ValidationError {
    /// <p>The description of an error found in the behaviors.</p>
    #[serde(rename = "errorMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
}

/// <p>Information about a Device Defender security profile behavior violation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(test, derive(Serialize))]
pub struct ViolationEvent {
    /// <p>The behavior which was violated.</p>
    #[serde(rename = "behavior")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behavior: Option<Behavior>,
    /// <p>The value of the metric (the measurement).</p>
    #[serde(rename = "metricValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metric_value: Option<MetricValue>,
    /// <p>The name of the security profile whose behavior was violated.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The name of the thing responsible for the violation event.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The time the violation event occurred.</p>
    #[serde(rename = "violationEventTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_event_time: Option<f64>,
    /// <p>The type of violation event.</p>
    #[serde(rename = "violationEventType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_event_type: Option<String>,
    /// <p>The ID of the violation event.</p>
    #[serde(rename = "violationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_id: Option<String>,
}

/// Errors returned by AcceptCertificateTransfer
#[derive(Debug, PartialEq)]
pub enum AcceptCertificateTransferError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't revert the certificate transfer because the transfer is already complete.</p>
    TransferAlreadyCompleted(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AcceptCertificateTransferError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AcceptCertificateTransferError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return AcceptCertificateTransferError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return AcceptCertificateTransferError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return AcceptCertificateTransferError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return AcceptCertificateTransferError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return AcceptCertificateTransferError::Throttling(String::from(error_message))
                }
                "TransferAlreadyCompletedException" => {
                    return AcceptCertificateTransferError::TransferAlreadyCompleted(String::from(
                        error_message,
                    ))
                }
                "UnauthorizedException" => {
                    return AcceptCertificateTransferError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return AcceptCertificateTransferError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AcceptCertificateTransferError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AcceptCertificateTransferError {
    fn from(err: serde_json::error::Error) -> AcceptCertificateTransferError {
        AcceptCertificateTransferError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AcceptCertificateTransferError {
    fn from(err: CredentialsError) -> AcceptCertificateTransferError {
        AcceptCertificateTransferError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AcceptCertificateTransferError {
    fn from(err: HttpDispatchError) -> AcceptCertificateTransferError {
        AcceptCertificateTransferError::HttpDispatch(err)
    }
}
impl From<io::Error> for AcceptCertificateTransferError {
    fn from(err: io::Error) -> AcceptCertificateTransferError {
        AcceptCertificateTransferError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AcceptCertificateTransferError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AcceptCertificateTransferError {
    fn description(&self) -> &str {
        match *self {
            AcceptCertificateTransferError::InternalFailure(ref cause) => cause,
            AcceptCertificateTransferError::InvalidRequest(ref cause) => cause,
            AcceptCertificateTransferError::ResourceNotFound(ref cause) => cause,
            AcceptCertificateTransferError::ServiceUnavailable(ref cause) => cause,
            AcceptCertificateTransferError::Throttling(ref cause) => cause,
            AcceptCertificateTransferError::TransferAlreadyCompleted(ref cause) => cause,
            AcceptCertificateTransferError::Unauthorized(ref cause) => cause,
            AcceptCertificateTransferError::Validation(ref cause) => cause,
            AcceptCertificateTransferError::Credentials(ref err) => err.description(),
            AcceptCertificateTransferError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            AcceptCertificateTransferError::ParseError(ref cause) => cause,
            AcceptCertificateTransferError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by AddThingToThingGroup
#[derive(Debug, PartialEq)]
pub enum AddThingToThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AddThingToThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AddThingToThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return AddThingToThingGroupError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return AddThingToThingGroupError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return AddThingToThingGroupError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return AddThingToThingGroupError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return AddThingToThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AddThingToThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AddThingToThingGroupError {
    fn from(err: serde_json::error::Error) -> AddThingToThingGroupError {
        AddThingToThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AddThingToThingGroupError {
    fn from(err: CredentialsError) -> AddThingToThingGroupError {
        AddThingToThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AddThingToThingGroupError {
    fn from(err: HttpDispatchError) -> AddThingToThingGroupError {
        AddThingToThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for AddThingToThingGroupError {
    fn from(err: io::Error) -> AddThingToThingGroupError {
        AddThingToThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AddThingToThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AddThingToThingGroupError {
    fn description(&self) -> &str {
        match *self {
            AddThingToThingGroupError::InternalFailure(ref cause) => cause,
            AddThingToThingGroupError::InvalidRequest(ref cause) => cause,
            AddThingToThingGroupError::ResourceNotFound(ref cause) => cause,
            AddThingToThingGroupError::Throttling(ref cause) => cause,
            AddThingToThingGroupError::Validation(ref cause) => cause,
            AddThingToThingGroupError::Credentials(ref err) => err.description(),
            AddThingToThingGroupError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            AddThingToThingGroupError::ParseError(ref cause) => cause,
            AddThingToThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by AssociateTargetsWithJob
#[derive(Debug, PartialEq)]
pub enum AssociateTargetsWithJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AssociateTargetsWithJobError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AssociateTargetsWithJobError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return AssociateTargetsWithJobError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return AssociateTargetsWithJobError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return AssociateTargetsWithJobError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return AssociateTargetsWithJobError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return AssociateTargetsWithJobError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return AssociateTargetsWithJobError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AssociateTargetsWithJobError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AssociateTargetsWithJobError {
    fn from(err: serde_json::error::Error) -> AssociateTargetsWithJobError {
        AssociateTargetsWithJobError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AssociateTargetsWithJobError {
    fn from(err: CredentialsError) -> AssociateTargetsWithJobError {
        AssociateTargetsWithJobError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AssociateTargetsWithJobError {
    fn from(err: HttpDispatchError) -> AssociateTargetsWithJobError {
        AssociateTargetsWithJobError::HttpDispatch(err)
    }
}
impl From<io::Error> for AssociateTargetsWithJobError {
    fn from(err: io::Error) -> AssociateTargetsWithJobError {
        AssociateTargetsWithJobError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AssociateTargetsWithJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AssociateTargetsWithJobError {
    fn description(&self) -> &str {
        match *self {
            AssociateTargetsWithJobError::InvalidRequest(ref cause) => cause,
            AssociateTargetsWithJobError::LimitExceeded(ref cause) => cause,
            AssociateTargetsWithJobError::ResourceNotFound(ref cause) => cause,
            AssociateTargetsWithJobError::ServiceUnavailable(ref cause) => cause,
            AssociateTargetsWithJobError::Throttling(ref cause) => cause,
            AssociateTargetsWithJobError::Validation(ref cause) => cause,
            AssociateTargetsWithJobError::Credentials(ref err) => err.description(),
            AssociateTargetsWithJobError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            AssociateTargetsWithJobError::ParseError(ref cause) => cause,
            AssociateTargetsWithJobError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by AttachPolicy
#[derive(Debug, PartialEq)]
pub enum AttachPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AttachPolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AttachPolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return AttachPolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return AttachPolicyError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return AttachPolicyError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return AttachPolicyError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return AttachPolicyError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return AttachPolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return AttachPolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return AttachPolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AttachPolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AttachPolicyError {
    fn from(err: serde_json::error::Error) -> AttachPolicyError {
        AttachPolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AttachPolicyError {
    fn from(err: CredentialsError) -> AttachPolicyError {
        AttachPolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AttachPolicyError {
    fn from(err: HttpDispatchError) -> AttachPolicyError {
        AttachPolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for AttachPolicyError {
    fn from(err: io::Error) -> AttachPolicyError {
        AttachPolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AttachPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachPolicyError {
    fn description(&self) -> &str {
        match *self {
            AttachPolicyError::InternalFailure(ref cause) => cause,
            AttachPolicyError::InvalidRequest(ref cause) => cause,
            AttachPolicyError::LimitExceeded(ref cause) => cause,
            AttachPolicyError::ResourceNotFound(ref cause) => cause,
            AttachPolicyError::ServiceUnavailable(ref cause) => cause,
            AttachPolicyError::Throttling(ref cause) => cause,
            AttachPolicyError::Unauthorized(ref cause) => cause,
            AttachPolicyError::Validation(ref cause) => cause,
            AttachPolicyError::Credentials(ref err) => err.description(),
            AttachPolicyError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            AttachPolicyError::ParseError(ref cause) => cause,
            AttachPolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by AttachPrincipalPolicy
#[derive(Debug, PartialEq)]
pub enum AttachPrincipalPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AttachPrincipalPolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AttachPrincipalPolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return AttachPrincipalPolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return AttachPrincipalPolicyError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return AttachPrincipalPolicyError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return AttachPrincipalPolicyError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return AttachPrincipalPolicyError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return AttachPrincipalPolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return AttachPrincipalPolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return AttachPrincipalPolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AttachPrincipalPolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AttachPrincipalPolicyError {
    fn from(err: serde_json::error::Error) -> AttachPrincipalPolicyError {
        AttachPrincipalPolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AttachPrincipalPolicyError {
    fn from(err: CredentialsError) -> AttachPrincipalPolicyError {
        AttachPrincipalPolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AttachPrincipalPolicyError {
    fn from(err: HttpDispatchError) -> AttachPrincipalPolicyError {
        AttachPrincipalPolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for AttachPrincipalPolicyError {
    fn from(err: io::Error) -> AttachPrincipalPolicyError {
        AttachPrincipalPolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AttachPrincipalPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachPrincipalPolicyError {
    fn description(&self) -> &str {
        match *self {
            AttachPrincipalPolicyError::InternalFailure(ref cause) => cause,
            AttachPrincipalPolicyError::InvalidRequest(ref cause) => cause,
            AttachPrincipalPolicyError::LimitExceeded(ref cause) => cause,
            AttachPrincipalPolicyError::ResourceNotFound(ref cause) => cause,
            AttachPrincipalPolicyError::ServiceUnavailable(ref cause) => cause,
            AttachPrincipalPolicyError::Throttling(ref cause) => cause,
            AttachPrincipalPolicyError::Unauthorized(ref cause) => cause,
            AttachPrincipalPolicyError::Validation(ref cause) => cause,
            AttachPrincipalPolicyError::Credentials(ref err) => err.description(),
            AttachPrincipalPolicyError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            AttachPrincipalPolicyError::ParseError(ref cause) => cause,
            AttachPrincipalPolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by AttachSecurityProfile
#[derive(Debug, PartialEq)]
pub enum AttachSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AttachSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AttachSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return AttachSecurityProfileError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return AttachSecurityProfileError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return AttachSecurityProfileError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return AttachSecurityProfileError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return AttachSecurityProfileError::Throttling(String::from(error_message))
                }
                "VersionConflictException" => {
                    return AttachSecurityProfileError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return AttachSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AttachSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AttachSecurityProfileError {
    fn from(err: serde_json::error::Error) -> AttachSecurityProfileError {
        AttachSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AttachSecurityProfileError {
    fn from(err: CredentialsError) -> AttachSecurityProfileError {
        AttachSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AttachSecurityProfileError {
    fn from(err: HttpDispatchError) -> AttachSecurityProfileError {
        AttachSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for AttachSecurityProfileError {
    fn from(err: io::Error) -> AttachSecurityProfileError {
        AttachSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AttachSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            AttachSecurityProfileError::InternalFailure(ref cause) => cause,
            AttachSecurityProfileError::InvalidRequest(ref cause) => cause,
            AttachSecurityProfileError::LimitExceeded(ref cause) => cause,
            AttachSecurityProfileError::ResourceNotFound(ref cause) => cause,
            AttachSecurityProfileError::Throttling(ref cause) => cause,
            AttachSecurityProfileError::VersionConflict(ref cause) => cause,
            AttachSecurityProfileError::Validation(ref cause) => cause,
            AttachSecurityProfileError::Credentials(ref err) => err.description(),
            AttachSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            AttachSecurityProfileError::ParseError(ref cause) => cause,
            AttachSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by AttachThingPrincipal
#[derive(Debug, PartialEq)]
pub enum AttachThingPrincipalError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl AttachThingPrincipalError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> AttachThingPrincipalError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return AttachThingPrincipalError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return AttachThingPrincipalError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return AttachThingPrincipalError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return AttachThingPrincipalError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return AttachThingPrincipalError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return AttachThingPrincipalError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return AttachThingPrincipalError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return AttachThingPrincipalError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for AttachThingPrincipalError {
    fn from(err: serde_json::error::Error) -> AttachThingPrincipalError {
        AttachThingPrincipalError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for AttachThingPrincipalError {
    fn from(err: CredentialsError) -> AttachThingPrincipalError {
        AttachThingPrincipalError::Credentials(err)
    }
}
impl From<HttpDispatchError> for AttachThingPrincipalError {
    fn from(err: HttpDispatchError) -> AttachThingPrincipalError {
        AttachThingPrincipalError::HttpDispatch(err)
    }
}
impl From<io::Error> for AttachThingPrincipalError {
    fn from(err: io::Error) -> AttachThingPrincipalError {
        AttachThingPrincipalError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for AttachThingPrincipalError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachThingPrincipalError {
    fn description(&self) -> &str {
        match *self {
            AttachThingPrincipalError::InternalFailure(ref cause) => cause,
            AttachThingPrincipalError::InvalidRequest(ref cause) => cause,
            AttachThingPrincipalError::ResourceNotFound(ref cause) => cause,
            AttachThingPrincipalError::ServiceUnavailable(ref cause) => cause,
            AttachThingPrincipalError::Throttling(ref cause) => cause,
            AttachThingPrincipalError::Unauthorized(ref cause) => cause,
            AttachThingPrincipalError::Validation(ref cause) => cause,
            AttachThingPrincipalError::Credentials(ref err) => err.description(),
            AttachThingPrincipalError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            AttachThingPrincipalError::ParseError(ref cause) => cause,
            AttachThingPrincipalError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CancelAuditTask
#[derive(Debug, PartialEq)]
pub enum CancelAuditTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CancelAuditTaskError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CancelAuditTaskError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CancelAuditTaskError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CancelAuditTaskError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CancelAuditTaskError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CancelAuditTaskError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return CancelAuditTaskError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CancelAuditTaskError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CancelAuditTaskError {
    fn from(err: serde_json::error::Error) -> CancelAuditTaskError {
        CancelAuditTaskError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CancelAuditTaskError {
    fn from(err: CredentialsError) -> CancelAuditTaskError {
        CancelAuditTaskError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CancelAuditTaskError {
    fn from(err: HttpDispatchError) -> CancelAuditTaskError {
        CancelAuditTaskError::HttpDispatch(err)
    }
}
impl From<io::Error> for CancelAuditTaskError {
    fn from(err: io::Error) -> CancelAuditTaskError {
        CancelAuditTaskError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CancelAuditTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelAuditTaskError {
    fn description(&self) -> &str {
        match *self {
            CancelAuditTaskError::InternalFailure(ref cause) => cause,
            CancelAuditTaskError::InvalidRequest(ref cause) => cause,
            CancelAuditTaskError::ResourceNotFound(ref cause) => cause,
            CancelAuditTaskError::Throttling(ref cause) => cause,
            CancelAuditTaskError::Validation(ref cause) => cause,
            CancelAuditTaskError::Credentials(ref err) => err.description(),
            CancelAuditTaskError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CancelAuditTaskError::ParseError(ref cause) => cause,
            CancelAuditTaskError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CancelCertificateTransfer
#[derive(Debug, PartialEq)]
pub enum CancelCertificateTransferError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't revert the certificate transfer because the transfer is already complete.</p>
    TransferAlreadyCompleted(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CancelCertificateTransferError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CancelCertificateTransferError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CancelCertificateTransferError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return CancelCertificateTransferError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return CancelCertificateTransferError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return CancelCertificateTransferError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return CancelCertificateTransferError::Throttling(String::from(error_message))
                }
                "TransferAlreadyCompletedException" => {
                    return CancelCertificateTransferError::TransferAlreadyCompleted(String::from(
                        error_message,
                    ))
                }
                "UnauthorizedException" => {
                    return CancelCertificateTransferError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CancelCertificateTransferError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CancelCertificateTransferError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CancelCertificateTransferError {
    fn from(err: serde_json::error::Error) -> CancelCertificateTransferError {
        CancelCertificateTransferError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CancelCertificateTransferError {
    fn from(err: CredentialsError) -> CancelCertificateTransferError {
        CancelCertificateTransferError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CancelCertificateTransferError {
    fn from(err: HttpDispatchError) -> CancelCertificateTransferError {
        CancelCertificateTransferError::HttpDispatch(err)
    }
}
impl From<io::Error> for CancelCertificateTransferError {
    fn from(err: io::Error) -> CancelCertificateTransferError {
        CancelCertificateTransferError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CancelCertificateTransferError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelCertificateTransferError {
    fn description(&self) -> &str {
        match *self {
            CancelCertificateTransferError::InternalFailure(ref cause) => cause,
            CancelCertificateTransferError::InvalidRequest(ref cause) => cause,
            CancelCertificateTransferError::ResourceNotFound(ref cause) => cause,
            CancelCertificateTransferError::ServiceUnavailable(ref cause) => cause,
            CancelCertificateTransferError::Throttling(ref cause) => cause,
            CancelCertificateTransferError::TransferAlreadyCompleted(ref cause) => cause,
            CancelCertificateTransferError::Unauthorized(ref cause) => cause,
            CancelCertificateTransferError::Validation(ref cause) => cause,
            CancelCertificateTransferError::Credentials(ref err) => err.description(),
            CancelCertificateTransferError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CancelCertificateTransferError::ParseError(ref cause) => cause,
            CancelCertificateTransferError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CancelJob
#[derive(Debug, PartialEq)]
pub enum CancelJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CancelJobError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CancelJobError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return CancelJobError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CancelJobError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CancelJobError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CancelJobError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return CancelJobError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CancelJobError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CancelJobError {
    fn from(err: serde_json::error::Error) -> CancelJobError {
        CancelJobError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CancelJobError {
    fn from(err: CredentialsError) -> CancelJobError {
        CancelJobError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CancelJobError {
    fn from(err: HttpDispatchError) -> CancelJobError {
        CancelJobError::HttpDispatch(err)
    }
}
impl From<io::Error> for CancelJobError {
    fn from(err: io::Error) -> CancelJobError {
        CancelJobError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CancelJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelJobError {
    fn description(&self) -> &str {
        match *self {
            CancelJobError::InvalidRequest(ref cause) => cause,
            CancelJobError::ResourceNotFound(ref cause) => cause,
            CancelJobError::ServiceUnavailable(ref cause) => cause,
            CancelJobError::Throttling(ref cause) => cause,
            CancelJobError::Validation(ref cause) => cause,
            CancelJobError::Credentials(ref err) => err.description(),
            CancelJobError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CancelJobError::ParseError(ref cause) => cause,
            CancelJobError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CancelJobExecution
#[derive(Debug, PartialEq)]
pub enum CancelJobExecutionError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the <code>force</code> parameter.</p>
    InvalidStateTransition(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CancelJobExecutionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CancelJobExecutionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return CancelJobExecutionError::InvalidRequest(String::from(error_message))
                }
                "InvalidStateTransitionException" => {
                    return CancelJobExecutionError::InvalidStateTransition(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return CancelJobExecutionError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CancelJobExecutionError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CancelJobExecutionError::Throttling(String::from(error_message))
                }
                "VersionConflictException" => {
                    return CancelJobExecutionError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return CancelJobExecutionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CancelJobExecutionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CancelJobExecutionError {
    fn from(err: serde_json::error::Error) -> CancelJobExecutionError {
        CancelJobExecutionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CancelJobExecutionError {
    fn from(err: CredentialsError) -> CancelJobExecutionError {
        CancelJobExecutionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CancelJobExecutionError {
    fn from(err: HttpDispatchError) -> CancelJobExecutionError {
        CancelJobExecutionError::HttpDispatch(err)
    }
}
impl From<io::Error> for CancelJobExecutionError {
    fn from(err: io::Error) -> CancelJobExecutionError {
        CancelJobExecutionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CancelJobExecutionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelJobExecutionError {
    fn description(&self) -> &str {
        match *self {
            CancelJobExecutionError::InvalidRequest(ref cause) => cause,
            CancelJobExecutionError::InvalidStateTransition(ref cause) => cause,
            CancelJobExecutionError::ResourceNotFound(ref cause) => cause,
            CancelJobExecutionError::ServiceUnavailable(ref cause) => cause,
            CancelJobExecutionError::Throttling(ref cause) => cause,
            CancelJobExecutionError::VersionConflict(ref cause) => cause,
            CancelJobExecutionError::Validation(ref cause) => cause,
            CancelJobExecutionError::Credentials(ref err) => err.description(),
            CancelJobExecutionError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CancelJobExecutionError::ParseError(ref cause) => cause,
            CancelJobExecutionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ClearDefaultAuthorizer
#[derive(Debug, PartialEq)]
pub enum ClearDefaultAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ClearDefaultAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ClearDefaultAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ClearDefaultAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ClearDefaultAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ClearDefaultAuthorizerError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return ClearDefaultAuthorizerError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ClearDefaultAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ClearDefaultAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ClearDefaultAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ClearDefaultAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ClearDefaultAuthorizerError {
    fn from(err: serde_json::error::Error) -> ClearDefaultAuthorizerError {
        ClearDefaultAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ClearDefaultAuthorizerError {
    fn from(err: CredentialsError) -> ClearDefaultAuthorizerError {
        ClearDefaultAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ClearDefaultAuthorizerError {
    fn from(err: HttpDispatchError) -> ClearDefaultAuthorizerError {
        ClearDefaultAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for ClearDefaultAuthorizerError {
    fn from(err: io::Error) -> ClearDefaultAuthorizerError {
        ClearDefaultAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ClearDefaultAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ClearDefaultAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            ClearDefaultAuthorizerError::InternalFailure(ref cause) => cause,
            ClearDefaultAuthorizerError::InvalidRequest(ref cause) => cause,
            ClearDefaultAuthorizerError::ResourceNotFound(ref cause) => cause,
            ClearDefaultAuthorizerError::ServiceUnavailable(ref cause) => cause,
            ClearDefaultAuthorizerError::Throttling(ref cause) => cause,
            ClearDefaultAuthorizerError::Unauthorized(ref cause) => cause,
            ClearDefaultAuthorizerError::Validation(ref cause) => cause,
            ClearDefaultAuthorizerError::Credentials(ref err) => err.description(),
            ClearDefaultAuthorizerError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ClearDefaultAuthorizerError::ParseError(ref cause) => cause,
            ClearDefaultAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateAuthorizer
#[derive(Debug, PartialEq)]
pub enum CreateAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return CreateAuthorizerError::LimitExceeded(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateAuthorizerError::ResourceAlreadyExists(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateAuthorizerError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateAuthorizerError {
    fn from(err: serde_json::error::Error) -> CreateAuthorizerError {
        CreateAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateAuthorizerError {
    fn from(err: CredentialsError) -> CreateAuthorizerError {
        CreateAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateAuthorizerError {
    fn from(err: HttpDispatchError) -> CreateAuthorizerError {
        CreateAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateAuthorizerError {
    fn from(err: io::Error) -> CreateAuthorizerError {
        CreateAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            CreateAuthorizerError::InternalFailure(ref cause) => cause,
            CreateAuthorizerError::InvalidRequest(ref cause) => cause,
            CreateAuthorizerError::LimitExceeded(ref cause) => cause,
            CreateAuthorizerError::ResourceAlreadyExists(ref cause) => cause,
            CreateAuthorizerError::ServiceUnavailable(ref cause) => cause,
            CreateAuthorizerError::Throttling(ref cause) => cause,
            CreateAuthorizerError::Unauthorized(ref cause) => cause,
            CreateAuthorizerError::Validation(ref cause) => cause,
            CreateAuthorizerError::Credentials(ref err) => err.description(),
            CreateAuthorizerError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateAuthorizerError::ParseError(ref cause) => cause,
            CreateAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateCertificateFromCsr
#[derive(Debug, PartialEq)]
pub enum CreateCertificateFromCsrError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateCertificateFromCsrError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateCertificateFromCsrError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateCertificateFromCsrError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return CreateCertificateFromCsrError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return CreateCertificateFromCsrError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return CreateCertificateFromCsrError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateCertificateFromCsrError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateCertificateFromCsrError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateCertificateFromCsrError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateCertificateFromCsrError {
    fn from(err: serde_json::error::Error) -> CreateCertificateFromCsrError {
        CreateCertificateFromCsrError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateCertificateFromCsrError {
    fn from(err: CredentialsError) -> CreateCertificateFromCsrError {
        CreateCertificateFromCsrError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateCertificateFromCsrError {
    fn from(err: HttpDispatchError) -> CreateCertificateFromCsrError {
        CreateCertificateFromCsrError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateCertificateFromCsrError {
    fn from(err: io::Error) -> CreateCertificateFromCsrError {
        CreateCertificateFromCsrError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateCertificateFromCsrError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateCertificateFromCsrError {
    fn description(&self) -> &str {
        match *self {
            CreateCertificateFromCsrError::InternalFailure(ref cause) => cause,
            CreateCertificateFromCsrError::InvalidRequest(ref cause) => cause,
            CreateCertificateFromCsrError::ServiceUnavailable(ref cause) => cause,
            CreateCertificateFromCsrError::Throttling(ref cause) => cause,
            CreateCertificateFromCsrError::Unauthorized(ref cause) => cause,
            CreateCertificateFromCsrError::Validation(ref cause) => cause,
            CreateCertificateFromCsrError::Credentials(ref err) => err.description(),
            CreateCertificateFromCsrError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CreateCertificateFromCsrError::ParseError(ref cause) => cause,
            CreateCertificateFromCsrError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateJob
#[derive(Debug, PartialEq)]
pub enum CreateJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateJobError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateJobError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return CreateJobError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return CreateJobError::LimitExceeded(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateJobError::ResourceAlreadyExists(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CreateJobError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateJobError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateJobError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateJobError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateJobError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateJobError {
    fn from(err: serde_json::error::Error) -> CreateJobError {
        CreateJobError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateJobError {
    fn from(err: CredentialsError) -> CreateJobError {
        CreateJobError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateJobError {
    fn from(err: HttpDispatchError) -> CreateJobError {
        CreateJobError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateJobError {
    fn from(err: io::Error) -> CreateJobError {
        CreateJobError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateJobError {
    fn description(&self) -> &str {
        match *self {
            CreateJobError::InvalidRequest(ref cause) => cause,
            CreateJobError::LimitExceeded(ref cause) => cause,
            CreateJobError::ResourceAlreadyExists(ref cause) => cause,
            CreateJobError::ResourceNotFound(ref cause) => cause,
            CreateJobError::ServiceUnavailable(ref cause) => cause,
            CreateJobError::Throttling(ref cause) => cause,
            CreateJobError::Validation(ref cause) => cause,
            CreateJobError::Credentials(ref err) => err.description(),
            CreateJobError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateJobError::ParseError(ref cause) => cause,
            CreateJobError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateKeysAndCertificate
#[derive(Debug, PartialEq)]
pub enum CreateKeysAndCertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateKeysAndCertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateKeysAndCertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateKeysAndCertificateError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return CreateKeysAndCertificateError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return CreateKeysAndCertificateError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return CreateKeysAndCertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateKeysAndCertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateKeysAndCertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateKeysAndCertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateKeysAndCertificateError {
    fn from(err: serde_json::error::Error) -> CreateKeysAndCertificateError {
        CreateKeysAndCertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateKeysAndCertificateError {
    fn from(err: CredentialsError) -> CreateKeysAndCertificateError {
        CreateKeysAndCertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateKeysAndCertificateError {
    fn from(err: HttpDispatchError) -> CreateKeysAndCertificateError {
        CreateKeysAndCertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateKeysAndCertificateError {
    fn from(err: io::Error) -> CreateKeysAndCertificateError {
        CreateKeysAndCertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateKeysAndCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateKeysAndCertificateError {
    fn description(&self) -> &str {
        match *self {
            CreateKeysAndCertificateError::InternalFailure(ref cause) => cause,
            CreateKeysAndCertificateError::InvalidRequest(ref cause) => cause,
            CreateKeysAndCertificateError::ServiceUnavailable(ref cause) => cause,
            CreateKeysAndCertificateError::Throttling(ref cause) => cause,
            CreateKeysAndCertificateError::Unauthorized(ref cause) => cause,
            CreateKeysAndCertificateError::Validation(ref cause) => cause,
            CreateKeysAndCertificateError::Credentials(ref err) => err.description(),
            CreateKeysAndCertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CreateKeysAndCertificateError::ParseError(ref cause) => cause,
            CreateKeysAndCertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateOTAUpdate
#[derive(Debug, PartialEq)]
pub enum CreateOTAUpdateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateOTAUpdateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateOTAUpdateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateOTAUpdateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateOTAUpdateError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateOTAUpdateError::ResourceAlreadyExists(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CreateOTAUpdateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateOTAUpdateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateOTAUpdateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateOTAUpdateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateOTAUpdateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateOTAUpdateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateOTAUpdateError {
    fn from(err: serde_json::error::Error) -> CreateOTAUpdateError {
        CreateOTAUpdateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateOTAUpdateError {
    fn from(err: CredentialsError) -> CreateOTAUpdateError {
        CreateOTAUpdateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateOTAUpdateError {
    fn from(err: HttpDispatchError) -> CreateOTAUpdateError {
        CreateOTAUpdateError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateOTAUpdateError {
    fn from(err: io::Error) -> CreateOTAUpdateError {
        CreateOTAUpdateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateOTAUpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateOTAUpdateError {
    fn description(&self) -> &str {
        match *self {
            CreateOTAUpdateError::InternalFailure(ref cause) => cause,
            CreateOTAUpdateError::InvalidRequest(ref cause) => cause,
            CreateOTAUpdateError::ResourceAlreadyExists(ref cause) => cause,
            CreateOTAUpdateError::ResourceNotFound(ref cause) => cause,
            CreateOTAUpdateError::ServiceUnavailable(ref cause) => cause,
            CreateOTAUpdateError::Throttling(ref cause) => cause,
            CreateOTAUpdateError::Unauthorized(ref cause) => cause,
            CreateOTAUpdateError::Validation(ref cause) => cause,
            CreateOTAUpdateError::Credentials(ref err) => err.description(),
            CreateOTAUpdateError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateOTAUpdateError::ParseError(ref cause) => cause,
            CreateOTAUpdateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreatePolicy
#[derive(Debug, PartialEq)]
pub enum CreatePolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The policy documentation is not valid.</p>
    MalformedPolicy(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreatePolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreatePolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreatePolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreatePolicyError::InvalidRequest(String::from(error_message))
                }
                "MalformedPolicyException" => {
                    return CreatePolicyError::MalformedPolicy(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreatePolicyError::ResourceAlreadyExists(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreatePolicyError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreatePolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreatePolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreatePolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreatePolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreatePolicyError {
    fn from(err: serde_json::error::Error) -> CreatePolicyError {
        CreatePolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreatePolicyError {
    fn from(err: CredentialsError) -> CreatePolicyError {
        CreatePolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreatePolicyError {
    fn from(err: HttpDispatchError) -> CreatePolicyError {
        CreatePolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreatePolicyError {
    fn from(err: io::Error) -> CreatePolicyError {
        CreatePolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreatePolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreatePolicyError {
    fn description(&self) -> &str {
        match *self {
            CreatePolicyError::InternalFailure(ref cause) => cause,
            CreatePolicyError::InvalidRequest(ref cause) => cause,
            CreatePolicyError::MalformedPolicy(ref cause) => cause,
            CreatePolicyError::ResourceAlreadyExists(ref cause) => cause,
            CreatePolicyError::ServiceUnavailable(ref cause) => cause,
            CreatePolicyError::Throttling(ref cause) => cause,
            CreatePolicyError::Unauthorized(ref cause) => cause,
            CreatePolicyError::Validation(ref cause) => cause,
            CreatePolicyError::Credentials(ref err) => err.description(),
            CreatePolicyError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreatePolicyError::ParseError(ref cause) => cause,
            CreatePolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreatePolicyVersion
#[derive(Debug, PartialEq)]
pub enum CreatePolicyVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The policy documentation is not valid.</p>
    MalformedPolicy(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>The number of policy versions exceeds the limit.</p>
    VersionsLimitExceeded(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreatePolicyVersionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreatePolicyVersionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreatePolicyVersionError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreatePolicyVersionError::InvalidRequest(String::from(error_message))
                }
                "MalformedPolicyException" => {
                    return CreatePolicyVersionError::MalformedPolicy(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CreatePolicyVersionError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreatePolicyVersionError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreatePolicyVersionError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreatePolicyVersionError::Unauthorized(String::from(error_message))
                }
                "VersionsLimitExceededException" => {
                    return CreatePolicyVersionError::VersionsLimitExceeded(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return CreatePolicyVersionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreatePolicyVersionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreatePolicyVersionError {
    fn from(err: serde_json::error::Error) -> CreatePolicyVersionError {
        CreatePolicyVersionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreatePolicyVersionError {
    fn from(err: CredentialsError) -> CreatePolicyVersionError {
        CreatePolicyVersionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreatePolicyVersionError {
    fn from(err: HttpDispatchError) -> CreatePolicyVersionError {
        CreatePolicyVersionError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreatePolicyVersionError {
    fn from(err: io::Error) -> CreatePolicyVersionError {
        CreatePolicyVersionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreatePolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreatePolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            CreatePolicyVersionError::InternalFailure(ref cause) => cause,
            CreatePolicyVersionError::InvalidRequest(ref cause) => cause,
            CreatePolicyVersionError::MalformedPolicy(ref cause) => cause,
            CreatePolicyVersionError::ResourceNotFound(ref cause) => cause,
            CreatePolicyVersionError::ServiceUnavailable(ref cause) => cause,
            CreatePolicyVersionError::Throttling(ref cause) => cause,
            CreatePolicyVersionError::Unauthorized(ref cause) => cause,
            CreatePolicyVersionError::VersionsLimitExceeded(ref cause) => cause,
            CreatePolicyVersionError::Validation(ref cause) => cause,
            CreatePolicyVersionError::Credentials(ref err) => err.description(),
            CreatePolicyVersionError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CreatePolicyVersionError::ParseError(ref cause) => cause,
            CreatePolicyVersionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateRoleAlias
#[derive(Debug, PartialEq)]
pub enum CreateRoleAliasError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateRoleAliasError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateRoleAliasError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateRoleAliasError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateRoleAliasError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return CreateRoleAliasError::LimitExceeded(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateRoleAliasError::ResourceAlreadyExists(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateRoleAliasError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateRoleAliasError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateRoleAliasError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateRoleAliasError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateRoleAliasError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateRoleAliasError {
    fn from(err: serde_json::error::Error) -> CreateRoleAliasError {
        CreateRoleAliasError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateRoleAliasError {
    fn from(err: CredentialsError) -> CreateRoleAliasError {
        CreateRoleAliasError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateRoleAliasError {
    fn from(err: HttpDispatchError) -> CreateRoleAliasError {
        CreateRoleAliasError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateRoleAliasError {
    fn from(err: io::Error) -> CreateRoleAliasError {
        CreateRoleAliasError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            CreateRoleAliasError::InternalFailure(ref cause) => cause,
            CreateRoleAliasError::InvalidRequest(ref cause) => cause,
            CreateRoleAliasError::LimitExceeded(ref cause) => cause,
            CreateRoleAliasError::ResourceAlreadyExists(ref cause) => cause,
            CreateRoleAliasError::ServiceUnavailable(ref cause) => cause,
            CreateRoleAliasError::Throttling(ref cause) => cause,
            CreateRoleAliasError::Unauthorized(ref cause) => cause,
            CreateRoleAliasError::Validation(ref cause) => cause,
            CreateRoleAliasError::Credentials(ref err) => err.description(),
            CreateRoleAliasError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateRoleAliasError::ParseError(ref cause) => cause,
            CreateRoleAliasError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateScheduledAudit
#[derive(Debug, PartialEq)]
pub enum CreateScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateScheduledAuditError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateScheduledAuditError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateScheduledAuditError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateScheduledAuditError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return CreateScheduledAuditError::LimitExceeded(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateScheduledAuditError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateScheduledAuditError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateScheduledAuditError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateScheduledAuditError {
    fn from(err: serde_json::error::Error) -> CreateScheduledAuditError {
        CreateScheduledAuditError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateScheduledAuditError {
    fn from(err: CredentialsError) -> CreateScheduledAuditError {
        CreateScheduledAuditError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateScheduledAuditError {
    fn from(err: HttpDispatchError) -> CreateScheduledAuditError {
        CreateScheduledAuditError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateScheduledAuditError {
    fn from(err: io::Error) -> CreateScheduledAuditError {
        CreateScheduledAuditError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            CreateScheduledAuditError::InternalFailure(ref cause) => cause,
            CreateScheduledAuditError::InvalidRequest(ref cause) => cause,
            CreateScheduledAuditError::LimitExceeded(ref cause) => cause,
            CreateScheduledAuditError::Throttling(ref cause) => cause,
            CreateScheduledAuditError::Validation(ref cause) => cause,
            CreateScheduledAuditError::Credentials(ref err) => err.description(),
            CreateScheduledAuditError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CreateScheduledAuditError::ParseError(ref cause) => cause,
            CreateScheduledAuditError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateSecurityProfile
#[derive(Debug, PartialEq)]
pub enum CreateSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateSecurityProfileError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateSecurityProfileError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateSecurityProfileError::ResourceAlreadyExists(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return CreateSecurityProfileError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateSecurityProfileError {
    fn from(err: serde_json::error::Error) -> CreateSecurityProfileError {
        CreateSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateSecurityProfileError {
    fn from(err: CredentialsError) -> CreateSecurityProfileError {
        CreateSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateSecurityProfileError {
    fn from(err: HttpDispatchError) -> CreateSecurityProfileError {
        CreateSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateSecurityProfileError {
    fn from(err: io::Error) -> CreateSecurityProfileError {
        CreateSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            CreateSecurityProfileError::InternalFailure(ref cause) => cause,
            CreateSecurityProfileError::InvalidRequest(ref cause) => cause,
            CreateSecurityProfileError::ResourceAlreadyExists(ref cause) => cause,
            CreateSecurityProfileError::Throttling(ref cause) => cause,
            CreateSecurityProfileError::Validation(ref cause) => cause,
            CreateSecurityProfileError::Credentials(ref err) => err.description(),
            CreateSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            CreateSecurityProfileError::ParseError(ref cause) => cause,
            CreateSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateStream
#[derive(Debug, PartialEq)]
pub enum CreateStreamError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateStreamError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateStreamError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateStreamError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateStreamError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateStreamError::ResourceAlreadyExists(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CreateStreamError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateStreamError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateStreamError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateStreamError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateStreamError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateStreamError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateStreamError {
    fn from(err: serde_json::error::Error) -> CreateStreamError {
        CreateStreamError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateStreamError {
    fn from(err: CredentialsError) -> CreateStreamError {
        CreateStreamError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateStreamError {
    fn from(err: HttpDispatchError) -> CreateStreamError {
        CreateStreamError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateStreamError {
    fn from(err: io::Error) -> CreateStreamError {
        CreateStreamError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateStreamError {
    fn description(&self) -> &str {
        match *self {
            CreateStreamError::InternalFailure(ref cause) => cause,
            CreateStreamError::InvalidRequest(ref cause) => cause,
            CreateStreamError::ResourceAlreadyExists(ref cause) => cause,
            CreateStreamError::ResourceNotFound(ref cause) => cause,
            CreateStreamError::ServiceUnavailable(ref cause) => cause,
            CreateStreamError::Throttling(ref cause) => cause,
            CreateStreamError::Unauthorized(ref cause) => cause,
            CreateStreamError::Validation(ref cause) => cause,
            CreateStreamError::Credentials(ref err) => err.description(),
            CreateStreamError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateStreamError::ParseError(ref cause) => cause,
            CreateStreamError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateThing
#[derive(Debug, PartialEq)]
pub enum CreateThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateThingError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateThingError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateThingError::ResourceAlreadyExists(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return CreateThingError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateThingError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateThingError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateThingError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateThingError {
    fn from(err: serde_json::error::Error) -> CreateThingError {
        CreateThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateThingError {
    fn from(err: CredentialsError) -> CreateThingError {
        CreateThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateThingError {
    fn from(err: HttpDispatchError) -> CreateThingError {
        CreateThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateThingError {
    fn from(err: io::Error) -> CreateThingError {
        CreateThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateThingError {
    fn description(&self) -> &str {
        match *self {
            CreateThingError::InternalFailure(ref cause) => cause,
            CreateThingError::InvalidRequest(ref cause) => cause,
            CreateThingError::ResourceAlreadyExists(ref cause) => cause,
            CreateThingError::ResourceNotFound(ref cause) => cause,
            CreateThingError::ServiceUnavailable(ref cause) => cause,
            CreateThingError::Throttling(ref cause) => cause,
            CreateThingError::Unauthorized(ref cause) => cause,
            CreateThingError::Validation(ref cause) => cause,
            CreateThingError::Credentials(ref err) => err.description(),
            CreateThingError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateThingError::ParseError(ref cause) => cause,
            CreateThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateThingGroup
#[derive(Debug, PartialEq)]
pub enum CreateThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateThingGroupError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateThingGroupError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateThingGroupError::ResourceAlreadyExists(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateThingGroupError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateThingGroupError {
    fn from(err: serde_json::error::Error) -> CreateThingGroupError {
        CreateThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateThingGroupError {
    fn from(err: CredentialsError) -> CreateThingGroupError {
        CreateThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateThingGroupError {
    fn from(err: HttpDispatchError) -> CreateThingGroupError {
        CreateThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateThingGroupError {
    fn from(err: io::Error) -> CreateThingGroupError {
        CreateThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateThingGroupError {
    fn description(&self) -> &str {
        match *self {
            CreateThingGroupError::InternalFailure(ref cause) => cause,
            CreateThingGroupError::InvalidRequest(ref cause) => cause,
            CreateThingGroupError::ResourceAlreadyExists(ref cause) => cause,
            CreateThingGroupError::Throttling(ref cause) => cause,
            CreateThingGroupError::Validation(ref cause) => cause,
            CreateThingGroupError::Credentials(ref err) => err.description(),
            CreateThingGroupError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateThingGroupError::ParseError(ref cause) => cause,
            CreateThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateThingType
#[derive(Debug, PartialEq)]
pub enum CreateThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateThingTypeError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateThingTypeError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return CreateThingTypeError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateThingTypeError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateThingTypeError::ResourceAlreadyExists(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateThingTypeError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return CreateThingTypeError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return CreateThingTypeError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateThingTypeError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateThingTypeError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateThingTypeError {
    fn from(err: serde_json::error::Error) -> CreateThingTypeError {
        CreateThingTypeError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateThingTypeError {
    fn from(err: CredentialsError) -> CreateThingTypeError {
        CreateThingTypeError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateThingTypeError {
    fn from(err: HttpDispatchError) -> CreateThingTypeError {
        CreateThingTypeError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateThingTypeError {
    fn from(err: io::Error) -> CreateThingTypeError {
        CreateThingTypeError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateThingTypeError {
    fn description(&self) -> &str {
        match *self {
            CreateThingTypeError::InternalFailure(ref cause) => cause,
            CreateThingTypeError::InvalidRequest(ref cause) => cause,
            CreateThingTypeError::ResourceAlreadyExists(ref cause) => cause,
            CreateThingTypeError::ServiceUnavailable(ref cause) => cause,
            CreateThingTypeError::Throttling(ref cause) => cause,
            CreateThingTypeError::Unauthorized(ref cause) => cause,
            CreateThingTypeError::Validation(ref cause) => cause,
            CreateThingTypeError::Credentials(ref err) => err.description(),
            CreateThingTypeError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateThingTypeError::ParseError(ref cause) => cause,
            CreateThingTypeError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by CreateTopicRule
#[derive(Debug, PartialEq)]
pub enum CreateTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The Rule-SQL expression can't be parsed correctly.</p>
    SqlParse(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl CreateTopicRuleError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> CreateTopicRuleError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return CreateTopicRuleError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return CreateTopicRuleError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return CreateTopicRuleError::ResourceAlreadyExists(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return CreateTopicRuleError::ServiceUnavailable(String::from(error_message))
                }
                "SqlParseException" => {
                    return CreateTopicRuleError::SqlParse(String::from(error_message))
                }
                "ValidationException" => {
                    return CreateTopicRuleError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return CreateTopicRuleError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for CreateTopicRuleError {
    fn from(err: serde_json::error::Error) -> CreateTopicRuleError {
        CreateTopicRuleError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for CreateTopicRuleError {
    fn from(err: CredentialsError) -> CreateTopicRuleError {
        CreateTopicRuleError::Credentials(err)
    }
}
impl From<HttpDispatchError> for CreateTopicRuleError {
    fn from(err: HttpDispatchError) -> CreateTopicRuleError {
        CreateTopicRuleError::HttpDispatch(err)
    }
}
impl From<io::Error> for CreateTopicRuleError {
    fn from(err: io::Error) -> CreateTopicRuleError {
        CreateTopicRuleError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for CreateTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            CreateTopicRuleError::Internal(ref cause) => cause,
            CreateTopicRuleError::InvalidRequest(ref cause) => cause,
            CreateTopicRuleError::ResourceAlreadyExists(ref cause) => cause,
            CreateTopicRuleError::ServiceUnavailable(ref cause) => cause,
            CreateTopicRuleError::SqlParse(ref cause) => cause,
            CreateTopicRuleError::Validation(ref cause) => cause,
            CreateTopicRuleError::Credentials(ref err) => err.description(),
            CreateTopicRuleError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            CreateTopicRuleError::ParseError(ref cause) => cause,
            CreateTopicRuleError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteAccountAuditConfiguration
#[derive(Debug, PartialEq)]
pub enum DeleteAccountAuditConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteAccountAuditConfigurationError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteAccountAuditConfigurationError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteAccountAuditConfigurationError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return DeleteAccountAuditConfigurationError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return DeleteAccountAuditConfigurationError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DeleteAccountAuditConfigurationError::Throttling(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return DeleteAccountAuditConfigurationError::Validation(
                        error_message.to_string(),
                    )
                }
                _ => {}
            }
        }
        return DeleteAccountAuditConfigurationError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteAccountAuditConfigurationError {
    fn from(err: serde_json::error::Error) -> DeleteAccountAuditConfigurationError {
        DeleteAccountAuditConfigurationError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteAccountAuditConfigurationError {
    fn from(err: CredentialsError) -> DeleteAccountAuditConfigurationError {
        DeleteAccountAuditConfigurationError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteAccountAuditConfigurationError {
    fn from(err: HttpDispatchError) -> DeleteAccountAuditConfigurationError {
        DeleteAccountAuditConfigurationError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteAccountAuditConfigurationError {
    fn from(err: io::Error) -> DeleteAccountAuditConfigurationError {
        DeleteAccountAuditConfigurationError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteAccountAuditConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteAccountAuditConfigurationError {
    fn description(&self) -> &str {
        match *self {
            DeleteAccountAuditConfigurationError::InternalFailure(ref cause) => cause,
            DeleteAccountAuditConfigurationError::InvalidRequest(ref cause) => cause,
            DeleteAccountAuditConfigurationError::ResourceNotFound(ref cause) => cause,
            DeleteAccountAuditConfigurationError::Throttling(ref cause) => cause,
            DeleteAccountAuditConfigurationError::Validation(ref cause) => cause,
            DeleteAccountAuditConfigurationError::Credentials(ref err) => err.description(),
            DeleteAccountAuditConfigurationError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteAccountAuditConfigurationError::ParseError(ref cause) => cause,
            DeleteAccountAuditConfigurationError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteAuthorizer
#[derive(Debug, PartialEq)]
pub enum DeleteAuthorizerError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "DeleteConflictException" => {
                    return DeleteAuthorizerError::DeleteConflict(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeleteAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteAuthorizerError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteAuthorizerError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteAuthorizerError {
    fn from(err: serde_json::error::Error) -> DeleteAuthorizerError {
        DeleteAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteAuthorizerError {
    fn from(err: CredentialsError) -> DeleteAuthorizerError {
        DeleteAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteAuthorizerError {
    fn from(err: HttpDispatchError) -> DeleteAuthorizerError {
        DeleteAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteAuthorizerError {
    fn from(err: io::Error) -> DeleteAuthorizerError {
        DeleteAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            DeleteAuthorizerError::DeleteConflict(ref cause) => cause,
            DeleteAuthorizerError::InternalFailure(ref cause) => cause,
            DeleteAuthorizerError::InvalidRequest(ref cause) => cause,
            DeleteAuthorizerError::ResourceNotFound(ref cause) => cause,
            DeleteAuthorizerError::ServiceUnavailable(ref cause) => cause,
            DeleteAuthorizerError::Throttling(ref cause) => cause,
            DeleteAuthorizerError::Unauthorized(ref cause) => cause,
            DeleteAuthorizerError::Validation(ref cause) => cause,
            DeleteAuthorizerError::Credentials(ref err) => err.description(),
            DeleteAuthorizerError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteAuthorizerError::ParseError(ref cause) => cause,
            DeleteAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteCACertificate
#[derive(Debug, PartialEq)]
pub enum DeleteCACertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteCACertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteCACertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "CertificateStateException" => {
                    return DeleteCACertificateError::CertificateState(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeleteCACertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteCACertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteCACertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteCACertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteCACertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteCACertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteCACertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteCACertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteCACertificateError {
    fn from(err: serde_json::error::Error) -> DeleteCACertificateError {
        DeleteCACertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteCACertificateError {
    fn from(err: CredentialsError) -> DeleteCACertificateError {
        DeleteCACertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteCACertificateError {
    fn from(err: HttpDispatchError) -> DeleteCACertificateError {
        DeleteCACertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteCACertificateError {
    fn from(err: io::Error) -> DeleteCACertificateError {
        DeleteCACertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteCACertificateError {
    fn description(&self) -> &str {
        match *self {
            DeleteCACertificateError::CertificateState(ref cause) => cause,
            DeleteCACertificateError::InternalFailure(ref cause) => cause,
            DeleteCACertificateError::InvalidRequest(ref cause) => cause,
            DeleteCACertificateError::ResourceNotFound(ref cause) => cause,
            DeleteCACertificateError::ServiceUnavailable(ref cause) => cause,
            DeleteCACertificateError::Throttling(ref cause) => cause,
            DeleteCACertificateError::Unauthorized(ref cause) => cause,
            DeleteCACertificateError::Validation(ref cause) => cause,
            DeleteCACertificateError::Credentials(ref err) => err.description(),
            DeleteCACertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteCACertificateError::ParseError(ref cause) => cause,
            DeleteCACertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteCertificate
#[derive(Debug, PartialEq)]
pub enum DeleteCertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteCertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteCertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "CertificateStateException" => {
                    return DeleteCertificateError::CertificateState(String::from(error_message))
                }
                "DeleteConflictException" => {
                    return DeleteCertificateError::DeleteConflict(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeleteCertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteCertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteCertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteCertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteCertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteCertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteCertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteCertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteCertificateError {
    fn from(err: serde_json::error::Error) -> DeleteCertificateError {
        DeleteCertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteCertificateError {
    fn from(err: CredentialsError) -> DeleteCertificateError {
        DeleteCertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteCertificateError {
    fn from(err: HttpDispatchError) -> DeleteCertificateError {
        DeleteCertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteCertificateError {
    fn from(err: io::Error) -> DeleteCertificateError {
        DeleteCertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteCertificateError {
    fn description(&self) -> &str {
        match *self {
            DeleteCertificateError::CertificateState(ref cause) => cause,
            DeleteCertificateError::DeleteConflict(ref cause) => cause,
            DeleteCertificateError::InternalFailure(ref cause) => cause,
            DeleteCertificateError::InvalidRequest(ref cause) => cause,
            DeleteCertificateError::ResourceNotFound(ref cause) => cause,
            DeleteCertificateError::ServiceUnavailable(ref cause) => cause,
            DeleteCertificateError::Throttling(ref cause) => cause,
            DeleteCertificateError::Unauthorized(ref cause) => cause,
            DeleteCertificateError::Validation(ref cause) => cause,
            DeleteCertificateError::Credentials(ref err) => err.description(),
            DeleteCertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteCertificateError::ParseError(ref cause) => cause,
            DeleteCertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteJob
#[derive(Debug, PartialEq)]
pub enum DeleteJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the <code>force</code> parameter.</p>
    InvalidStateTransition(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteJobError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteJobError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return DeleteJobError::InvalidRequest(String::from(error_message))
                }
                "InvalidStateTransitionException" => {
                    return DeleteJobError::InvalidStateTransition(String::from(error_message))
                }
                "LimitExceededException" => {
                    return DeleteJobError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteJobError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteJobError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteJobError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteJobError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteJobError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteJobError {
    fn from(err: serde_json::error::Error) -> DeleteJobError {
        DeleteJobError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteJobError {
    fn from(err: CredentialsError) -> DeleteJobError {
        DeleteJobError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteJobError {
    fn from(err: HttpDispatchError) -> DeleteJobError {
        DeleteJobError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteJobError {
    fn from(err: io::Error) -> DeleteJobError {
        DeleteJobError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteJobError {
    fn description(&self) -> &str {
        match *self {
            DeleteJobError::InvalidRequest(ref cause) => cause,
            DeleteJobError::InvalidStateTransition(ref cause) => cause,
            DeleteJobError::LimitExceeded(ref cause) => cause,
            DeleteJobError::ResourceNotFound(ref cause) => cause,
            DeleteJobError::ServiceUnavailable(ref cause) => cause,
            DeleteJobError::Throttling(ref cause) => cause,
            DeleteJobError::Validation(ref cause) => cause,
            DeleteJobError::Credentials(ref err) => err.description(),
            DeleteJobError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteJobError::ParseError(ref cause) => cause,
            DeleteJobError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteJobExecution
#[derive(Debug, PartialEq)]
pub enum DeleteJobExecutionError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the <code>force</code> parameter.</p>
    InvalidStateTransition(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteJobExecutionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteJobExecutionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return DeleteJobExecutionError::InvalidRequest(String::from(error_message))
                }
                "InvalidStateTransitionException" => {
                    return DeleteJobExecutionError::InvalidStateTransition(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return DeleteJobExecutionError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteJobExecutionError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteJobExecutionError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteJobExecutionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteJobExecutionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteJobExecutionError {
    fn from(err: serde_json::error::Error) -> DeleteJobExecutionError {
        DeleteJobExecutionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteJobExecutionError {
    fn from(err: CredentialsError) -> DeleteJobExecutionError {
        DeleteJobExecutionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteJobExecutionError {
    fn from(err: HttpDispatchError) -> DeleteJobExecutionError {
        DeleteJobExecutionError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteJobExecutionError {
    fn from(err: io::Error) -> DeleteJobExecutionError {
        DeleteJobExecutionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteJobExecutionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteJobExecutionError {
    fn description(&self) -> &str {
        match *self {
            DeleteJobExecutionError::InvalidRequest(ref cause) => cause,
            DeleteJobExecutionError::InvalidStateTransition(ref cause) => cause,
            DeleteJobExecutionError::ResourceNotFound(ref cause) => cause,
            DeleteJobExecutionError::ServiceUnavailable(ref cause) => cause,
            DeleteJobExecutionError::Throttling(ref cause) => cause,
            DeleteJobExecutionError::Validation(ref cause) => cause,
            DeleteJobExecutionError::Credentials(ref err) => err.description(),
            DeleteJobExecutionError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteJobExecutionError::ParseError(ref cause) => cause,
            DeleteJobExecutionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteOTAUpdate
#[derive(Debug, PartialEq)]
pub enum DeleteOTAUpdateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteOTAUpdateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteOTAUpdateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteOTAUpdateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteOTAUpdateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteOTAUpdateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteOTAUpdateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteOTAUpdateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteOTAUpdateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteOTAUpdateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteOTAUpdateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteOTAUpdateError {
    fn from(err: serde_json::error::Error) -> DeleteOTAUpdateError {
        DeleteOTAUpdateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteOTAUpdateError {
    fn from(err: CredentialsError) -> DeleteOTAUpdateError {
        DeleteOTAUpdateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteOTAUpdateError {
    fn from(err: HttpDispatchError) -> DeleteOTAUpdateError {
        DeleteOTAUpdateError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteOTAUpdateError {
    fn from(err: io::Error) -> DeleteOTAUpdateError {
        DeleteOTAUpdateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteOTAUpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteOTAUpdateError {
    fn description(&self) -> &str {
        match *self {
            DeleteOTAUpdateError::InternalFailure(ref cause) => cause,
            DeleteOTAUpdateError::InvalidRequest(ref cause) => cause,
            DeleteOTAUpdateError::ResourceNotFound(ref cause) => cause,
            DeleteOTAUpdateError::ServiceUnavailable(ref cause) => cause,
            DeleteOTAUpdateError::Throttling(ref cause) => cause,
            DeleteOTAUpdateError::Unauthorized(ref cause) => cause,
            DeleteOTAUpdateError::Validation(ref cause) => cause,
            DeleteOTAUpdateError::Credentials(ref err) => err.description(),
            DeleteOTAUpdateError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteOTAUpdateError::ParseError(ref cause) => cause,
            DeleteOTAUpdateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeletePolicy
#[derive(Debug, PartialEq)]
pub enum DeletePolicyError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeletePolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeletePolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "DeleteConflictException" => {
                    return DeletePolicyError::DeleteConflict(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeletePolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeletePolicyError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeletePolicyError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeletePolicyError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeletePolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeletePolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeletePolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeletePolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeletePolicyError {
    fn from(err: serde_json::error::Error) -> DeletePolicyError {
        DeletePolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeletePolicyError {
    fn from(err: CredentialsError) -> DeletePolicyError {
        DeletePolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeletePolicyError {
    fn from(err: HttpDispatchError) -> DeletePolicyError {
        DeletePolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeletePolicyError {
    fn from(err: io::Error) -> DeletePolicyError {
        DeletePolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeletePolicyError {
    fn description(&self) -> &str {
        match *self {
            DeletePolicyError::DeleteConflict(ref cause) => cause,
            DeletePolicyError::InternalFailure(ref cause) => cause,
            DeletePolicyError::InvalidRequest(ref cause) => cause,
            DeletePolicyError::ResourceNotFound(ref cause) => cause,
            DeletePolicyError::ServiceUnavailable(ref cause) => cause,
            DeletePolicyError::Throttling(ref cause) => cause,
            DeletePolicyError::Unauthorized(ref cause) => cause,
            DeletePolicyError::Validation(ref cause) => cause,
            DeletePolicyError::Credentials(ref err) => err.description(),
            DeletePolicyError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeletePolicyError::ParseError(ref cause) => cause,
            DeletePolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeletePolicyVersion
#[derive(Debug, PartialEq)]
pub enum DeletePolicyVersionError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeletePolicyVersionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeletePolicyVersionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "DeleteConflictException" => {
                    return DeletePolicyVersionError::DeleteConflict(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeletePolicyVersionError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeletePolicyVersionError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeletePolicyVersionError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeletePolicyVersionError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeletePolicyVersionError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeletePolicyVersionError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeletePolicyVersionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeletePolicyVersionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeletePolicyVersionError {
    fn from(err: serde_json::error::Error) -> DeletePolicyVersionError {
        DeletePolicyVersionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeletePolicyVersionError {
    fn from(err: CredentialsError) -> DeletePolicyVersionError {
        DeletePolicyVersionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeletePolicyVersionError {
    fn from(err: HttpDispatchError) -> DeletePolicyVersionError {
        DeletePolicyVersionError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeletePolicyVersionError {
    fn from(err: io::Error) -> DeletePolicyVersionError {
        DeletePolicyVersionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeletePolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeletePolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            DeletePolicyVersionError::DeleteConflict(ref cause) => cause,
            DeletePolicyVersionError::InternalFailure(ref cause) => cause,
            DeletePolicyVersionError::InvalidRequest(ref cause) => cause,
            DeletePolicyVersionError::ResourceNotFound(ref cause) => cause,
            DeletePolicyVersionError::ServiceUnavailable(ref cause) => cause,
            DeletePolicyVersionError::Throttling(ref cause) => cause,
            DeletePolicyVersionError::Unauthorized(ref cause) => cause,
            DeletePolicyVersionError::Validation(ref cause) => cause,
            DeletePolicyVersionError::Credentials(ref err) => err.description(),
            DeletePolicyVersionError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeletePolicyVersionError::ParseError(ref cause) => cause,
            DeletePolicyVersionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteRegistrationCode
#[derive(Debug, PartialEq)]
pub enum DeleteRegistrationCodeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteRegistrationCodeError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteRegistrationCodeError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteRegistrationCodeError::InternalFailure(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteRegistrationCodeError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return DeleteRegistrationCodeError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DeleteRegistrationCodeError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteRegistrationCodeError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteRegistrationCodeError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteRegistrationCodeError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteRegistrationCodeError {
    fn from(err: serde_json::error::Error) -> DeleteRegistrationCodeError {
        DeleteRegistrationCodeError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteRegistrationCodeError {
    fn from(err: CredentialsError) -> DeleteRegistrationCodeError {
        DeleteRegistrationCodeError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteRegistrationCodeError {
    fn from(err: HttpDispatchError) -> DeleteRegistrationCodeError {
        DeleteRegistrationCodeError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteRegistrationCodeError {
    fn from(err: io::Error) -> DeleteRegistrationCodeError {
        DeleteRegistrationCodeError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteRegistrationCodeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteRegistrationCodeError {
    fn description(&self) -> &str {
        match *self {
            DeleteRegistrationCodeError::InternalFailure(ref cause) => cause,
            DeleteRegistrationCodeError::ResourceNotFound(ref cause) => cause,
            DeleteRegistrationCodeError::ServiceUnavailable(ref cause) => cause,
            DeleteRegistrationCodeError::Throttling(ref cause) => cause,
            DeleteRegistrationCodeError::Unauthorized(ref cause) => cause,
            DeleteRegistrationCodeError::Validation(ref cause) => cause,
            DeleteRegistrationCodeError::Credentials(ref err) => err.description(),
            DeleteRegistrationCodeError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteRegistrationCodeError::ParseError(ref cause) => cause,
            DeleteRegistrationCodeError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteRoleAlias
#[derive(Debug, PartialEq)]
pub enum DeleteRoleAliasError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteRoleAliasError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteRoleAliasError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "DeleteConflictException" => {
                    return DeleteRoleAliasError::DeleteConflict(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeleteRoleAliasError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteRoleAliasError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteRoleAliasError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteRoleAliasError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteRoleAliasError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteRoleAliasError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteRoleAliasError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteRoleAliasError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteRoleAliasError {
    fn from(err: serde_json::error::Error) -> DeleteRoleAliasError {
        DeleteRoleAliasError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteRoleAliasError {
    fn from(err: CredentialsError) -> DeleteRoleAliasError {
        DeleteRoleAliasError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteRoleAliasError {
    fn from(err: HttpDispatchError) -> DeleteRoleAliasError {
        DeleteRoleAliasError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteRoleAliasError {
    fn from(err: io::Error) -> DeleteRoleAliasError {
        DeleteRoleAliasError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            DeleteRoleAliasError::DeleteConflict(ref cause) => cause,
            DeleteRoleAliasError::InternalFailure(ref cause) => cause,
            DeleteRoleAliasError::InvalidRequest(ref cause) => cause,
            DeleteRoleAliasError::ResourceNotFound(ref cause) => cause,
            DeleteRoleAliasError::ServiceUnavailable(ref cause) => cause,
            DeleteRoleAliasError::Throttling(ref cause) => cause,
            DeleteRoleAliasError::Unauthorized(ref cause) => cause,
            DeleteRoleAliasError::Validation(ref cause) => cause,
            DeleteRoleAliasError::Credentials(ref err) => err.description(),
            DeleteRoleAliasError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteRoleAliasError::ParseError(ref cause) => cause,
            DeleteRoleAliasError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteScheduledAudit
#[derive(Debug, PartialEq)]
pub enum DeleteScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteScheduledAuditError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteScheduledAuditError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteScheduledAuditError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteScheduledAuditError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteScheduledAuditError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteScheduledAuditError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteScheduledAuditError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteScheduledAuditError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteScheduledAuditError {
    fn from(err: serde_json::error::Error) -> DeleteScheduledAuditError {
        DeleteScheduledAuditError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteScheduledAuditError {
    fn from(err: CredentialsError) -> DeleteScheduledAuditError {
        DeleteScheduledAuditError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteScheduledAuditError {
    fn from(err: HttpDispatchError) -> DeleteScheduledAuditError {
        DeleteScheduledAuditError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteScheduledAuditError {
    fn from(err: io::Error) -> DeleteScheduledAuditError {
        DeleteScheduledAuditError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            DeleteScheduledAuditError::InternalFailure(ref cause) => cause,
            DeleteScheduledAuditError::InvalidRequest(ref cause) => cause,
            DeleteScheduledAuditError::ResourceNotFound(ref cause) => cause,
            DeleteScheduledAuditError::Throttling(ref cause) => cause,
            DeleteScheduledAuditError::Validation(ref cause) => cause,
            DeleteScheduledAuditError::Credentials(ref err) => err.description(),
            DeleteScheduledAuditError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteScheduledAuditError::ParseError(ref cause) => cause,
            DeleteScheduledAuditError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteSecurityProfile
#[derive(Debug, PartialEq)]
pub enum DeleteSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteSecurityProfileError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteSecurityProfileError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteSecurityProfileError::Throttling(String::from(error_message))
                }
                "VersionConflictException" => {
                    return DeleteSecurityProfileError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteSecurityProfileError {
    fn from(err: serde_json::error::Error) -> DeleteSecurityProfileError {
        DeleteSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteSecurityProfileError {
    fn from(err: CredentialsError) -> DeleteSecurityProfileError {
        DeleteSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteSecurityProfileError {
    fn from(err: HttpDispatchError) -> DeleteSecurityProfileError {
        DeleteSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteSecurityProfileError {
    fn from(err: io::Error) -> DeleteSecurityProfileError {
        DeleteSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            DeleteSecurityProfileError::InternalFailure(ref cause) => cause,
            DeleteSecurityProfileError::InvalidRequest(ref cause) => cause,
            DeleteSecurityProfileError::Throttling(ref cause) => cause,
            DeleteSecurityProfileError::VersionConflict(ref cause) => cause,
            DeleteSecurityProfileError::Validation(ref cause) => cause,
            DeleteSecurityProfileError::Credentials(ref err) => err.description(),
            DeleteSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteSecurityProfileError::ParseError(ref cause) => cause,
            DeleteSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteStream
#[derive(Debug, PartialEq)]
pub enum DeleteStreamError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteStreamError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteStreamError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "DeleteConflictException" => {
                    return DeleteStreamError::DeleteConflict(String::from(error_message))
                }
                "InternalFailureException" => {
                    return DeleteStreamError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteStreamError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteStreamError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteStreamError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteStreamError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteStreamError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteStreamError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteStreamError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteStreamError {
    fn from(err: serde_json::error::Error) -> DeleteStreamError {
        DeleteStreamError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteStreamError {
    fn from(err: CredentialsError) -> DeleteStreamError {
        DeleteStreamError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteStreamError {
    fn from(err: HttpDispatchError) -> DeleteStreamError {
        DeleteStreamError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteStreamError {
    fn from(err: io::Error) -> DeleteStreamError {
        DeleteStreamError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteStreamError {
    fn description(&self) -> &str {
        match *self {
            DeleteStreamError::DeleteConflict(ref cause) => cause,
            DeleteStreamError::InternalFailure(ref cause) => cause,
            DeleteStreamError::InvalidRequest(ref cause) => cause,
            DeleteStreamError::ResourceNotFound(ref cause) => cause,
            DeleteStreamError::ServiceUnavailable(ref cause) => cause,
            DeleteStreamError::Throttling(ref cause) => cause,
            DeleteStreamError::Unauthorized(ref cause) => cause,
            DeleteStreamError::Validation(ref cause) => cause,
            DeleteStreamError::Credentials(ref err) => err.description(),
            DeleteStreamError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteStreamError::ParseError(ref cause) => cause,
            DeleteStreamError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteThing
#[derive(Debug, PartialEq)]
pub enum DeleteThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteThingError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteThingError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteThingError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteThingError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteThingError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteThingError::Unauthorized(String::from(error_message))
                }
                "VersionConflictException" => {
                    return DeleteThingError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteThingError {
    fn from(err: serde_json::error::Error) -> DeleteThingError {
        DeleteThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteThingError {
    fn from(err: CredentialsError) -> DeleteThingError {
        DeleteThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteThingError {
    fn from(err: HttpDispatchError) -> DeleteThingError {
        DeleteThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteThingError {
    fn from(err: io::Error) -> DeleteThingError {
        DeleteThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteThingError {
    fn description(&self) -> &str {
        match *self {
            DeleteThingError::InternalFailure(ref cause) => cause,
            DeleteThingError::InvalidRequest(ref cause) => cause,
            DeleteThingError::ResourceNotFound(ref cause) => cause,
            DeleteThingError::ServiceUnavailable(ref cause) => cause,
            DeleteThingError::Throttling(ref cause) => cause,
            DeleteThingError::Unauthorized(ref cause) => cause,
            DeleteThingError::VersionConflict(ref cause) => cause,
            DeleteThingError::Validation(ref cause) => cause,
            DeleteThingError::Credentials(ref err) => err.description(),
            DeleteThingError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteThingError::ParseError(ref cause) => cause,
            DeleteThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteThingGroup
#[derive(Debug, PartialEq)]
pub enum DeleteThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteThingGroupError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteThingGroupError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteThingGroupError::Throttling(String::from(error_message))
                }
                "VersionConflictException" => {
                    return DeleteThingGroupError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteThingGroupError {
    fn from(err: serde_json::error::Error) -> DeleteThingGroupError {
        DeleteThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteThingGroupError {
    fn from(err: CredentialsError) -> DeleteThingGroupError {
        DeleteThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteThingGroupError {
    fn from(err: HttpDispatchError) -> DeleteThingGroupError {
        DeleteThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteThingGroupError {
    fn from(err: io::Error) -> DeleteThingGroupError {
        DeleteThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteThingGroupError {
    fn description(&self) -> &str {
        match *self {
            DeleteThingGroupError::InternalFailure(ref cause) => cause,
            DeleteThingGroupError::InvalidRequest(ref cause) => cause,
            DeleteThingGroupError::Throttling(ref cause) => cause,
            DeleteThingGroupError::VersionConflict(ref cause) => cause,
            DeleteThingGroupError::Validation(ref cause) => cause,
            DeleteThingGroupError::Credentials(ref err) => err.description(),
            DeleteThingGroupError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteThingGroupError::ParseError(ref cause) => cause,
            DeleteThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteThingType
#[derive(Debug, PartialEq)]
pub enum DeleteThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteThingTypeError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteThingTypeError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeleteThingTypeError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteThingTypeError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeleteThingTypeError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteThingTypeError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeleteThingTypeError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteThingTypeError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteThingTypeError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteThingTypeError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteThingTypeError {
    fn from(err: serde_json::error::Error) -> DeleteThingTypeError {
        DeleteThingTypeError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteThingTypeError {
    fn from(err: CredentialsError) -> DeleteThingTypeError {
        DeleteThingTypeError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteThingTypeError {
    fn from(err: HttpDispatchError) -> DeleteThingTypeError {
        DeleteThingTypeError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteThingTypeError {
    fn from(err: io::Error) -> DeleteThingTypeError {
        DeleteThingTypeError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteThingTypeError {
    fn description(&self) -> &str {
        match *self {
            DeleteThingTypeError::InternalFailure(ref cause) => cause,
            DeleteThingTypeError::InvalidRequest(ref cause) => cause,
            DeleteThingTypeError::ResourceNotFound(ref cause) => cause,
            DeleteThingTypeError::ServiceUnavailable(ref cause) => cause,
            DeleteThingTypeError::Throttling(ref cause) => cause,
            DeleteThingTypeError::Unauthorized(ref cause) => cause,
            DeleteThingTypeError::Validation(ref cause) => cause,
            DeleteThingTypeError::Credentials(ref err) => err.description(),
            DeleteThingTypeError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteThingTypeError::ParseError(ref cause) => cause,
            DeleteThingTypeError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteTopicRule
#[derive(Debug, PartialEq)]
pub enum DeleteTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteTopicRuleError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteTopicRuleError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return DeleteTopicRuleError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteTopicRuleError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteTopicRuleError::ServiceUnavailable(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeleteTopicRuleError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeleteTopicRuleError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteTopicRuleError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteTopicRuleError {
    fn from(err: serde_json::error::Error) -> DeleteTopicRuleError {
        DeleteTopicRuleError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteTopicRuleError {
    fn from(err: CredentialsError) -> DeleteTopicRuleError {
        DeleteTopicRuleError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteTopicRuleError {
    fn from(err: HttpDispatchError) -> DeleteTopicRuleError {
        DeleteTopicRuleError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteTopicRuleError {
    fn from(err: io::Error) -> DeleteTopicRuleError {
        DeleteTopicRuleError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            DeleteTopicRuleError::Internal(ref cause) => cause,
            DeleteTopicRuleError::InvalidRequest(ref cause) => cause,
            DeleteTopicRuleError::ServiceUnavailable(ref cause) => cause,
            DeleteTopicRuleError::Unauthorized(ref cause) => cause,
            DeleteTopicRuleError::Validation(ref cause) => cause,
            DeleteTopicRuleError::Credentials(ref err) => err.description(),
            DeleteTopicRuleError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DeleteTopicRuleError::ParseError(ref cause) => cause,
            DeleteTopicRuleError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeleteV2LoggingLevel
#[derive(Debug, PartialEq)]
pub enum DeleteV2LoggingLevelError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeleteV2LoggingLevelError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeleteV2LoggingLevelError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return DeleteV2LoggingLevelError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeleteV2LoggingLevelError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeleteV2LoggingLevelError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return DeleteV2LoggingLevelError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeleteV2LoggingLevelError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeleteV2LoggingLevelError {
    fn from(err: serde_json::error::Error) -> DeleteV2LoggingLevelError {
        DeleteV2LoggingLevelError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeleteV2LoggingLevelError {
    fn from(err: CredentialsError) -> DeleteV2LoggingLevelError {
        DeleteV2LoggingLevelError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeleteV2LoggingLevelError {
    fn from(err: HttpDispatchError) -> DeleteV2LoggingLevelError {
        DeleteV2LoggingLevelError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeleteV2LoggingLevelError {
    fn from(err: io::Error) -> DeleteV2LoggingLevelError {
        DeleteV2LoggingLevelError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeleteV2LoggingLevelError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteV2LoggingLevelError {
    fn description(&self) -> &str {
        match *self {
            DeleteV2LoggingLevelError::Internal(ref cause) => cause,
            DeleteV2LoggingLevelError::InvalidRequest(ref cause) => cause,
            DeleteV2LoggingLevelError::ServiceUnavailable(ref cause) => cause,
            DeleteV2LoggingLevelError::Validation(ref cause) => cause,
            DeleteV2LoggingLevelError::Credentials(ref err) => err.description(),
            DeleteV2LoggingLevelError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeleteV2LoggingLevelError::ParseError(ref cause) => cause,
            DeleteV2LoggingLevelError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DeprecateThingType
#[derive(Debug, PartialEq)]
pub enum DeprecateThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DeprecateThingTypeError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DeprecateThingTypeError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DeprecateThingTypeError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DeprecateThingTypeError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DeprecateThingTypeError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DeprecateThingTypeError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DeprecateThingTypeError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DeprecateThingTypeError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DeprecateThingTypeError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DeprecateThingTypeError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DeprecateThingTypeError {
    fn from(err: serde_json::error::Error) -> DeprecateThingTypeError {
        DeprecateThingTypeError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DeprecateThingTypeError {
    fn from(err: CredentialsError) -> DeprecateThingTypeError {
        DeprecateThingTypeError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DeprecateThingTypeError {
    fn from(err: HttpDispatchError) -> DeprecateThingTypeError {
        DeprecateThingTypeError::HttpDispatch(err)
    }
}
impl From<io::Error> for DeprecateThingTypeError {
    fn from(err: io::Error) -> DeprecateThingTypeError {
        DeprecateThingTypeError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DeprecateThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeprecateThingTypeError {
    fn description(&self) -> &str {
        match *self {
            DeprecateThingTypeError::InternalFailure(ref cause) => cause,
            DeprecateThingTypeError::InvalidRequest(ref cause) => cause,
            DeprecateThingTypeError::ResourceNotFound(ref cause) => cause,
            DeprecateThingTypeError::ServiceUnavailable(ref cause) => cause,
            DeprecateThingTypeError::Throttling(ref cause) => cause,
            DeprecateThingTypeError::Unauthorized(ref cause) => cause,
            DeprecateThingTypeError::Validation(ref cause) => cause,
            DeprecateThingTypeError::Credentials(ref err) => err.description(),
            DeprecateThingTypeError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DeprecateThingTypeError::ParseError(ref cause) => cause,
            DeprecateThingTypeError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeAccountAuditConfiguration
#[derive(Debug, PartialEq)]
pub enum DescribeAccountAuditConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeAccountAuditConfigurationError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeAccountAuditConfigurationError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeAccountAuditConfigurationError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeAccountAuditConfigurationError::Throttling(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return DescribeAccountAuditConfigurationError::Validation(
                        error_message.to_string(),
                    )
                }
                _ => {}
            }
        }
        return DescribeAccountAuditConfigurationError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeAccountAuditConfigurationError {
    fn from(err: serde_json::error::Error) -> DescribeAccountAuditConfigurationError {
        DescribeAccountAuditConfigurationError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeAccountAuditConfigurationError {
    fn from(err: CredentialsError) -> DescribeAccountAuditConfigurationError {
        DescribeAccountAuditConfigurationError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeAccountAuditConfigurationError {
    fn from(err: HttpDispatchError) -> DescribeAccountAuditConfigurationError {
        DescribeAccountAuditConfigurationError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeAccountAuditConfigurationError {
    fn from(err: io::Error) -> DescribeAccountAuditConfigurationError {
        DescribeAccountAuditConfigurationError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeAccountAuditConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAccountAuditConfigurationError {
    fn description(&self) -> &str {
        match *self {
            DescribeAccountAuditConfigurationError::InternalFailure(ref cause) => cause,
            DescribeAccountAuditConfigurationError::Throttling(ref cause) => cause,
            DescribeAccountAuditConfigurationError::Validation(ref cause) => cause,
            DescribeAccountAuditConfigurationError::Credentials(ref err) => err.description(),
            DescribeAccountAuditConfigurationError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeAccountAuditConfigurationError::ParseError(ref cause) => cause,
            DescribeAccountAuditConfigurationError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeAuditTask
#[derive(Debug, PartialEq)]
pub enum DescribeAuditTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeAuditTaskError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeAuditTaskError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeAuditTaskError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeAuditTaskError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeAuditTaskError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeAuditTaskError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeAuditTaskError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeAuditTaskError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeAuditTaskError {
    fn from(err: serde_json::error::Error) -> DescribeAuditTaskError {
        DescribeAuditTaskError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeAuditTaskError {
    fn from(err: CredentialsError) -> DescribeAuditTaskError {
        DescribeAuditTaskError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeAuditTaskError {
    fn from(err: HttpDispatchError) -> DescribeAuditTaskError {
        DescribeAuditTaskError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeAuditTaskError {
    fn from(err: io::Error) -> DescribeAuditTaskError {
        DescribeAuditTaskError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeAuditTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAuditTaskError {
    fn description(&self) -> &str {
        match *self {
            DescribeAuditTaskError::InternalFailure(ref cause) => cause,
            DescribeAuditTaskError::InvalidRequest(ref cause) => cause,
            DescribeAuditTaskError::ResourceNotFound(ref cause) => cause,
            DescribeAuditTaskError::Throttling(ref cause) => cause,
            DescribeAuditTaskError::Validation(ref cause) => cause,
            DescribeAuditTaskError::Credentials(ref err) => err.description(),
            DescribeAuditTaskError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeAuditTaskError::ParseError(ref cause) => cause,
            DescribeAuditTaskError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeAuthorizer
#[derive(Debug, PartialEq)]
pub enum DescribeAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeAuthorizerError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeAuthorizerError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeAuthorizerError {
    fn from(err: serde_json::error::Error) -> DescribeAuthorizerError {
        DescribeAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeAuthorizerError {
    fn from(err: CredentialsError) -> DescribeAuthorizerError {
        DescribeAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeAuthorizerError {
    fn from(err: HttpDispatchError) -> DescribeAuthorizerError {
        DescribeAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeAuthorizerError {
    fn from(err: io::Error) -> DescribeAuthorizerError {
        DescribeAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            DescribeAuthorizerError::InternalFailure(ref cause) => cause,
            DescribeAuthorizerError::InvalidRequest(ref cause) => cause,
            DescribeAuthorizerError::ResourceNotFound(ref cause) => cause,
            DescribeAuthorizerError::ServiceUnavailable(ref cause) => cause,
            DescribeAuthorizerError::Throttling(ref cause) => cause,
            DescribeAuthorizerError::Unauthorized(ref cause) => cause,
            DescribeAuthorizerError::Validation(ref cause) => cause,
            DescribeAuthorizerError::Credentials(ref err) => err.description(),
            DescribeAuthorizerError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeAuthorizerError::ParseError(ref cause) => cause,
            DescribeAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeCACertificate
#[derive(Debug, PartialEq)]
pub enum DescribeCACertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeCACertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeCACertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeCACertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeCACertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeCACertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeCACertificateError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeCACertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeCACertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeCACertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeCACertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeCACertificateError {
    fn from(err: serde_json::error::Error) -> DescribeCACertificateError {
        DescribeCACertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeCACertificateError {
    fn from(err: CredentialsError) -> DescribeCACertificateError {
        DescribeCACertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeCACertificateError {
    fn from(err: HttpDispatchError) -> DescribeCACertificateError {
        DescribeCACertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeCACertificateError {
    fn from(err: io::Error) -> DescribeCACertificateError {
        DescribeCACertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeCACertificateError {
    fn description(&self) -> &str {
        match *self {
            DescribeCACertificateError::InternalFailure(ref cause) => cause,
            DescribeCACertificateError::InvalidRequest(ref cause) => cause,
            DescribeCACertificateError::ResourceNotFound(ref cause) => cause,
            DescribeCACertificateError::ServiceUnavailable(ref cause) => cause,
            DescribeCACertificateError::Throttling(ref cause) => cause,
            DescribeCACertificateError::Unauthorized(ref cause) => cause,
            DescribeCACertificateError::Validation(ref cause) => cause,
            DescribeCACertificateError::Credentials(ref err) => err.description(),
            DescribeCACertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeCACertificateError::ParseError(ref cause) => cause,
            DescribeCACertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeCertificate
#[derive(Debug, PartialEq)]
pub enum DescribeCertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeCertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeCertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeCertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeCertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeCertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeCertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeCertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeCertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeCertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeCertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeCertificateError {
    fn from(err: serde_json::error::Error) -> DescribeCertificateError {
        DescribeCertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeCertificateError {
    fn from(err: CredentialsError) -> DescribeCertificateError {
        DescribeCertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeCertificateError {
    fn from(err: HttpDispatchError) -> DescribeCertificateError {
        DescribeCertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeCertificateError {
    fn from(err: io::Error) -> DescribeCertificateError {
        DescribeCertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeCertificateError {
    fn description(&self) -> &str {
        match *self {
            DescribeCertificateError::InternalFailure(ref cause) => cause,
            DescribeCertificateError::InvalidRequest(ref cause) => cause,
            DescribeCertificateError::ResourceNotFound(ref cause) => cause,
            DescribeCertificateError::ServiceUnavailable(ref cause) => cause,
            DescribeCertificateError::Throttling(ref cause) => cause,
            DescribeCertificateError::Unauthorized(ref cause) => cause,
            DescribeCertificateError::Validation(ref cause) => cause,
            DescribeCertificateError::Credentials(ref err) => err.description(),
            DescribeCertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeCertificateError::ParseError(ref cause) => cause,
            DescribeCertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeDefaultAuthorizer
#[derive(Debug, PartialEq)]
pub enum DescribeDefaultAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeDefaultAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeDefaultAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeDefaultAuthorizerError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return DescribeDefaultAuthorizerError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return DescribeDefaultAuthorizerError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return DescribeDefaultAuthorizerError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeDefaultAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeDefaultAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeDefaultAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeDefaultAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeDefaultAuthorizerError {
    fn from(err: serde_json::error::Error) -> DescribeDefaultAuthorizerError {
        DescribeDefaultAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeDefaultAuthorizerError {
    fn from(err: CredentialsError) -> DescribeDefaultAuthorizerError {
        DescribeDefaultAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeDefaultAuthorizerError {
    fn from(err: HttpDispatchError) -> DescribeDefaultAuthorizerError {
        DescribeDefaultAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeDefaultAuthorizerError {
    fn from(err: io::Error) -> DescribeDefaultAuthorizerError {
        DescribeDefaultAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeDefaultAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeDefaultAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            DescribeDefaultAuthorizerError::InternalFailure(ref cause) => cause,
            DescribeDefaultAuthorizerError::InvalidRequest(ref cause) => cause,
            DescribeDefaultAuthorizerError::ResourceNotFound(ref cause) => cause,
            DescribeDefaultAuthorizerError::ServiceUnavailable(ref cause) => cause,
            DescribeDefaultAuthorizerError::Throttling(ref cause) => cause,
            DescribeDefaultAuthorizerError::Unauthorized(ref cause) => cause,
            DescribeDefaultAuthorizerError::Validation(ref cause) => cause,
            DescribeDefaultAuthorizerError::Credentials(ref err) => err.description(),
            DescribeDefaultAuthorizerError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeDefaultAuthorizerError::ParseError(ref cause) => cause,
            DescribeDefaultAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeEndpoint
#[derive(Debug, PartialEq)]
pub enum DescribeEndpointError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeEndpointError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeEndpointError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeEndpointError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeEndpointError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeEndpointError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeEndpointError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeEndpointError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeEndpointError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeEndpointError {
    fn from(err: serde_json::error::Error) -> DescribeEndpointError {
        DescribeEndpointError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeEndpointError {
    fn from(err: CredentialsError) -> DescribeEndpointError {
        DescribeEndpointError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeEndpointError {
    fn from(err: HttpDispatchError) -> DescribeEndpointError {
        DescribeEndpointError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeEndpointError {
    fn from(err: io::Error) -> DescribeEndpointError {
        DescribeEndpointError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeEndpointError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeEndpointError {
    fn description(&self) -> &str {
        match *self {
            DescribeEndpointError::InternalFailure(ref cause) => cause,
            DescribeEndpointError::InvalidRequest(ref cause) => cause,
            DescribeEndpointError::Throttling(ref cause) => cause,
            DescribeEndpointError::Unauthorized(ref cause) => cause,
            DescribeEndpointError::Validation(ref cause) => cause,
            DescribeEndpointError::Credentials(ref err) => err.description(),
            DescribeEndpointError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DescribeEndpointError::ParseError(ref cause) => cause,
            DescribeEndpointError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeEventConfigurations
#[derive(Debug, PartialEq)]
pub enum DescribeEventConfigurationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeEventConfigurationsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeEventConfigurationsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeEventConfigurationsError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeEventConfigurationsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeEventConfigurationsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeEventConfigurationsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeEventConfigurationsError {
    fn from(err: serde_json::error::Error) -> DescribeEventConfigurationsError {
        DescribeEventConfigurationsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeEventConfigurationsError {
    fn from(err: CredentialsError) -> DescribeEventConfigurationsError {
        DescribeEventConfigurationsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeEventConfigurationsError {
    fn from(err: HttpDispatchError) -> DescribeEventConfigurationsError {
        DescribeEventConfigurationsError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeEventConfigurationsError {
    fn from(err: io::Error) -> DescribeEventConfigurationsError {
        DescribeEventConfigurationsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeEventConfigurationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeEventConfigurationsError {
    fn description(&self) -> &str {
        match *self {
            DescribeEventConfigurationsError::InternalFailure(ref cause) => cause,
            DescribeEventConfigurationsError::Throttling(ref cause) => cause,
            DescribeEventConfigurationsError::Validation(ref cause) => cause,
            DescribeEventConfigurationsError::Credentials(ref err) => err.description(),
            DescribeEventConfigurationsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeEventConfigurationsError::ParseError(ref cause) => cause,
            DescribeEventConfigurationsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeIndex
#[derive(Debug, PartialEq)]
pub enum DescribeIndexError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeIndexError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeIndexError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeIndexError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeIndexError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeIndexError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeIndexError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeIndexError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeIndexError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeIndexError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeIndexError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeIndexError {
    fn from(err: serde_json::error::Error) -> DescribeIndexError {
        DescribeIndexError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeIndexError {
    fn from(err: CredentialsError) -> DescribeIndexError {
        DescribeIndexError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeIndexError {
    fn from(err: HttpDispatchError) -> DescribeIndexError {
        DescribeIndexError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeIndexError {
    fn from(err: io::Error) -> DescribeIndexError {
        DescribeIndexError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeIndexError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeIndexError {
    fn description(&self) -> &str {
        match *self {
            DescribeIndexError::InternalFailure(ref cause) => cause,
            DescribeIndexError::InvalidRequest(ref cause) => cause,
            DescribeIndexError::ResourceNotFound(ref cause) => cause,
            DescribeIndexError::ServiceUnavailable(ref cause) => cause,
            DescribeIndexError::Throttling(ref cause) => cause,
            DescribeIndexError::Unauthorized(ref cause) => cause,
            DescribeIndexError::Validation(ref cause) => cause,
            DescribeIndexError::Credentials(ref err) => err.description(),
            DescribeIndexError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DescribeIndexError::ParseError(ref cause) => cause,
            DescribeIndexError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeJob
#[derive(Debug, PartialEq)]
pub enum DescribeJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeJobError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeJobError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return DescribeJobError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeJobError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeJobError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeJobError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeJobError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeJobError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeJobError {
    fn from(err: serde_json::error::Error) -> DescribeJobError {
        DescribeJobError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeJobError {
    fn from(err: CredentialsError) -> DescribeJobError {
        DescribeJobError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeJobError {
    fn from(err: HttpDispatchError) -> DescribeJobError {
        DescribeJobError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeJobError {
    fn from(err: io::Error) -> DescribeJobError {
        DescribeJobError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeJobError {
    fn description(&self) -> &str {
        match *self {
            DescribeJobError::InvalidRequest(ref cause) => cause,
            DescribeJobError::ResourceNotFound(ref cause) => cause,
            DescribeJobError::ServiceUnavailable(ref cause) => cause,
            DescribeJobError::Throttling(ref cause) => cause,
            DescribeJobError::Validation(ref cause) => cause,
            DescribeJobError::Credentials(ref err) => err.description(),
            DescribeJobError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DescribeJobError::ParseError(ref cause) => cause,
            DescribeJobError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeJobExecution
#[derive(Debug, PartialEq)]
pub enum DescribeJobExecutionError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeJobExecutionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeJobExecutionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return DescribeJobExecutionError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeJobExecutionError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeJobExecutionError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeJobExecutionError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeJobExecutionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeJobExecutionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeJobExecutionError {
    fn from(err: serde_json::error::Error) -> DescribeJobExecutionError {
        DescribeJobExecutionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeJobExecutionError {
    fn from(err: CredentialsError) -> DescribeJobExecutionError {
        DescribeJobExecutionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeJobExecutionError {
    fn from(err: HttpDispatchError) -> DescribeJobExecutionError {
        DescribeJobExecutionError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeJobExecutionError {
    fn from(err: io::Error) -> DescribeJobExecutionError {
        DescribeJobExecutionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeJobExecutionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeJobExecutionError {
    fn description(&self) -> &str {
        match *self {
            DescribeJobExecutionError::InvalidRequest(ref cause) => cause,
            DescribeJobExecutionError::ResourceNotFound(ref cause) => cause,
            DescribeJobExecutionError::ServiceUnavailable(ref cause) => cause,
            DescribeJobExecutionError::Throttling(ref cause) => cause,
            DescribeJobExecutionError::Validation(ref cause) => cause,
            DescribeJobExecutionError::Credentials(ref err) => err.description(),
            DescribeJobExecutionError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeJobExecutionError::ParseError(ref cause) => cause,
            DescribeJobExecutionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeRoleAlias
#[derive(Debug, PartialEq)]
pub enum DescribeRoleAliasError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeRoleAliasError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeRoleAliasError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeRoleAliasError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeRoleAliasError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeRoleAliasError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeRoleAliasError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeRoleAliasError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeRoleAliasError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeRoleAliasError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeRoleAliasError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeRoleAliasError {
    fn from(err: serde_json::error::Error) -> DescribeRoleAliasError {
        DescribeRoleAliasError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeRoleAliasError {
    fn from(err: CredentialsError) -> DescribeRoleAliasError {
        DescribeRoleAliasError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeRoleAliasError {
    fn from(err: HttpDispatchError) -> DescribeRoleAliasError {
        DescribeRoleAliasError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeRoleAliasError {
    fn from(err: io::Error) -> DescribeRoleAliasError {
        DescribeRoleAliasError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            DescribeRoleAliasError::InternalFailure(ref cause) => cause,
            DescribeRoleAliasError::InvalidRequest(ref cause) => cause,
            DescribeRoleAliasError::ResourceNotFound(ref cause) => cause,
            DescribeRoleAliasError::ServiceUnavailable(ref cause) => cause,
            DescribeRoleAliasError::Throttling(ref cause) => cause,
            DescribeRoleAliasError::Unauthorized(ref cause) => cause,
            DescribeRoleAliasError::Validation(ref cause) => cause,
            DescribeRoleAliasError::Credentials(ref err) => err.description(),
            DescribeRoleAliasError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeRoleAliasError::ParseError(ref cause) => cause,
            DescribeRoleAliasError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeScheduledAudit
#[derive(Debug, PartialEq)]
pub enum DescribeScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeScheduledAuditError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeScheduledAuditError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeScheduledAuditError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeScheduledAuditError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeScheduledAuditError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeScheduledAuditError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeScheduledAuditError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeScheduledAuditError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeScheduledAuditError {
    fn from(err: serde_json::error::Error) -> DescribeScheduledAuditError {
        DescribeScheduledAuditError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeScheduledAuditError {
    fn from(err: CredentialsError) -> DescribeScheduledAuditError {
        DescribeScheduledAuditError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeScheduledAuditError {
    fn from(err: HttpDispatchError) -> DescribeScheduledAuditError {
        DescribeScheduledAuditError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeScheduledAuditError {
    fn from(err: io::Error) -> DescribeScheduledAuditError {
        DescribeScheduledAuditError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            DescribeScheduledAuditError::InternalFailure(ref cause) => cause,
            DescribeScheduledAuditError::InvalidRequest(ref cause) => cause,
            DescribeScheduledAuditError::ResourceNotFound(ref cause) => cause,
            DescribeScheduledAuditError::Throttling(ref cause) => cause,
            DescribeScheduledAuditError::Validation(ref cause) => cause,
            DescribeScheduledAuditError::Credentials(ref err) => err.description(),
            DescribeScheduledAuditError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeScheduledAuditError::ParseError(ref cause) => cause,
            DescribeScheduledAuditError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeSecurityProfile
#[derive(Debug, PartialEq)]
pub enum DescribeSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeSecurityProfileError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return DescribeSecurityProfileError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeSecurityProfileError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeSecurityProfileError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeSecurityProfileError {
    fn from(err: serde_json::error::Error) -> DescribeSecurityProfileError {
        DescribeSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeSecurityProfileError {
    fn from(err: CredentialsError) -> DescribeSecurityProfileError {
        DescribeSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeSecurityProfileError {
    fn from(err: HttpDispatchError) -> DescribeSecurityProfileError {
        DescribeSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeSecurityProfileError {
    fn from(err: io::Error) -> DescribeSecurityProfileError {
        DescribeSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            DescribeSecurityProfileError::InternalFailure(ref cause) => cause,
            DescribeSecurityProfileError::InvalidRequest(ref cause) => cause,
            DescribeSecurityProfileError::ResourceNotFound(ref cause) => cause,
            DescribeSecurityProfileError::Throttling(ref cause) => cause,
            DescribeSecurityProfileError::Validation(ref cause) => cause,
            DescribeSecurityProfileError::Credentials(ref err) => err.description(),
            DescribeSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeSecurityProfileError::ParseError(ref cause) => cause,
            DescribeSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeStream
#[derive(Debug, PartialEq)]
pub enum DescribeStreamError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeStreamError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeStreamError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeStreamError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeStreamError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeStreamError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeStreamError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeStreamError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeStreamError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeStreamError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeStreamError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeStreamError {
    fn from(err: serde_json::error::Error) -> DescribeStreamError {
        DescribeStreamError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeStreamError {
    fn from(err: CredentialsError) -> DescribeStreamError {
        DescribeStreamError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeStreamError {
    fn from(err: HttpDispatchError) -> DescribeStreamError {
        DescribeStreamError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeStreamError {
    fn from(err: io::Error) -> DescribeStreamError {
        DescribeStreamError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeStreamError {
    fn description(&self) -> &str {
        match *self {
            DescribeStreamError::InternalFailure(ref cause) => cause,
            DescribeStreamError::InvalidRequest(ref cause) => cause,
            DescribeStreamError::ResourceNotFound(ref cause) => cause,
            DescribeStreamError::ServiceUnavailable(ref cause) => cause,
            DescribeStreamError::Throttling(ref cause) => cause,
            DescribeStreamError::Unauthorized(ref cause) => cause,
            DescribeStreamError::Validation(ref cause) => cause,
            DescribeStreamError::Credentials(ref err) => err.description(),
            DescribeStreamError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DescribeStreamError::ParseError(ref cause) => cause,
            DescribeStreamError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeThing
#[derive(Debug, PartialEq)]
pub enum DescribeThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeThingError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeThingError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeThingError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeThingError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeThingError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeThingError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeThingError {
    fn from(err: serde_json::error::Error) -> DescribeThingError {
        DescribeThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeThingError {
    fn from(err: CredentialsError) -> DescribeThingError {
        DescribeThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeThingError {
    fn from(err: HttpDispatchError) -> DescribeThingError {
        DescribeThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeThingError {
    fn from(err: io::Error) -> DescribeThingError {
        DescribeThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingError::InternalFailure(ref cause) => cause,
            DescribeThingError::InvalidRequest(ref cause) => cause,
            DescribeThingError::ResourceNotFound(ref cause) => cause,
            DescribeThingError::ServiceUnavailable(ref cause) => cause,
            DescribeThingError::Throttling(ref cause) => cause,
            DescribeThingError::Unauthorized(ref cause) => cause,
            DescribeThingError::Validation(ref cause) => cause,
            DescribeThingError::Credentials(ref err) => err.description(),
            DescribeThingError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DescribeThingError::ParseError(ref cause) => cause,
            DescribeThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeThingGroup
#[derive(Debug, PartialEq)]
pub enum DescribeThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeThingGroupError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeThingGroupError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeThingGroupError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeThingGroupError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeThingGroupError {
    fn from(err: serde_json::error::Error) -> DescribeThingGroupError {
        DescribeThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeThingGroupError {
    fn from(err: CredentialsError) -> DescribeThingGroupError {
        DescribeThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeThingGroupError {
    fn from(err: HttpDispatchError) -> DescribeThingGroupError {
        DescribeThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeThingGroupError {
    fn from(err: io::Error) -> DescribeThingGroupError {
        DescribeThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingGroupError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingGroupError::InternalFailure(ref cause) => cause,
            DescribeThingGroupError::InvalidRequest(ref cause) => cause,
            DescribeThingGroupError::ResourceNotFound(ref cause) => cause,
            DescribeThingGroupError::Throttling(ref cause) => cause,
            DescribeThingGroupError::Validation(ref cause) => cause,
            DescribeThingGroupError::Credentials(ref err) => err.description(),
            DescribeThingGroupError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeThingGroupError::ParseError(ref cause) => cause,
            DescribeThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeThingRegistrationTask
#[derive(Debug, PartialEq)]
pub enum DescribeThingRegistrationTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeThingRegistrationTaskError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeThingRegistrationTaskError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeThingRegistrationTaskError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return DescribeThingRegistrationTaskError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return DescribeThingRegistrationTaskError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DescribeThingRegistrationTaskError::Throttling(String::from(
                        error_message,
                    ))
                }
                "UnauthorizedException" => {
                    return DescribeThingRegistrationTaskError::Unauthorized(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return DescribeThingRegistrationTaskError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeThingRegistrationTaskError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeThingRegistrationTaskError {
    fn from(err: serde_json::error::Error) -> DescribeThingRegistrationTaskError {
        DescribeThingRegistrationTaskError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeThingRegistrationTaskError {
    fn from(err: CredentialsError) -> DescribeThingRegistrationTaskError {
        DescribeThingRegistrationTaskError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeThingRegistrationTaskError {
    fn from(err: HttpDispatchError) -> DescribeThingRegistrationTaskError {
        DescribeThingRegistrationTaskError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeThingRegistrationTaskError {
    fn from(err: io::Error) -> DescribeThingRegistrationTaskError {
        DescribeThingRegistrationTaskError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeThingRegistrationTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingRegistrationTaskError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingRegistrationTaskError::InternalFailure(ref cause) => cause,
            DescribeThingRegistrationTaskError::InvalidRequest(ref cause) => cause,
            DescribeThingRegistrationTaskError::ResourceNotFound(ref cause) => cause,
            DescribeThingRegistrationTaskError::Throttling(ref cause) => cause,
            DescribeThingRegistrationTaskError::Unauthorized(ref cause) => cause,
            DescribeThingRegistrationTaskError::Validation(ref cause) => cause,
            DescribeThingRegistrationTaskError::Credentials(ref err) => err.description(),
            DescribeThingRegistrationTaskError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeThingRegistrationTaskError::ParseError(ref cause) => cause,
            DescribeThingRegistrationTaskError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DescribeThingType
#[derive(Debug, PartialEq)]
pub enum DescribeThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DescribeThingTypeError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DescribeThingTypeError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DescribeThingTypeError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DescribeThingTypeError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DescribeThingTypeError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DescribeThingTypeError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DescribeThingTypeError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DescribeThingTypeError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DescribeThingTypeError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DescribeThingTypeError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DescribeThingTypeError {
    fn from(err: serde_json::error::Error) -> DescribeThingTypeError {
        DescribeThingTypeError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DescribeThingTypeError {
    fn from(err: CredentialsError) -> DescribeThingTypeError {
        DescribeThingTypeError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DescribeThingTypeError {
    fn from(err: HttpDispatchError) -> DescribeThingTypeError {
        DescribeThingTypeError::HttpDispatch(err)
    }
}
impl From<io::Error> for DescribeThingTypeError {
    fn from(err: io::Error) -> DescribeThingTypeError {
        DescribeThingTypeError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DescribeThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingTypeError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingTypeError::InternalFailure(ref cause) => cause,
            DescribeThingTypeError::InvalidRequest(ref cause) => cause,
            DescribeThingTypeError::ResourceNotFound(ref cause) => cause,
            DescribeThingTypeError::ServiceUnavailable(ref cause) => cause,
            DescribeThingTypeError::Throttling(ref cause) => cause,
            DescribeThingTypeError::Unauthorized(ref cause) => cause,
            DescribeThingTypeError::Validation(ref cause) => cause,
            DescribeThingTypeError::Credentials(ref err) => err.description(),
            DescribeThingTypeError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DescribeThingTypeError::ParseError(ref cause) => cause,
            DescribeThingTypeError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DetachPolicy
#[derive(Debug, PartialEq)]
pub enum DetachPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DetachPolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DetachPolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DetachPolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DetachPolicyError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return DetachPolicyError::LimitExceeded(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DetachPolicyError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DetachPolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DetachPolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DetachPolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DetachPolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DetachPolicyError {
    fn from(err: serde_json::error::Error) -> DetachPolicyError {
        DetachPolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DetachPolicyError {
    fn from(err: CredentialsError) -> DetachPolicyError {
        DetachPolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DetachPolicyError {
    fn from(err: HttpDispatchError) -> DetachPolicyError {
        DetachPolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for DetachPolicyError {
    fn from(err: io::Error) -> DetachPolicyError {
        DetachPolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DetachPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachPolicyError {
    fn description(&self) -> &str {
        match *self {
            DetachPolicyError::InternalFailure(ref cause) => cause,
            DetachPolicyError::InvalidRequest(ref cause) => cause,
            DetachPolicyError::LimitExceeded(ref cause) => cause,
            DetachPolicyError::ServiceUnavailable(ref cause) => cause,
            DetachPolicyError::Throttling(ref cause) => cause,
            DetachPolicyError::Unauthorized(ref cause) => cause,
            DetachPolicyError::Validation(ref cause) => cause,
            DetachPolicyError::Credentials(ref err) => err.description(),
            DetachPolicyError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DetachPolicyError::ParseError(ref cause) => cause,
            DetachPolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DetachPrincipalPolicy
#[derive(Debug, PartialEq)]
pub enum DetachPrincipalPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DetachPrincipalPolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DetachPrincipalPolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DetachPrincipalPolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DetachPrincipalPolicyError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DetachPrincipalPolicyError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DetachPrincipalPolicyError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DetachPrincipalPolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DetachPrincipalPolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DetachPrincipalPolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DetachPrincipalPolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DetachPrincipalPolicyError {
    fn from(err: serde_json::error::Error) -> DetachPrincipalPolicyError {
        DetachPrincipalPolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DetachPrincipalPolicyError {
    fn from(err: CredentialsError) -> DetachPrincipalPolicyError {
        DetachPrincipalPolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DetachPrincipalPolicyError {
    fn from(err: HttpDispatchError) -> DetachPrincipalPolicyError {
        DetachPrincipalPolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for DetachPrincipalPolicyError {
    fn from(err: io::Error) -> DetachPrincipalPolicyError {
        DetachPrincipalPolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DetachPrincipalPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachPrincipalPolicyError {
    fn description(&self) -> &str {
        match *self {
            DetachPrincipalPolicyError::InternalFailure(ref cause) => cause,
            DetachPrincipalPolicyError::InvalidRequest(ref cause) => cause,
            DetachPrincipalPolicyError::ResourceNotFound(ref cause) => cause,
            DetachPrincipalPolicyError::ServiceUnavailable(ref cause) => cause,
            DetachPrincipalPolicyError::Throttling(ref cause) => cause,
            DetachPrincipalPolicyError::Unauthorized(ref cause) => cause,
            DetachPrincipalPolicyError::Validation(ref cause) => cause,
            DetachPrincipalPolicyError::Credentials(ref err) => err.description(),
            DetachPrincipalPolicyError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DetachPrincipalPolicyError::ParseError(ref cause) => cause,
            DetachPrincipalPolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DetachSecurityProfile
#[derive(Debug, PartialEq)]
pub enum DetachSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DetachSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DetachSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DetachSecurityProfileError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DetachSecurityProfileError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DetachSecurityProfileError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return DetachSecurityProfileError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return DetachSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DetachSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DetachSecurityProfileError {
    fn from(err: serde_json::error::Error) -> DetachSecurityProfileError {
        DetachSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DetachSecurityProfileError {
    fn from(err: CredentialsError) -> DetachSecurityProfileError {
        DetachSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DetachSecurityProfileError {
    fn from(err: HttpDispatchError) -> DetachSecurityProfileError {
        DetachSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for DetachSecurityProfileError {
    fn from(err: io::Error) -> DetachSecurityProfileError {
        DetachSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DetachSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            DetachSecurityProfileError::InternalFailure(ref cause) => cause,
            DetachSecurityProfileError::InvalidRequest(ref cause) => cause,
            DetachSecurityProfileError::ResourceNotFound(ref cause) => cause,
            DetachSecurityProfileError::Throttling(ref cause) => cause,
            DetachSecurityProfileError::Validation(ref cause) => cause,
            DetachSecurityProfileError::Credentials(ref err) => err.description(),
            DetachSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DetachSecurityProfileError::ParseError(ref cause) => cause,
            DetachSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DetachThingPrincipal
#[derive(Debug, PartialEq)]
pub enum DetachThingPrincipalError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DetachThingPrincipalError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DetachThingPrincipalError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return DetachThingPrincipalError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DetachThingPrincipalError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return DetachThingPrincipalError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DetachThingPrincipalError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return DetachThingPrincipalError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DetachThingPrincipalError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DetachThingPrincipalError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DetachThingPrincipalError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DetachThingPrincipalError {
    fn from(err: serde_json::error::Error) -> DetachThingPrincipalError {
        DetachThingPrincipalError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DetachThingPrincipalError {
    fn from(err: CredentialsError) -> DetachThingPrincipalError {
        DetachThingPrincipalError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DetachThingPrincipalError {
    fn from(err: HttpDispatchError) -> DetachThingPrincipalError {
        DetachThingPrincipalError::HttpDispatch(err)
    }
}
impl From<io::Error> for DetachThingPrincipalError {
    fn from(err: io::Error) -> DetachThingPrincipalError {
        DetachThingPrincipalError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DetachThingPrincipalError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachThingPrincipalError {
    fn description(&self) -> &str {
        match *self {
            DetachThingPrincipalError::InternalFailure(ref cause) => cause,
            DetachThingPrincipalError::InvalidRequest(ref cause) => cause,
            DetachThingPrincipalError::ResourceNotFound(ref cause) => cause,
            DetachThingPrincipalError::ServiceUnavailable(ref cause) => cause,
            DetachThingPrincipalError::Throttling(ref cause) => cause,
            DetachThingPrincipalError::Unauthorized(ref cause) => cause,
            DetachThingPrincipalError::Validation(ref cause) => cause,
            DetachThingPrincipalError::Credentials(ref err) => err.description(),
            DetachThingPrincipalError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            DetachThingPrincipalError::ParseError(ref cause) => cause,
            DetachThingPrincipalError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by DisableTopicRule
#[derive(Debug, PartialEq)]
pub enum DisableTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl DisableTopicRuleError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> DisableTopicRuleError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return DisableTopicRuleError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return DisableTopicRuleError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return DisableTopicRuleError::ServiceUnavailable(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return DisableTopicRuleError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return DisableTopicRuleError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return DisableTopicRuleError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for DisableTopicRuleError {
    fn from(err: serde_json::error::Error) -> DisableTopicRuleError {
        DisableTopicRuleError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for DisableTopicRuleError {
    fn from(err: CredentialsError) -> DisableTopicRuleError {
        DisableTopicRuleError::Credentials(err)
    }
}
impl From<HttpDispatchError> for DisableTopicRuleError {
    fn from(err: HttpDispatchError) -> DisableTopicRuleError {
        DisableTopicRuleError::HttpDispatch(err)
    }
}
impl From<io::Error> for DisableTopicRuleError {
    fn from(err: io::Error) -> DisableTopicRuleError {
        DisableTopicRuleError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for DisableTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DisableTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            DisableTopicRuleError::Internal(ref cause) => cause,
            DisableTopicRuleError::InvalidRequest(ref cause) => cause,
            DisableTopicRuleError::ServiceUnavailable(ref cause) => cause,
            DisableTopicRuleError::Unauthorized(ref cause) => cause,
            DisableTopicRuleError::Validation(ref cause) => cause,
            DisableTopicRuleError::Credentials(ref err) => err.description(),
            DisableTopicRuleError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            DisableTopicRuleError::ParseError(ref cause) => cause,
            DisableTopicRuleError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by EnableTopicRule
#[derive(Debug, PartialEq)]
pub enum EnableTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl EnableTopicRuleError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> EnableTopicRuleError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return EnableTopicRuleError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return EnableTopicRuleError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return EnableTopicRuleError::ServiceUnavailable(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return EnableTopicRuleError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return EnableTopicRuleError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return EnableTopicRuleError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for EnableTopicRuleError {
    fn from(err: serde_json::error::Error) -> EnableTopicRuleError {
        EnableTopicRuleError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for EnableTopicRuleError {
    fn from(err: CredentialsError) -> EnableTopicRuleError {
        EnableTopicRuleError::Credentials(err)
    }
}
impl From<HttpDispatchError> for EnableTopicRuleError {
    fn from(err: HttpDispatchError) -> EnableTopicRuleError {
        EnableTopicRuleError::HttpDispatch(err)
    }
}
impl From<io::Error> for EnableTopicRuleError {
    fn from(err: io::Error) -> EnableTopicRuleError {
        EnableTopicRuleError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for EnableTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for EnableTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            EnableTopicRuleError::Internal(ref cause) => cause,
            EnableTopicRuleError::InvalidRequest(ref cause) => cause,
            EnableTopicRuleError::ServiceUnavailable(ref cause) => cause,
            EnableTopicRuleError::Unauthorized(ref cause) => cause,
            EnableTopicRuleError::Validation(ref cause) => cause,
            EnableTopicRuleError::Credentials(ref err) => err.description(),
            EnableTopicRuleError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            EnableTopicRuleError::ParseError(ref cause) => cause,
            EnableTopicRuleError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetEffectivePolicies
#[derive(Debug, PartialEq)]
pub enum GetEffectivePoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetEffectivePoliciesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetEffectivePoliciesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return GetEffectivePoliciesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetEffectivePoliciesError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return GetEffectivePoliciesError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return GetEffectivePoliciesError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetEffectivePoliciesError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return GetEffectivePoliciesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetEffectivePoliciesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetEffectivePoliciesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetEffectivePoliciesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetEffectivePoliciesError {
    fn from(err: serde_json::error::Error) -> GetEffectivePoliciesError {
        GetEffectivePoliciesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetEffectivePoliciesError {
    fn from(err: CredentialsError) -> GetEffectivePoliciesError {
        GetEffectivePoliciesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetEffectivePoliciesError {
    fn from(err: HttpDispatchError) -> GetEffectivePoliciesError {
        GetEffectivePoliciesError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetEffectivePoliciesError {
    fn from(err: io::Error) -> GetEffectivePoliciesError {
        GetEffectivePoliciesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetEffectivePoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetEffectivePoliciesError {
    fn description(&self) -> &str {
        match *self {
            GetEffectivePoliciesError::InternalFailure(ref cause) => cause,
            GetEffectivePoliciesError::InvalidRequest(ref cause) => cause,
            GetEffectivePoliciesError::LimitExceeded(ref cause) => cause,
            GetEffectivePoliciesError::ResourceNotFound(ref cause) => cause,
            GetEffectivePoliciesError::ServiceUnavailable(ref cause) => cause,
            GetEffectivePoliciesError::Throttling(ref cause) => cause,
            GetEffectivePoliciesError::Unauthorized(ref cause) => cause,
            GetEffectivePoliciesError::Validation(ref cause) => cause,
            GetEffectivePoliciesError::Credentials(ref err) => err.description(),
            GetEffectivePoliciesError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            GetEffectivePoliciesError::ParseError(ref cause) => cause,
            GetEffectivePoliciesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetIndexingConfiguration
#[derive(Debug, PartialEq)]
pub enum GetIndexingConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetIndexingConfigurationError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetIndexingConfigurationError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return GetIndexingConfigurationError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return GetIndexingConfigurationError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return GetIndexingConfigurationError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return GetIndexingConfigurationError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetIndexingConfigurationError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetIndexingConfigurationError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetIndexingConfigurationError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetIndexingConfigurationError {
    fn from(err: serde_json::error::Error) -> GetIndexingConfigurationError {
        GetIndexingConfigurationError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetIndexingConfigurationError {
    fn from(err: CredentialsError) -> GetIndexingConfigurationError {
        GetIndexingConfigurationError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetIndexingConfigurationError {
    fn from(err: HttpDispatchError) -> GetIndexingConfigurationError {
        GetIndexingConfigurationError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetIndexingConfigurationError {
    fn from(err: io::Error) -> GetIndexingConfigurationError {
        GetIndexingConfigurationError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetIndexingConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetIndexingConfigurationError {
    fn description(&self) -> &str {
        match *self {
            GetIndexingConfigurationError::InternalFailure(ref cause) => cause,
            GetIndexingConfigurationError::InvalidRequest(ref cause) => cause,
            GetIndexingConfigurationError::ServiceUnavailable(ref cause) => cause,
            GetIndexingConfigurationError::Throttling(ref cause) => cause,
            GetIndexingConfigurationError::Unauthorized(ref cause) => cause,
            GetIndexingConfigurationError::Validation(ref cause) => cause,
            GetIndexingConfigurationError::Credentials(ref err) => err.description(),
            GetIndexingConfigurationError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            GetIndexingConfigurationError::ParseError(ref cause) => cause,
            GetIndexingConfigurationError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetJobDocument
#[derive(Debug, PartialEq)]
pub enum GetJobDocumentError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetJobDocumentError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetJobDocumentError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return GetJobDocumentError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return GetJobDocumentError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetJobDocumentError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return GetJobDocumentError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return GetJobDocumentError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetJobDocumentError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetJobDocumentError {
    fn from(err: serde_json::error::Error) -> GetJobDocumentError {
        GetJobDocumentError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetJobDocumentError {
    fn from(err: CredentialsError) -> GetJobDocumentError {
        GetJobDocumentError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetJobDocumentError {
    fn from(err: HttpDispatchError) -> GetJobDocumentError {
        GetJobDocumentError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetJobDocumentError {
    fn from(err: io::Error) -> GetJobDocumentError {
        GetJobDocumentError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetJobDocumentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetJobDocumentError {
    fn description(&self) -> &str {
        match *self {
            GetJobDocumentError::InvalidRequest(ref cause) => cause,
            GetJobDocumentError::ResourceNotFound(ref cause) => cause,
            GetJobDocumentError::ServiceUnavailable(ref cause) => cause,
            GetJobDocumentError::Throttling(ref cause) => cause,
            GetJobDocumentError::Validation(ref cause) => cause,
            GetJobDocumentError::Credentials(ref err) => err.description(),
            GetJobDocumentError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            GetJobDocumentError::ParseError(ref cause) => cause,
            GetJobDocumentError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetLoggingOptions
#[derive(Debug, PartialEq)]
pub enum GetLoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetLoggingOptionsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetLoggingOptionsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return GetLoggingOptionsError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetLoggingOptionsError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetLoggingOptionsError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return GetLoggingOptionsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetLoggingOptionsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetLoggingOptionsError {
    fn from(err: serde_json::error::Error) -> GetLoggingOptionsError {
        GetLoggingOptionsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetLoggingOptionsError {
    fn from(err: CredentialsError) -> GetLoggingOptionsError {
        GetLoggingOptionsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetLoggingOptionsError {
    fn from(err: HttpDispatchError) -> GetLoggingOptionsError {
        GetLoggingOptionsError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetLoggingOptionsError {
    fn from(err: io::Error) -> GetLoggingOptionsError {
        GetLoggingOptionsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetLoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetLoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            GetLoggingOptionsError::Internal(ref cause) => cause,
            GetLoggingOptionsError::InvalidRequest(ref cause) => cause,
            GetLoggingOptionsError::ServiceUnavailable(ref cause) => cause,
            GetLoggingOptionsError::Validation(ref cause) => cause,
            GetLoggingOptionsError::Credentials(ref err) => err.description(),
            GetLoggingOptionsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            GetLoggingOptionsError::ParseError(ref cause) => cause,
            GetLoggingOptionsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetOTAUpdate
#[derive(Debug, PartialEq)]
pub enum GetOTAUpdateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetOTAUpdateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetOTAUpdateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return GetOTAUpdateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetOTAUpdateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return GetOTAUpdateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetOTAUpdateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return GetOTAUpdateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetOTAUpdateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetOTAUpdateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetOTAUpdateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetOTAUpdateError {
    fn from(err: serde_json::error::Error) -> GetOTAUpdateError {
        GetOTAUpdateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetOTAUpdateError {
    fn from(err: CredentialsError) -> GetOTAUpdateError {
        GetOTAUpdateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetOTAUpdateError {
    fn from(err: HttpDispatchError) -> GetOTAUpdateError {
        GetOTAUpdateError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetOTAUpdateError {
    fn from(err: io::Error) -> GetOTAUpdateError {
        GetOTAUpdateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetOTAUpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetOTAUpdateError {
    fn description(&self) -> &str {
        match *self {
            GetOTAUpdateError::InternalFailure(ref cause) => cause,
            GetOTAUpdateError::InvalidRequest(ref cause) => cause,
            GetOTAUpdateError::ResourceNotFound(ref cause) => cause,
            GetOTAUpdateError::ServiceUnavailable(ref cause) => cause,
            GetOTAUpdateError::Throttling(ref cause) => cause,
            GetOTAUpdateError::Unauthorized(ref cause) => cause,
            GetOTAUpdateError::Validation(ref cause) => cause,
            GetOTAUpdateError::Credentials(ref err) => err.description(),
            GetOTAUpdateError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            GetOTAUpdateError::ParseError(ref cause) => cause,
            GetOTAUpdateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetPolicy
#[derive(Debug, PartialEq)]
pub enum GetPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetPolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetPolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return GetPolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetPolicyError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return GetPolicyError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetPolicyError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return GetPolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetPolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetPolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetPolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetPolicyError {
    fn from(err: serde_json::error::Error) -> GetPolicyError {
        GetPolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetPolicyError {
    fn from(err: CredentialsError) -> GetPolicyError {
        GetPolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetPolicyError {
    fn from(err: HttpDispatchError) -> GetPolicyError {
        GetPolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetPolicyError {
    fn from(err: io::Error) -> GetPolicyError {
        GetPolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetPolicyError {
    fn description(&self) -> &str {
        match *self {
            GetPolicyError::InternalFailure(ref cause) => cause,
            GetPolicyError::InvalidRequest(ref cause) => cause,
            GetPolicyError::ResourceNotFound(ref cause) => cause,
            GetPolicyError::ServiceUnavailable(ref cause) => cause,
            GetPolicyError::Throttling(ref cause) => cause,
            GetPolicyError::Unauthorized(ref cause) => cause,
            GetPolicyError::Validation(ref cause) => cause,
            GetPolicyError::Credentials(ref err) => err.description(),
            GetPolicyError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            GetPolicyError::ParseError(ref cause) => cause,
            GetPolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetPolicyVersion
#[derive(Debug, PartialEq)]
pub enum GetPolicyVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetPolicyVersionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetPolicyVersionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return GetPolicyVersionError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetPolicyVersionError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return GetPolicyVersionError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetPolicyVersionError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return GetPolicyVersionError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetPolicyVersionError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetPolicyVersionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetPolicyVersionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetPolicyVersionError {
    fn from(err: serde_json::error::Error) -> GetPolicyVersionError {
        GetPolicyVersionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetPolicyVersionError {
    fn from(err: CredentialsError) -> GetPolicyVersionError {
        GetPolicyVersionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetPolicyVersionError {
    fn from(err: HttpDispatchError) -> GetPolicyVersionError {
        GetPolicyVersionError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetPolicyVersionError {
    fn from(err: io::Error) -> GetPolicyVersionError {
        GetPolicyVersionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetPolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetPolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            GetPolicyVersionError::InternalFailure(ref cause) => cause,
            GetPolicyVersionError::InvalidRequest(ref cause) => cause,
            GetPolicyVersionError::ResourceNotFound(ref cause) => cause,
            GetPolicyVersionError::ServiceUnavailable(ref cause) => cause,
            GetPolicyVersionError::Throttling(ref cause) => cause,
            GetPolicyVersionError::Unauthorized(ref cause) => cause,
            GetPolicyVersionError::Validation(ref cause) => cause,
            GetPolicyVersionError::Credentials(ref err) => err.description(),
            GetPolicyVersionError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            GetPolicyVersionError::ParseError(ref cause) => cause,
            GetPolicyVersionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetRegistrationCode
#[derive(Debug, PartialEq)]
pub enum GetRegistrationCodeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetRegistrationCodeError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetRegistrationCodeError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return GetRegistrationCodeError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetRegistrationCodeError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetRegistrationCodeError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return GetRegistrationCodeError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetRegistrationCodeError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetRegistrationCodeError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetRegistrationCodeError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetRegistrationCodeError {
    fn from(err: serde_json::error::Error) -> GetRegistrationCodeError {
        GetRegistrationCodeError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetRegistrationCodeError {
    fn from(err: CredentialsError) -> GetRegistrationCodeError {
        GetRegistrationCodeError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetRegistrationCodeError {
    fn from(err: HttpDispatchError) -> GetRegistrationCodeError {
        GetRegistrationCodeError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetRegistrationCodeError {
    fn from(err: io::Error) -> GetRegistrationCodeError {
        GetRegistrationCodeError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetRegistrationCodeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetRegistrationCodeError {
    fn description(&self) -> &str {
        match *self {
            GetRegistrationCodeError::InternalFailure(ref cause) => cause,
            GetRegistrationCodeError::InvalidRequest(ref cause) => cause,
            GetRegistrationCodeError::ServiceUnavailable(ref cause) => cause,
            GetRegistrationCodeError::Throttling(ref cause) => cause,
            GetRegistrationCodeError::Unauthorized(ref cause) => cause,
            GetRegistrationCodeError::Validation(ref cause) => cause,
            GetRegistrationCodeError::Credentials(ref err) => err.description(),
            GetRegistrationCodeError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            GetRegistrationCodeError::ParseError(ref cause) => cause,
            GetRegistrationCodeError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetTopicRule
#[derive(Debug, PartialEq)]
pub enum GetTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetTopicRuleError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetTopicRuleError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return GetTopicRuleError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return GetTopicRuleError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetTopicRuleError::ServiceUnavailable(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return GetTopicRuleError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return GetTopicRuleError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetTopicRuleError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetTopicRuleError {
    fn from(err: serde_json::error::Error) -> GetTopicRuleError {
        GetTopicRuleError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetTopicRuleError {
    fn from(err: CredentialsError) -> GetTopicRuleError {
        GetTopicRuleError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetTopicRuleError {
    fn from(err: HttpDispatchError) -> GetTopicRuleError {
        GetTopicRuleError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetTopicRuleError {
    fn from(err: io::Error) -> GetTopicRuleError {
        GetTopicRuleError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            GetTopicRuleError::Internal(ref cause) => cause,
            GetTopicRuleError::InvalidRequest(ref cause) => cause,
            GetTopicRuleError::ServiceUnavailable(ref cause) => cause,
            GetTopicRuleError::Unauthorized(ref cause) => cause,
            GetTopicRuleError::Validation(ref cause) => cause,
            GetTopicRuleError::Credentials(ref err) => err.description(),
            GetTopicRuleError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            GetTopicRuleError::ParseError(ref cause) => cause,
            GetTopicRuleError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by GetV2LoggingOptions
#[derive(Debug, PartialEq)]
pub enum GetV2LoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The resource is not configured.</p>
    NotConfigured(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl GetV2LoggingOptionsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> GetV2LoggingOptionsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return GetV2LoggingOptionsError::Internal(String::from(error_message))
                }
                "NotConfiguredException" => {
                    return GetV2LoggingOptionsError::NotConfigured(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return GetV2LoggingOptionsError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return GetV2LoggingOptionsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return GetV2LoggingOptionsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for GetV2LoggingOptionsError {
    fn from(err: serde_json::error::Error) -> GetV2LoggingOptionsError {
        GetV2LoggingOptionsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for GetV2LoggingOptionsError {
    fn from(err: CredentialsError) -> GetV2LoggingOptionsError {
        GetV2LoggingOptionsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for GetV2LoggingOptionsError {
    fn from(err: HttpDispatchError) -> GetV2LoggingOptionsError {
        GetV2LoggingOptionsError::HttpDispatch(err)
    }
}
impl From<io::Error> for GetV2LoggingOptionsError {
    fn from(err: io::Error) -> GetV2LoggingOptionsError {
        GetV2LoggingOptionsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for GetV2LoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetV2LoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            GetV2LoggingOptionsError::Internal(ref cause) => cause,
            GetV2LoggingOptionsError::NotConfigured(ref cause) => cause,
            GetV2LoggingOptionsError::ServiceUnavailable(ref cause) => cause,
            GetV2LoggingOptionsError::Validation(ref cause) => cause,
            GetV2LoggingOptionsError::Credentials(ref err) => err.description(),
            GetV2LoggingOptionsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            GetV2LoggingOptionsError::ParseError(ref cause) => cause,
            GetV2LoggingOptionsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListActiveViolations
#[derive(Debug, PartialEq)]
pub enum ListActiveViolationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListActiveViolationsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListActiveViolationsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListActiveViolationsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListActiveViolationsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListActiveViolationsError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListActiveViolationsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListActiveViolationsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListActiveViolationsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListActiveViolationsError {
    fn from(err: serde_json::error::Error) -> ListActiveViolationsError {
        ListActiveViolationsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListActiveViolationsError {
    fn from(err: CredentialsError) -> ListActiveViolationsError {
        ListActiveViolationsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListActiveViolationsError {
    fn from(err: HttpDispatchError) -> ListActiveViolationsError {
        ListActiveViolationsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListActiveViolationsError {
    fn from(err: io::Error) -> ListActiveViolationsError {
        ListActiveViolationsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListActiveViolationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListActiveViolationsError {
    fn description(&self) -> &str {
        match *self {
            ListActiveViolationsError::InternalFailure(ref cause) => cause,
            ListActiveViolationsError::InvalidRequest(ref cause) => cause,
            ListActiveViolationsError::ResourceNotFound(ref cause) => cause,
            ListActiveViolationsError::Throttling(ref cause) => cause,
            ListActiveViolationsError::Validation(ref cause) => cause,
            ListActiveViolationsError::Credentials(ref err) => err.description(),
            ListActiveViolationsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListActiveViolationsError::ParseError(ref cause) => cause,
            ListActiveViolationsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListAttachedPolicies
#[derive(Debug, PartialEq)]
pub enum ListAttachedPoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListAttachedPoliciesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListAttachedPoliciesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListAttachedPoliciesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListAttachedPoliciesError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return ListAttachedPoliciesError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListAttachedPoliciesError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListAttachedPoliciesError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListAttachedPoliciesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListAttachedPoliciesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListAttachedPoliciesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListAttachedPoliciesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListAttachedPoliciesError {
    fn from(err: serde_json::error::Error) -> ListAttachedPoliciesError {
        ListAttachedPoliciesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListAttachedPoliciesError {
    fn from(err: CredentialsError) -> ListAttachedPoliciesError {
        ListAttachedPoliciesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListAttachedPoliciesError {
    fn from(err: HttpDispatchError) -> ListAttachedPoliciesError {
        ListAttachedPoliciesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListAttachedPoliciesError {
    fn from(err: io::Error) -> ListAttachedPoliciesError {
        ListAttachedPoliciesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListAttachedPoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAttachedPoliciesError {
    fn description(&self) -> &str {
        match *self {
            ListAttachedPoliciesError::InternalFailure(ref cause) => cause,
            ListAttachedPoliciesError::InvalidRequest(ref cause) => cause,
            ListAttachedPoliciesError::LimitExceeded(ref cause) => cause,
            ListAttachedPoliciesError::ResourceNotFound(ref cause) => cause,
            ListAttachedPoliciesError::ServiceUnavailable(ref cause) => cause,
            ListAttachedPoliciesError::Throttling(ref cause) => cause,
            ListAttachedPoliciesError::Unauthorized(ref cause) => cause,
            ListAttachedPoliciesError::Validation(ref cause) => cause,
            ListAttachedPoliciesError::Credentials(ref err) => err.description(),
            ListAttachedPoliciesError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListAttachedPoliciesError::ParseError(ref cause) => cause,
            ListAttachedPoliciesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListAuditFindings
#[derive(Debug, PartialEq)]
pub enum ListAuditFindingsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListAuditFindingsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListAuditFindingsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListAuditFindingsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListAuditFindingsError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListAuditFindingsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListAuditFindingsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListAuditFindingsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListAuditFindingsError {
    fn from(err: serde_json::error::Error) -> ListAuditFindingsError {
        ListAuditFindingsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListAuditFindingsError {
    fn from(err: CredentialsError) -> ListAuditFindingsError {
        ListAuditFindingsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListAuditFindingsError {
    fn from(err: HttpDispatchError) -> ListAuditFindingsError {
        ListAuditFindingsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListAuditFindingsError {
    fn from(err: io::Error) -> ListAuditFindingsError {
        ListAuditFindingsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListAuditFindingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuditFindingsError {
    fn description(&self) -> &str {
        match *self {
            ListAuditFindingsError::InternalFailure(ref cause) => cause,
            ListAuditFindingsError::InvalidRequest(ref cause) => cause,
            ListAuditFindingsError::Throttling(ref cause) => cause,
            ListAuditFindingsError::Validation(ref cause) => cause,
            ListAuditFindingsError::Credentials(ref err) => err.description(),
            ListAuditFindingsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListAuditFindingsError::ParseError(ref cause) => cause,
            ListAuditFindingsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListAuditTasks
#[derive(Debug, PartialEq)]
pub enum ListAuditTasksError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListAuditTasksError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListAuditTasksError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListAuditTasksError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListAuditTasksError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListAuditTasksError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListAuditTasksError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListAuditTasksError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListAuditTasksError {
    fn from(err: serde_json::error::Error) -> ListAuditTasksError {
        ListAuditTasksError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListAuditTasksError {
    fn from(err: CredentialsError) -> ListAuditTasksError {
        ListAuditTasksError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListAuditTasksError {
    fn from(err: HttpDispatchError) -> ListAuditTasksError {
        ListAuditTasksError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListAuditTasksError {
    fn from(err: io::Error) -> ListAuditTasksError {
        ListAuditTasksError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListAuditTasksError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuditTasksError {
    fn description(&self) -> &str {
        match *self {
            ListAuditTasksError::InternalFailure(ref cause) => cause,
            ListAuditTasksError::InvalidRequest(ref cause) => cause,
            ListAuditTasksError::Throttling(ref cause) => cause,
            ListAuditTasksError::Validation(ref cause) => cause,
            ListAuditTasksError::Credentials(ref err) => err.description(),
            ListAuditTasksError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListAuditTasksError::ParseError(ref cause) => cause,
            ListAuditTasksError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListAuthorizers
#[derive(Debug, PartialEq)]
pub enum ListAuthorizersError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListAuthorizersError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListAuthorizersError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListAuthorizersError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListAuthorizersError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListAuthorizersError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListAuthorizersError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListAuthorizersError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListAuthorizersError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListAuthorizersError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListAuthorizersError {
    fn from(err: serde_json::error::Error) -> ListAuthorizersError {
        ListAuthorizersError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListAuthorizersError {
    fn from(err: CredentialsError) -> ListAuthorizersError {
        ListAuthorizersError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListAuthorizersError {
    fn from(err: HttpDispatchError) -> ListAuthorizersError {
        ListAuthorizersError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListAuthorizersError {
    fn from(err: io::Error) -> ListAuthorizersError {
        ListAuthorizersError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListAuthorizersError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuthorizersError {
    fn description(&self) -> &str {
        match *self {
            ListAuthorizersError::InternalFailure(ref cause) => cause,
            ListAuthorizersError::InvalidRequest(ref cause) => cause,
            ListAuthorizersError::ServiceUnavailable(ref cause) => cause,
            ListAuthorizersError::Throttling(ref cause) => cause,
            ListAuthorizersError::Unauthorized(ref cause) => cause,
            ListAuthorizersError::Validation(ref cause) => cause,
            ListAuthorizersError::Credentials(ref err) => err.description(),
            ListAuthorizersError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListAuthorizersError::ParseError(ref cause) => cause,
            ListAuthorizersError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListCACertificates
#[derive(Debug, PartialEq)]
pub enum ListCACertificatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListCACertificatesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListCACertificatesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListCACertificatesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListCACertificatesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListCACertificatesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListCACertificatesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListCACertificatesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListCACertificatesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListCACertificatesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListCACertificatesError {
    fn from(err: serde_json::error::Error) -> ListCACertificatesError {
        ListCACertificatesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListCACertificatesError {
    fn from(err: CredentialsError) -> ListCACertificatesError {
        ListCACertificatesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListCACertificatesError {
    fn from(err: HttpDispatchError) -> ListCACertificatesError {
        ListCACertificatesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListCACertificatesError {
    fn from(err: io::Error) -> ListCACertificatesError {
        ListCACertificatesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListCACertificatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListCACertificatesError {
    fn description(&self) -> &str {
        match *self {
            ListCACertificatesError::InternalFailure(ref cause) => cause,
            ListCACertificatesError::InvalidRequest(ref cause) => cause,
            ListCACertificatesError::ServiceUnavailable(ref cause) => cause,
            ListCACertificatesError::Throttling(ref cause) => cause,
            ListCACertificatesError::Unauthorized(ref cause) => cause,
            ListCACertificatesError::Validation(ref cause) => cause,
            ListCACertificatesError::Credentials(ref err) => err.description(),
            ListCACertificatesError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListCACertificatesError::ParseError(ref cause) => cause,
            ListCACertificatesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListCertificates
#[derive(Debug, PartialEq)]
pub enum ListCertificatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListCertificatesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListCertificatesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListCertificatesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListCertificatesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListCertificatesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListCertificatesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListCertificatesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListCertificatesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListCertificatesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListCertificatesError {
    fn from(err: serde_json::error::Error) -> ListCertificatesError {
        ListCertificatesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListCertificatesError {
    fn from(err: CredentialsError) -> ListCertificatesError {
        ListCertificatesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListCertificatesError {
    fn from(err: HttpDispatchError) -> ListCertificatesError {
        ListCertificatesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListCertificatesError {
    fn from(err: io::Error) -> ListCertificatesError {
        ListCertificatesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListCertificatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListCertificatesError {
    fn description(&self) -> &str {
        match *self {
            ListCertificatesError::InternalFailure(ref cause) => cause,
            ListCertificatesError::InvalidRequest(ref cause) => cause,
            ListCertificatesError::ServiceUnavailable(ref cause) => cause,
            ListCertificatesError::Throttling(ref cause) => cause,
            ListCertificatesError::Unauthorized(ref cause) => cause,
            ListCertificatesError::Validation(ref cause) => cause,
            ListCertificatesError::Credentials(ref err) => err.description(),
            ListCertificatesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListCertificatesError::ParseError(ref cause) => cause,
            ListCertificatesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListCertificatesByCA
#[derive(Debug, PartialEq)]
pub enum ListCertificatesByCAError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListCertificatesByCAError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListCertificatesByCAError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListCertificatesByCAError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListCertificatesByCAError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListCertificatesByCAError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListCertificatesByCAError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListCertificatesByCAError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListCertificatesByCAError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListCertificatesByCAError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListCertificatesByCAError {
    fn from(err: serde_json::error::Error) -> ListCertificatesByCAError {
        ListCertificatesByCAError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListCertificatesByCAError {
    fn from(err: CredentialsError) -> ListCertificatesByCAError {
        ListCertificatesByCAError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListCertificatesByCAError {
    fn from(err: HttpDispatchError) -> ListCertificatesByCAError {
        ListCertificatesByCAError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListCertificatesByCAError {
    fn from(err: io::Error) -> ListCertificatesByCAError {
        ListCertificatesByCAError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListCertificatesByCAError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListCertificatesByCAError {
    fn description(&self) -> &str {
        match *self {
            ListCertificatesByCAError::InternalFailure(ref cause) => cause,
            ListCertificatesByCAError::InvalidRequest(ref cause) => cause,
            ListCertificatesByCAError::ServiceUnavailable(ref cause) => cause,
            ListCertificatesByCAError::Throttling(ref cause) => cause,
            ListCertificatesByCAError::Unauthorized(ref cause) => cause,
            ListCertificatesByCAError::Validation(ref cause) => cause,
            ListCertificatesByCAError::Credentials(ref err) => err.description(),
            ListCertificatesByCAError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListCertificatesByCAError::ParseError(ref cause) => cause,
            ListCertificatesByCAError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListIndices
#[derive(Debug, PartialEq)]
pub enum ListIndicesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListIndicesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListIndicesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListIndicesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListIndicesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListIndicesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListIndicesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListIndicesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListIndicesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListIndicesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListIndicesError {
    fn from(err: serde_json::error::Error) -> ListIndicesError {
        ListIndicesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListIndicesError {
    fn from(err: CredentialsError) -> ListIndicesError {
        ListIndicesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListIndicesError {
    fn from(err: HttpDispatchError) -> ListIndicesError {
        ListIndicesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListIndicesError {
    fn from(err: io::Error) -> ListIndicesError {
        ListIndicesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListIndicesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListIndicesError {
    fn description(&self) -> &str {
        match *self {
            ListIndicesError::InternalFailure(ref cause) => cause,
            ListIndicesError::InvalidRequest(ref cause) => cause,
            ListIndicesError::ServiceUnavailable(ref cause) => cause,
            ListIndicesError::Throttling(ref cause) => cause,
            ListIndicesError::Unauthorized(ref cause) => cause,
            ListIndicesError::Validation(ref cause) => cause,
            ListIndicesError::Credentials(ref err) => err.description(),
            ListIndicesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListIndicesError::ParseError(ref cause) => cause,
            ListIndicesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListJobExecutionsForJob
#[derive(Debug, PartialEq)]
pub enum ListJobExecutionsForJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListJobExecutionsForJobError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListJobExecutionsForJobError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return ListJobExecutionsForJobError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListJobExecutionsForJobError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return ListJobExecutionsForJobError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListJobExecutionsForJobError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListJobExecutionsForJobError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListJobExecutionsForJobError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListJobExecutionsForJobError {
    fn from(err: serde_json::error::Error) -> ListJobExecutionsForJobError {
        ListJobExecutionsForJobError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListJobExecutionsForJobError {
    fn from(err: CredentialsError) -> ListJobExecutionsForJobError {
        ListJobExecutionsForJobError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListJobExecutionsForJobError {
    fn from(err: HttpDispatchError) -> ListJobExecutionsForJobError {
        ListJobExecutionsForJobError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListJobExecutionsForJobError {
    fn from(err: io::Error) -> ListJobExecutionsForJobError {
        ListJobExecutionsForJobError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListJobExecutionsForJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListJobExecutionsForJobError {
    fn description(&self) -> &str {
        match *self {
            ListJobExecutionsForJobError::InvalidRequest(ref cause) => cause,
            ListJobExecutionsForJobError::ResourceNotFound(ref cause) => cause,
            ListJobExecutionsForJobError::ServiceUnavailable(ref cause) => cause,
            ListJobExecutionsForJobError::Throttling(ref cause) => cause,
            ListJobExecutionsForJobError::Validation(ref cause) => cause,
            ListJobExecutionsForJobError::Credentials(ref err) => err.description(),
            ListJobExecutionsForJobError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListJobExecutionsForJobError::ParseError(ref cause) => cause,
            ListJobExecutionsForJobError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListJobExecutionsForThing
#[derive(Debug, PartialEq)]
pub enum ListJobExecutionsForThingError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListJobExecutionsForThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListJobExecutionsForThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return ListJobExecutionsForThingError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return ListJobExecutionsForThingError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return ListJobExecutionsForThingError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListJobExecutionsForThingError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListJobExecutionsForThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListJobExecutionsForThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListJobExecutionsForThingError {
    fn from(err: serde_json::error::Error) -> ListJobExecutionsForThingError {
        ListJobExecutionsForThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListJobExecutionsForThingError {
    fn from(err: CredentialsError) -> ListJobExecutionsForThingError {
        ListJobExecutionsForThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListJobExecutionsForThingError {
    fn from(err: HttpDispatchError) -> ListJobExecutionsForThingError {
        ListJobExecutionsForThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListJobExecutionsForThingError {
    fn from(err: io::Error) -> ListJobExecutionsForThingError {
        ListJobExecutionsForThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListJobExecutionsForThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListJobExecutionsForThingError {
    fn description(&self) -> &str {
        match *self {
            ListJobExecutionsForThingError::InvalidRequest(ref cause) => cause,
            ListJobExecutionsForThingError::ResourceNotFound(ref cause) => cause,
            ListJobExecutionsForThingError::ServiceUnavailable(ref cause) => cause,
            ListJobExecutionsForThingError::Throttling(ref cause) => cause,
            ListJobExecutionsForThingError::Validation(ref cause) => cause,
            ListJobExecutionsForThingError::Credentials(ref err) => err.description(),
            ListJobExecutionsForThingError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListJobExecutionsForThingError::ParseError(ref cause) => cause,
            ListJobExecutionsForThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListJobs
#[derive(Debug, PartialEq)]
pub enum ListJobsError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListJobsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListJobsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InvalidRequestException" => {
                    return ListJobsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListJobsError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListJobsError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListJobsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListJobsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListJobsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListJobsError {
    fn from(err: serde_json::error::Error) -> ListJobsError {
        ListJobsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListJobsError {
    fn from(err: CredentialsError) -> ListJobsError {
        ListJobsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListJobsError {
    fn from(err: HttpDispatchError) -> ListJobsError {
        ListJobsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListJobsError {
    fn from(err: io::Error) -> ListJobsError {
        ListJobsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListJobsError {
    fn description(&self) -> &str {
        match *self {
            ListJobsError::InvalidRequest(ref cause) => cause,
            ListJobsError::ResourceNotFound(ref cause) => cause,
            ListJobsError::ServiceUnavailable(ref cause) => cause,
            ListJobsError::Throttling(ref cause) => cause,
            ListJobsError::Validation(ref cause) => cause,
            ListJobsError::Credentials(ref err) => err.description(),
            ListJobsError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListJobsError::ParseError(ref cause) => cause,
            ListJobsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListOTAUpdates
#[derive(Debug, PartialEq)]
pub enum ListOTAUpdatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListOTAUpdatesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListOTAUpdatesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListOTAUpdatesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListOTAUpdatesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListOTAUpdatesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListOTAUpdatesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListOTAUpdatesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListOTAUpdatesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListOTAUpdatesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListOTAUpdatesError {
    fn from(err: serde_json::error::Error) -> ListOTAUpdatesError {
        ListOTAUpdatesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListOTAUpdatesError {
    fn from(err: CredentialsError) -> ListOTAUpdatesError {
        ListOTAUpdatesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListOTAUpdatesError {
    fn from(err: HttpDispatchError) -> ListOTAUpdatesError {
        ListOTAUpdatesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListOTAUpdatesError {
    fn from(err: io::Error) -> ListOTAUpdatesError {
        ListOTAUpdatesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListOTAUpdatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListOTAUpdatesError {
    fn description(&self) -> &str {
        match *self {
            ListOTAUpdatesError::InternalFailure(ref cause) => cause,
            ListOTAUpdatesError::InvalidRequest(ref cause) => cause,
            ListOTAUpdatesError::ServiceUnavailable(ref cause) => cause,
            ListOTAUpdatesError::Throttling(ref cause) => cause,
            ListOTAUpdatesError::Unauthorized(ref cause) => cause,
            ListOTAUpdatesError::Validation(ref cause) => cause,
            ListOTAUpdatesError::Credentials(ref err) => err.description(),
            ListOTAUpdatesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListOTAUpdatesError::ParseError(ref cause) => cause,
            ListOTAUpdatesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListOutgoingCertificates
#[derive(Debug, PartialEq)]
pub enum ListOutgoingCertificatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListOutgoingCertificatesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListOutgoingCertificatesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListOutgoingCertificatesError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ListOutgoingCertificatesError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return ListOutgoingCertificatesError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListOutgoingCertificatesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListOutgoingCertificatesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListOutgoingCertificatesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListOutgoingCertificatesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListOutgoingCertificatesError {
    fn from(err: serde_json::error::Error) -> ListOutgoingCertificatesError {
        ListOutgoingCertificatesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListOutgoingCertificatesError {
    fn from(err: CredentialsError) -> ListOutgoingCertificatesError {
        ListOutgoingCertificatesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListOutgoingCertificatesError {
    fn from(err: HttpDispatchError) -> ListOutgoingCertificatesError {
        ListOutgoingCertificatesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListOutgoingCertificatesError {
    fn from(err: io::Error) -> ListOutgoingCertificatesError {
        ListOutgoingCertificatesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListOutgoingCertificatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListOutgoingCertificatesError {
    fn description(&self) -> &str {
        match *self {
            ListOutgoingCertificatesError::InternalFailure(ref cause) => cause,
            ListOutgoingCertificatesError::InvalidRequest(ref cause) => cause,
            ListOutgoingCertificatesError::ServiceUnavailable(ref cause) => cause,
            ListOutgoingCertificatesError::Throttling(ref cause) => cause,
            ListOutgoingCertificatesError::Unauthorized(ref cause) => cause,
            ListOutgoingCertificatesError::Validation(ref cause) => cause,
            ListOutgoingCertificatesError::Credentials(ref err) => err.description(),
            ListOutgoingCertificatesError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListOutgoingCertificatesError::ParseError(ref cause) => cause,
            ListOutgoingCertificatesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListPolicies
#[derive(Debug, PartialEq)]
pub enum ListPoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListPoliciesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListPoliciesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListPoliciesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListPoliciesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListPoliciesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListPoliciesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListPoliciesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListPoliciesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListPoliciesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListPoliciesError {
    fn from(err: serde_json::error::Error) -> ListPoliciesError {
        ListPoliciesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListPoliciesError {
    fn from(err: CredentialsError) -> ListPoliciesError {
        ListPoliciesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListPoliciesError {
    fn from(err: HttpDispatchError) -> ListPoliciesError {
        ListPoliciesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListPoliciesError {
    fn from(err: io::Error) -> ListPoliciesError {
        ListPoliciesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListPoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPoliciesError {
    fn description(&self) -> &str {
        match *self {
            ListPoliciesError::InternalFailure(ref cause) => cause,
            ListPoliciesError::InvalidRequest(ref cause) => cause,
            ListPoliciesError::ServiceUnavailable(ref cause) => cause,
            ListPoliciesError::Throttling(ref cause) => cause,
            ListPoliciesError::Unauthorized(ref cause) => cause,
            ListPoliciesError::Validation(ref cause) => cause,
            ListPoliciesError::Credentials(ref err) => err.description(),
            ListPoliciesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListPoliciesError::ParseError(ref cause) => cause,
            ListPoliciesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListPolicyPrincipals
#[derive(Debug, PartialEq)]
pub enum ListPolicyPrincipalsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListPolicyPrincipalsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListPolicyPrincipalsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListPolicyPrincipalsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListPolicyPrincipalsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListPolicyPrincipalsError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListPolicyPrincipalsError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListPolicyPrincipalsError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListPolicyPrincipalsError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListPolicyPrincipalsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListPolicyPrincipalsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListPolicyPrincipalsError {
    fn from(err: serde_json::error::Error) -> ListPolicyPrincipalsError {
        ListPolicyPrincipalsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListPolicyPrincipalsError {
    fn from(err: CredentialsError) -> ListPolicyPrincipalsError {
        ListPolicyPrincipalsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListPolicyPrincipalsError {
    fn from(err: HttpDispatchError) -> ListPolicyPrincipalsError {
        ListPolicyPrincipalsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListPolicyPrincipalsError {
    fn from(err: io::Error) -> ListPolicyPrincipalsError {
        ListPolicyPrincipalsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListPolicyPrincipalsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPolicyPrincipalsError {
    fn description(&self) -> &str {
        match *self {
            ListPolicyPrincipalsError::InternalFailure(ref cause) => cause,
            ListPolicyPrincipalsError::InvalidRequest(ref cause) => cause,
            ListPolicyPrincipalsError::ResourceNotFound(ref cause) => cause,
            ListPolicyPrincipalsError::ServiceUnavailable(ref cause) => cause,
            ListPolicyPrincipalsError::Throttling(ref cause) => cause,
            ListPolicyPrincipalsError::Unauthorized(ref cause) => cause,
            ListPolicyPrincipalsError::Validation(ref cause) => cause,
            ListPolicyPrincipalsError::Credentials(ref err) => err.description(),
            ListPolicyPrincipalsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListPolicyPrincipalsError::ParseError(ref cause) => cause,
            ListPolicyPrincipalsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListPolicyVersions
#[derive(Debug, PartialEq)]
pub enum ListPolicyVersionsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListPolicyVersionsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListPolicyVersionsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListPolicyVersionsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListPolicyVersionsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListPolicyVersionsError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListPolicyVersionsError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListPolicyVersionsError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListPolicyVersionsError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListPolicyVersionsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListPolicyVersionsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListPolicyVersionsError {
    fn from(err: serde_json::error::Error) -> ListPolicyVersionsError {
        ListPolicyVersionsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListPolicyVersionsError {
    fn from(err: CredentialsError) -> ListPolicyVersionsError {
        ListPolicyVersionsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListPolicyVersionsError {
    fn from(err: HttpDispatchError) -> ListPolicyVersionsError {
        ListPolicyVersionsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListPolicyVersionsError {
    fn from(err: io::Error) -> ListPolicyVersionsError {
        ListPolicyVersionsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListPolicyVersionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPolicyVersionsError {
    fn description(&self) -> &str {
        match *self {
            ListPolicyVersionsError::InternalFailure(ref cause) => cause,
            ListPolicyVersionsError::InvalidRequest(ref cause) => cause,
            ListPolicyVersionsError::ResourceNotFound(ref cause) => cause,
            ListPolicyVersionsError::ServiceUnavailable(ref cause) => cause,
            ListPolicyVersionsError::Throttling(ref cause) => cause,
            ListPolicyVersionsError::Unauthorized(ref cause) => cause,
            ListPolicyVersionsError::Validation(ref cause) => cause,
            ListPolicyVersionsError::Credentials(ref err) => err.description(),
            ListPolicyVersionsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListPolicyVersionsError::ParseError(ref cause) => cause,
            ListPolicyVersionsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListPrincipalPolicies
#[derive(Debug, PartialEq)]
pub enum ListPrincipalPoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListPrincipalPoliciesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListPrincipalPoliciesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListPrincipalPoliciesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListPrincipalPoliciesError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListPrincipalPoliciesError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListPrincipalPoliciesError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListPrincipalPoliciesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListPrincipalPoliciesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListPrincipalPoliciesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListPrincipalPoliciesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListPrincipalPoliciesError {
    fn from(err: serde_json::error::Error) -> ListPrincipalPoliciesError {
        ListPrincipalPoliciesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListPrincipalPoliciesError {
    fn from(err: CredentialsError) -> ListPrincipalPoliciesError {
        ListPrincipalPoliciesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListPrincipalPoliciesError {
    fn from(err: HttpDispatchError) -> ListPrincipalPoliciesError {
        ListPrincipalPoliciesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListPrincipalPoliciesError {
    fn from(err: io::Error) -> ListPrincipalPoliciesError {
        ListPrincipalPoliciesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListPrincipalPoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPrincipalPoliciesError {
    fn description(&self) -> &str {
        match *self {
            ListPrincipalPoliciesError::InternalFailure(ref cause) => cause,
            ListPrincipalPoliciesError::InvalidRequest(ref cause) => cause,
            ListPrincipalPoliciesError::ResourceNotFound(ref cause) => cause,
            ListPrincipalPoliciesError::ServiceUnavailable(ref cause) => cause,
            ListPrincipalPoliciesError::Throttling(ref cause) => cause,
            ListPrincipalPoliciesError::Unauthorized(ref cause) => cause,
            ListPrincipalPoliciesError::Validation(ref cause) => cause,
            ListPrincipalPoliciesError::Credentials(ref err) => err.description(),
            ListPrincipalPoliciesError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListPrincipalPoliciesError::ParseError(ref cause) => cause,
            ListPrincipalPoliciesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListPrincipalThings
#[derive(Debug, PartialEq)]
pub enum ListPrincipalThingsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListPrincipalThingsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListPrincipalThingsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListPrincipalThingsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListPrincipalThingsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListPrincipalThingsError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListPrincipalThingsError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListPrincipalThingsError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListPrincipalThingsError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListPrincipalThingsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListPrincipalThingsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListPrincipalThingsError {
    fn from(err: serde_json::error::Error) -> ListPrincipalThingsError {
        ListPrincipalThingsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListPrincipalThingsError {
    fn from(err: CredentialsError) -> ListPrincipalThingsError {
        ListPrincipalThingsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListPrincipalThingsError {
    fn from(err: HttpDispatchError) -> ListPrincipalThingsError {
        ListPrincipalThingsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListPrincipalThingsError {
    fn from(err: io::Error) -> ListPrincipalThingsError {
        ListPrincipalThingsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListPrincipalThingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPrincipalThingsError {
    fn description(&self) -> &str {
        match *self {
            ListPrincipalThingsError::InternalFailure(ref cause) => cause,
            ListPrincipalThingsError::InvalidRequest(ref cause) => cause,
            ListPrincipalThingsError::ResourceNotFound(ref cause) => cause,
            ListPrincipalThingsError::ServiceUnavailable(ref cause) => cause,
            ListPrincipalThingsError::Throttling(ref cause) => cause,
            ListPrincipalThingsError::Unauthorized(ref cause) => cause,
            ListPrincipalThingsError::Validation(ref cause) => cause,
            ListPrincipalThingsError::Credentials(ref err) => err.description(),
            ListPrincipalThingsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListPrincipalThingsError::ParseError(ref cause) => cause,
            ListPrincipalThingsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListRoleAliases
#[derive(Debug, PartialEq)]
pub enum ListRoleAliasesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListRoleAliasesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListRoleAliasesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListRoleAliasesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListRoleAliasesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListRoleAliasesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListRoleAliasesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListRoleAliasesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListRoleAliasesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListRoleAliasesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListRoleAliasesError {
    fn from(err: serde_json::error::Error) -> ListRoleAliasesError {
        ListRoleAliasesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListRoleAliasesError {
    fn from(err: CredentialsError) -> ListRoleAliasesError {
        ListRoleAliasesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListRoleAliasesError {
    fn from(err: HttpDispatchError) -> ListRoleAliasesError {
        ListRoleAliasesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListRoleAliasesError {
    fn from(err: io::Error) -> ListRoleAliasesError {
        ListRoleAliasesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListRoleAliasesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListRoleAliasesError {
    fn description(&self) -> &str {
        match *self {
            ListRoleAliasesError::InternalFailure(ref cause) => cause,
            ListRoleAliasesError::InvalidRequest(ref cause) => cause,
            ListRoleAliasesError::ServiceUnavailable(ref cause) => cause,
            ListRoleAliasesError::Throttling(ref cause) => cause,
            ListRoleAliasesError::Unauthorized(ref cause) => cause,
            ListRoleAliasesError::Validation(ref cause) => cause,
            ListRoleAliasesError::Credentials(ref err) => err.description(),
            ListRoleAliasesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListRoleAliasesError::ParseError(ref cause) => cause,
            ListRoleAliasesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListScheduledAudits
#[derive(Debug, PartialEq)]
pub enum ListScheduledAuditsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListScheduledAuditsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListScheduledAuditsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListScheduledAuditsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListScheduledAuditsError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListScheduledAuditsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListScheduledAuditsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListScheduledAuditsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListScheduledAuditsError {
    fn from(err: serde_json::error::Error) -> ListScheduledAuditsError {
        ListScheduledAuditsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListScheduledAuditsError {
    fn from(err: CredentialsError) -> ListScheduledAuditsError {
        ListScheduledAuditsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListScheduledAuditsError {
    fn from(err: HttpDispatchError) -> ListScheduledAuditsError {
        ListScheduledAuditsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListScheduledAuditsError {
    fn from(err: io::Error) -> ListScheduledAuditsError {
        ListScheduledAuditsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListScheduledAuditsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListScheduledAuditsError {
    fn description(&self) -> &str {
        match *self {
            ListScheduledAuditsError::InternalFailure(ref cause) => cause,
            ListScheduledAuditsError::InvalidRequest(ref cause) => cause,
            ListScheduledAuditsError::Throttling(ref cause) => cause,
            ListScheduledAuditsError::Validation(ref cause) => cause,
            ListScheduledAuditsError::Credentials(ref err) => err.description(),
            ListScheduledAuditsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListScheduledAuditsError::ParseError(ref cause) => cause,
            ListScheduledAuditsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListSecurityProfiles
#[derive(Debug, PartialEq)]
pub enum ListSecurityProfilesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListSecurityProfilesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListSecurityProfilesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListSecurityProfilesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListSecurityProfilesError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListSecurityProfilesError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListSecurityProfilesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListSecurityProfilesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListSecurityProfilesError {
    fn from(err: serde_json::error::Error) -> ListSecurityProfilesError {
        ListSecurityProfilesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListSecurityProfilesError {
    fn from(err: CredentialsError) -> ListSecurityProfilesError {
        ListSecurityProfilesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListSecurityProfilesError {
    fn from(err: HttpDispatchError) -> ListSecurityProfilesError {
        ListSecurityProfilesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListSecurityProfilesError {
    fn from(err: io::Error) -> ListSecurityProfilesError {
        ListSecurityProfilesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListSecurityProfilesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListSecurityProfilesError {
    fn description(&self) -> &str {
        match *self {
            ListSecurityProfilesError::InternalFailure(ref cause) => cause,
            ListSecurityProfilesError::InvalidRequest(ref cause) => cause,
            ListSecurityProfilesError::Throttling(ref cause) => cause,
            ListSecurityProfilesError::Validation(ref cause) => cause,
            ListSecurityProfilesError::Credentials(ref err) => err.description(),
            ListSecurityProfilesError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListSecurityProfilesError::ParseError(ref cause) => cause,
            ListSecurityProfilesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListSecurityProfilesForTarget
#[derive(Debug, PartialEq)]
pub enum ListSecurityProfilesForTargetError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListSecurityProfilesForTargetError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListSecurityProfilesForTargetError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListSecurityProfilesForTargetError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ListSecurityProfilesForTargetError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return ListSecurityProfilesForTargetError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListSecurityProfilesForTargetError::Throttling(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ListSecurityProfilesForTargetError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListSecurityProfilesForTargetError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListSecurityProfilesForTargetError {
    fn from(err: serde_json::error::Error) -> ListSecurityProfilesForTargetError {
        ListSecurityProfilesForTargetError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListSecurityProfilesForTargetError {
    fn from(err: CredentialsError) -> ListSecurityProfilesForTargetError {
        ListSecurityProfilesForTargetError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListSecurityProfilesForTargetError {
    fn from(err: HttpDispatchError) -> ListSecurityProfilesForTargetError {
        ListSecurityProfilesForTargetError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListSecurityProfilesForTargetError {
    fn from(err: io::Error) -> ListSecurityProfilesForTargetError {
        ListSecurityProfilesForTargetError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListSecurityProfilesForTargetError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListSecurityProfilesForTargetError {
    fn description(&self) -> &str {
        match *self {
            ListSecurityProfilesForTargetError::InternalFailure(ref cause) => cause,
            ListSecurityProfilesForTargetError::InvalidRequest(ref cause) => cause,
            ListSecurityProfilesForTargetError::ResourceNotFound(ref cause) => cause,
            ListSecurityProfilesForTargetError::Throttling(ref cause) => cause,
            ListSecurityProfilesForTargetError::Validation(ref cause) => cause,
            ListSecurityProfilesForTargetError::Credentials(ref err) => err.description(),
            ListSecurityProfilesForTargetError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListSecurityProfilesForTargetError::ParseError(ref cause) => cause,
            ListSecurityProfilesForTargetError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListStreams
#[derive(Debug, PartialEq)]
pub enum ListStreamsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListStreamsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListStreamsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListStreamsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListStreamsError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListStreamsError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListStreamsError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListStreamsError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListStreamsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListStreamsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListStreamsError {
    fn from(err: serde_json::error::Error) -> ListStreamsError {
        ListStreamsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListStreamsError {
    fn from(err: CredentialsError) -> ListStreamsError {
        ListStreamsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListStreamsError {
    fn from(err: HttpDispatchError) -> ListStreamsError {
        ListStreamsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListStreamsError {
    fn from(err: io::Error) -> ListStreamsError {
        ListStreamsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListStreamsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListStreamsError {
    fn description(&self) -> &str {
        match *self {
            ListStreamsError::InternalFailure(ref cause) => cause,
            ListStreamsError::InvalidRequest(ref cause) => cause,
            ListStreamsError::ServiceUnavailable(ref cause) => cause,
            ListStreamsError::Throttling(ref cause) => cause,
            ListStreamsError::Unauthorized(ref cause) => cause,
            ListStreamsError::Validation(ref cause) => cause,
            ListStreamsError::Credentials(ref err) => err.description(),
            ListStreamsError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListStreamsError::ParseError(ref cause) => cause,
            ListStreamsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListTargetsForPolicy
#[derive(Debug, PartialEq)]
pub enum ListTargetsForPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListTargetsForPolicyError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListTargetsForPolicyError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListTargetsForPolicyError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListTargetsForPolicyError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return ListTargetsForPolicyError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListTargetsForPolicyError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListTargetsForPolicyError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListTargetsForPolicyError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListTargetsForPolicyError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListTargetsForPolicyError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListTargetsForPolicyError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListTargetsForPolicyError {
    fn from(err: serde_json::error::Error) -> ListTargetsForPolicyError {
        ListTargetsForPolicyError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListTargetsForPolicyError {
    fn from(err: CredentialsError) -> ListTargetsForPolicyError {
        ListTargetsForPolicyError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListTargetsForPolicyError {
    fn from(err: HttpDispatchError) -> ListTargetsForPolicyError {
        ListTargetsForPolicyError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListTargetsForPolicyError {
    fn from(err: io::Error) -> ListTargetsForPolicyError {
        ListTargetsForPolicyError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListTargetsForPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTargetsForPolicyError {
    fn description(&self) -> &str {
        match *self {
            ListTargetsForPolicyError::InternalFailure(ref cause) => cause,
            ListTargetsForPolicyError::InvalidRequest(ref cause) => cause,
            ListTargetsForPolicyError::LimitExceeded(ref cause) => cause,
            ListTargetsForPolicyError::ResourceNotFound(ref cause) => cause,
            ListTargetsForPolicyError::ServiceUnavailable(ref cause) => cause,
            ListTargetsForPolicyError::Throttling(ref cause) => cause,
            ListTargetsForPolicyError::Unauthorized(ref cause) => cause,
            ListTargetsForPolicyError::Validation(ref cause) => cause,
            ListTargetsForPolicyError::Credentials(ref err) => err.description(),
            ListTargetsForPolicyError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListTargetsForPolicyError::ParseError(ref cause) => cause,
            ListTargetsForPolicyError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListTargetsForSecurityProfile
#[derive(Debug, PartialEq)]
pub enum ListTargetsForSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListTargetsForSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListTargetsForSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListTargetsForSecurityProfileError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ListTargetsForSecurityProfileError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return ListTargetsForSecurityProfileError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListTargetsForSecurityProfileError::Throttling(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ListTargetsForSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListTargetsForSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListTargetsForSecurityProfileError {
    fn from(err: serde_json::error::Error) -> ListTargetsForSecurityProfileError {
        ListTargetsForSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListTargetsForSecurityProfileError {
    fn from(err: CredentialsError) -> ListTargetsForSecurityProfileError {
        ListTargetsForSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListTargetsForSecurityProfileError {
    fn from(err: HttpDispatchError) -> ListTargetsForSecurityProfileError {
        ListTargetsForSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListTargetsForSecurityProfileError {
    fn from(err: io::Error) -> ListTargetsForSecurityProfileError {
        ListTargetsForSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListTargetsForSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTargetsForSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            ListTargetsForSecurityProfileError::InternalFailure(ref cause) => cause,
            ListTargetsForSecurityProfileError::InvalidRequest(ref cause) => cause,
            ListTargetsForSecurityProfileError::ResourceNotFound(ref cause) => cause,
            ListTargetsForSecurityProfileError::Throttling(ref cause) => cause,
            ListTargetsForSecurityProfileError::Validation(ref cause) => cause,
            ListTargetsForSecurityProfileError::Credentials(ref err) => err.description(),
            ListTargetsForSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListTargetsForSecurityProfileError::ParseError(ref cause) => cause,
            ListTargetsForSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingGroups
#[derive(Debug, PartialEq)]
pub enum ListThingGroupsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingGroupsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingGroupsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingGroupsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListThingGroupsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListThingGroupsError::ResourceNotFound(String::from(error_message))
                }
                "ValidationException" => {
                    return ListThingGroupsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingGroupsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingGroupsError {
    fn from(err: serde_json::error::Error) -> ListThingGroupsError {
        ListThingGroupsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingGroupsError {
    fn from(err: CredentialsError) -> ListThingGroupsError {
        ListThingGroupsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingGroupsError {
    fn from(err: HttpDispatchError) -> ListThingGroupsError {
        ListThingGroupsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingGroupsError {
    fn from(err: io::Error) -> ListThingGroupsError {
        ListThingGroupsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingGroupsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingGroupsError {
    fn description(&self) -> &str {
        match *self {
            ListThingGroupsError::InternalFailure(ref cause) => cause,
            ListThingGroupsError::InvalidRequest(ref cause) => cause,
            ListThingGroupsError::ResourceNotFound(ref cause) => cause,
            ListThingGroupsError::Validation(ref cause) => cause,
            ListThingGroupsError::Credentials(ref err) => err.description(),
            ListThingGroupsError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListThingGroupsError::ParseError(ref cause) => cause,
            ListThingGroupsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingGroupsForThing
#[derive(Debug, PartialEq)]
pub enum ListThingGroupsForThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingGroupsForThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingGroupsForThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingGroupsForThingError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ListThingGroupsForThingError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListThingGroupsForThingError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ListThingGroupsForThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingGroupsForThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingGroupsForThingError {
    fn from(err: serde_json::error::Error) -> ListThingGroupsForThingError {
        ListThingGroupsForThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingGroupsForThingError {
    fn from(err: CredentialsError) -> ListThingGroupsForThingError {
        ListThingGroupsForThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingGroupsForThingError {
    fn from(err: HttpDispatchError) -> ListThingGroupsForThingError {
        ListThingGroupsForThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingGroupsForThingError {
    fn from(err: io::Error) -> ListThingGroupsForThingError {
        ListThingGroupsForThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingGroupsForThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingGroupsForThingError {
    fn description(&self) -> &str {
        match *self {
            ListThingGroupsForThingError::InternalFailure(ref cause) => cause,
            ListThingGroupsForThingError::InvalidRequest(ref cause) => cause,
            ListThingGroupsForThingError::ResourceNotFound(ref cause) => cause,
            ListThingGroupsForThingError::Validation(ref cause) => cause,
            ListThingGroupsForThingError::Credentials(ref err) => err.description(),
            ListThingGroupsForThingError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListThingGroupsForThingError::ParseError(ref cause) => cause,
            ListThingGroupsForThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingPrincipals
#[derive(Debug, PartialEq)]
pub enum ListThingPrincipalsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingPrincipalsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingPrincipalsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingPrincipalsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListThingPrincipalsError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListThingPrincipalsError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListThingPrincipalsError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListThingPrincipalsError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListThingPrincipalsError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListThingPrincipalsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingPrincipalsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingPrincipalsError {
    fn from(err: serde_json::error::Error) -> ListThingPrincipalsError {
        ListThingPrincipalsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingPrincipalsError {
    fn from(err: CredentialsError) -> ListThingPrincipalsError {
        ListThingPrincipalsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingPrincipalsError {
    fn from(err: HttpDispatchError) -> ListThingPrincipalsError {
        ListThingPrincipalsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingPrincipalsError {
    fn from(err: io::Error) -> ListThingPrincipalsError {
        ListThingPrincipalsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingPrincipalsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingPrincipalsError {
    fn description(&self) -> &str {
        match *self {
            ListThingPrincipalsError::InternalFailure(ref cause) => cause,
            ListThingPrincipalsError::InvalidRequest(ref cause) => cause,
            ListThingPrincipalsError::ResourceNotFound(ref cause) => cause,
            ListThingPrincipalsError::ServiceUnavailable(ref cause) => cause,
            ListThingPrincipalsError::Throttling(ref cause) => cause,
            ListThingPrincipalsError::Unauthorized(ref cause) => cause,
            ListThingPrincipalsError::Validation(ref cause) => cause,
            ListThingPrincipalsError::Credentials(ref err) => err.description(),
            ListThingPrincipalsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListThingPrincipalsError::ParseError(ref cause) => cause,
            ListThingPrincipalsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingRegistrationTaskReports
#[derive(Debug, PartialEq)]
pub enum ListThingRegistrationTaskReportsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingRegistrationTaskReportsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingRegistrationTaskReportsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingRegistrationTaskReportsError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ListThingRegistrationTaskReportsError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListThingRegistrationTaskReportsError::Throttling(String::from(
                        error_message,
                    ))
                }
                "UnauthorizedException" => {
                    return ListThingRegistrationTaskReportsError::Unauthorized(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ListThingRegistrationTaskReportsError::Validation(
                        error_message.to_string(),
                    )
                }
                _ => {}
            }
        }
        return ListThingRegistrationTaskReportsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingRegistrationTaskReportsError {
    fn from(err: serde_json::error::Error) -> ListThingRegistrationTaskReportsError {
        ListThingRegistrationTaskReportsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingRegistrationTaskReportsError {
    fn from(err: CredentialsError) -> ListThingRegistrationTaskReportsError {
        ListThingRegistrationTaskReportsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingRegistrationTaskReportsError {
    fn from(err: HttpDispatchError) -> ListThingRegistrationTaskReportsError {
        ListThingRegistrationTaskReportsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingRegistrationTaskReportsError {
    fn from(err: io::Error) -> ListThingRegistrationTaskReportsError {
        ListThingRegistrationTaskReportsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingRegistrationTaskReportsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingRegistrationTaskReportsError {
    fn description(&self) -> &str {
        match *self {
            ListThingRegistrationTaskReportsError::InternalFailure(ref cause) => cause,
            ListThingRegistrationTaskReportsError::InvalidRequest(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Throttling(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Unauthorized(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Validation(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Credentials(ref err) => err.description(),
            ListThingRegistrationTaskReportsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListThingRegistrationTaskReportsError::ParseError(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingRegistrationTasks
#[derive(Debug, PartialEq)]
pub enum ListThingRegistrationTasksError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingRegistrationTasksError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingRegistrationTasksError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingRegistrationTasksError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ListThingRegistrationTasksError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ListThingRegistrationTasksError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListThingRegistrationTasksError::Unauthorized(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ListThingRegistrationTasksError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingRegistrationTasksError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingRegistrationTasksError {
    fn from(err: serde_json::error::Error) -> ListThingRegistrationTasksError {
        ListThingRegistrationTasksError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingRegistrationTasksError {
    fn from(err: CredentialsError) -> ListThingRegistrationTasksError {
        ListThingRegistrationTasksError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingRegistrationTasksError {
    fn from(err: HttpDispatchError) -> ListThingRegistrationTasksError {
        ListThingRegistrationTasksError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingRegistrationTasksError {
    fn from(err: io::Error) -> ListThingRegistrationTasksError {
        ListThingRegistrationTasksError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingRegistrationTasksError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingRegistrationTasksError {
    fn description(&self) -> &str {
        match *self {
            ListThingRegistrationTasksError::InternalFailure(ref cause) => cause,
            ListThingRegistrationTasksError::InvalidRequest(ref cause) => cause,
            ListThingRegistrationTasksError::Throttling(ref cause) => cause,
            ListThingRegistrationTasksError::Unauthorized(ref cause) => cause,
            ListThingRegistrationTasksError::Validation(ref cause) => cause,
            ListThingRegistrationTasksError::Credentials(ref err) => err.description(),
            ListThingRegistrationTasksError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListThingRegistrationTasksError::ParseError(ref cause) => cause,
            ListThingRegistrationTasksError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingTypes
#[derive(Debug, PartialEq)]
pub enum ListThingTypesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingTypesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingTypesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingTypesError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListThingTypesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListThingTypesError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListThingTypesError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListThingTypesError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListThingTypesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingTypesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingTypesError {
    fn from(err: serde_json::error::Error) -> ListThingTypesError {
        ListThingTypesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingTypesError {
    fn from(err: CredentialsError) -> ListThingTypesError {
        ListThingTypesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingTypesError {
    fn from(err: HttpDispatchError) -> ListThingTypesError {
        ListThingTypesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingTypesError {
    fn from(err: io::Error) -> ListThingTypesError {
        ListThingTypesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingTypesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingTypesError {
    fn description(&self) -> &str {
        match *self {
            ListThingTypesError::InternalFailure(ref cause) => cause,
            ListThingTypesError::InvalidRequest(ref cause) => cause,
            ListThingTypesError::ServiceUnavailable(ref cause) => cause,
            ListThingTypesError::Throttling(ref cause) => cause,
            ListThingTypesError::Unauthorized(ref cause) => cause,
            ListThingTypesError::Validation(ref cause) => cause,
            ListThingTypesError::Credentials(ref err) => err.description(),
            ListThingTypesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListThingTypesError::ParseError(ref cause) => cause,
            ListThingTypesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThings
#[derive(Debug, PartialEq)]
pub enum ListThingsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListThingsError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListThingsError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListThingsError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ListThingsError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ListThingsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingsError {
    fn from(err: serde_json::error::Error) -> ListThingsError {
        ListThingsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingsError {
    fn from(err: CredentialsError) -> ListThingsError {
        ListThingsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingsError {
    fn from(err: HttpDispatchError) -> ListThingsError {
        ListThingsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingsError {
    fn from(err: io::Error) -> ListThingsError {
        ListThingsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingsError {
    fn description(&self) -> &str {
        match *self {
            ListThingsError::InternalFailure(ref cause) => cause,
            ListThingsError::InvalidRequest(ref cause) => cause,
            ListThingsError::ServiceUnavailable(ref cause) => cause,
            ListThingsError::Throttling(ref cause) => cause,
            ListThingsError::Unauthorized(ref cause) => cause,
            ListThingsError::Validation(ref cause) => cause,
            ListThingsError::Credentials(ref err) => err.description(),
            ListThingsError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListThingsError::ParseError(ref cause) => cause,
            ListThingsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListThingsInThingGroup
#[derive(Debug, PartialEq)]
pub enum ListThingsInThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListThingsInThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListThingsInThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListThingsInThingGroupError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListThingsInThingGroupError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return ListThingsInThingGroupError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ListThingsInThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListThingsInThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListThingsInThingGroupError {
    fn from(err: serde_json::error::Error) -> ListThingsInThingGroupError {
        ListThingsInThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListThingsInThingGroupError {
    fn from(err: CredentialsError) -> ListThingsInThingGroupError {
        ListThingsInThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListThingsInThingGroupError {
    fn from(err: HttpDispatchError) -> ListThingsInThingGroupError {
        ListThingsInThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListThingsInThingGroupError {
    fn from(err: io::Error) -> ListThingsInThingGroupError {
        ListThingsInThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListThingsInThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingsInThingGroupError {
    fn description(&self) -> &str {
        match *self {
            ListThingsInThingGroupError::InternalFailure(ref cause) => cause,
            ListThingsInThingGroupError::InvalidRequest(ref cause) => cause,
            ListThingsInThingGroupError::ResourceNotFound(ref cause) => cause,
            ListThingsInThingGroupError::Validation(ref cause) => cause,
            ListThingsInThingGroupError::Credentials(ref err) => err.description(),
            ListThingsInThingGroupError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListThingsInThingGroupError::ParseError(ref cause) => cause,
            ListThingsInThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListTopicRules
#[derive(Debug, PartialEq)]
pub enum ListTopicRulesError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListTopicRulesError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListTopicRulesError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return ListTopicRulesError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListTopicRulesError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListTopicRulesError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return ListTopicRulesError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListTopicRulesError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListTopicRulesError {
    fn from(err: serde_json::error::Error) -> ListTopicRulesError {
        ListTopicRulesError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListTopicRulesError {
    fn from(err: CredentialsError) -> ListTopicRulesError {
        ListTopicRulesError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListTopicRulesError {
    fn from(err: HttpDispatchError) -> ListTopicRulesError {
        ListTopicRulesError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListTopicRulesError {
    fn from(err: io::Error) -> ListTopicRulesError {
        ListTopicRulesError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListTopicRulesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTopicRulesError {
    fn description(&self) -> &str {
        match *self {
            ListTopicRulesError::Internal(ref cause) => cause,
            ListTopicRulesError::InvalidRequest(ref cause) => cause,
            ListTopicRulesError::ServiceUnavailable(ref cause) => cause,
            ListTopicRulesError::Validation(ref cause) => cause,
            ListTopicRulesError::Credentials(ref err) => err.description(),
            ListTopicRulesError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ListTopicRulesError::ParseError(ref cause) => cause,
            ListTopicRulesError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListV2LoggingLevels
#[derive(Debug, PartialEq)]
pub enum ListV2LoggingLevelsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource is not configured.</p>
    NotConfigured(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListV2LoggingLevelsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListV2LoggingLevelsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return ListV2LoggingLevelsError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListV2LoggingLevelsError::InvalidRequest(String::from(error_message))
                }
                "NotConfiguredException" => {
                    return ListV2LoggingLevelsError::NotConfigured(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ListV2LoggingLevelsError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return ListV2LoggingLevelsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListV2LoggingLevelsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListV2LoggingLevelsError {
    fn from(err: serde_json::error::Error) -> ListV2LoggingLevelsError {
        ListV2LoggingLevelsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListV2LoggingLevelsError {
    fn from(err: CredentialsError) -> ListV2LoggingLevelsError {
        ListV2LoggingLevelsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListV2LoggingLevelsError {
    fn from(err: HttpDispatchError) -> ListV2LoggingLevelsError {
        ListV2LoggingLevelsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListV2LoggingLevelsError {
    fn from(err: io::Error) -> ListV2LoggingLevelsError {
        ListV2LoggingLevelsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListV2LoggingLevelsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListV2LoggingLevelsError {
    fn description(&self) -> &str {
        match *self {
            ListV2LoggingLevelsError::Internal(ref cause) => cause,
            ListV2LoggingLevelsError::InvalidRequest(ref cause) => cause,
            ListV2LoggingLevelsError::NotConfigured(ref cause) => cause,
            ListV2LoggingLevelsError::ServiceUnavailable(ref cause) => cause,
            ListV2LoggingLevelsError::Validation(ref cause) => cause,
            ListV2LoggingLevelsError::Credentials(ref err) => err.description(),
            ListV2LoggingLevelsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListV2LoggingLevelsError::ParseError(ref cause) => cause,
            ListV2LoggingLevelsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ListViolationEvents
#[derive(Debug, PartialEq)]
pub enum ListViolationEventsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ListViolationEventsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ListViolationEventsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ListViolationEventsError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ListViolationEventsError::InvalidRequest(String::from(error_message))
                }
                "ThrottlingException" => {
                    return ListViolationEventsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return ListViolationEventsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ListViolationEventsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ListViolationEventsError {
    fn from(err: serde_json::error::Error) -> ListViolationEventsError {
        ListViolationEventsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ListViolationEventsError {
    fn from(err: CredentialsError) -> ListViolationEventsError {
        ListViolationEventsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ListViolationEventsError {
    fn from(err: HttpDispatchError) -> ListViolationEventsError {
        ListViolationEventsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ListViolationEventsError {
    fn from(err: io::Error) -> ListViolationEventsError {
        ListViolationEventsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ListViolationEventsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListViolationEventsError {
    fn description(&self) -> &str {
        match *self {
            ListViolationEventsError::InternalFailure(ref cause) => cause,
            ListViolationEventsError::InvalidRequest(ref cause) => cause,
            ListViolationEventsError::Throttling(ref cause) => cause,
            ListViolationEventsError::Validation(ref cause) => cause,
            ListViolationEventsError::Credentials(ref err) => err.description(),
            ListViolationEventsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ListViolationEventsError::ParseError(ref cause) => cause,
            ListViolationEventsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by RegisterCACertificate
#[derive(Debug, PartialEq)]
pub enum RegisterCACertificateError {
    /// <p>The certificate is invalid.</p>
    CertificateValidation(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The registration code is invalid.</p>
    RegistrationCodeValidation(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl RegisterCACertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> RegisterCACertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "CertificateValidationException" => {
                    return RegisterCACertificateError::CertificateValidation(String::from(
                        error_message,
                    ))
                }
                "InternalFailureException" => {
                    return RegisterCACertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return RegisterCACertificateError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return RegisterCACertificateError::LimitExceeded(String::from(error_message))
                }
                "RegistrationCodeValidationException" => {
                    return RegisterCACertificateError::RegistrationCodeValidation(String::from(
                        error_message,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RegisterCACertificateError::ResourceAlreadyExists(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RegisterCACertificateError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return RegisterCACertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return RegisterCACertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return RegisterCACertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return RegisterCACertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for RegisterCACertificateError {
    fn from(err: serde_json::error::Error) -> RegisterCACertificateError {
        RegisterCACertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for RegisterCACertificateError {
    fn from(err: CredentialsError) -> RegisterCACertificateError {
        RegisterCACertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for RegisterCACertificateError {
    fn from(err: HttpDispatchError) -> RegisterCACertificateError {
        RegisterCACertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for RegisterCACertificateError {
    fn from(err: io::Error) -> RegisterCACertificateError {
        RegisterCACertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for RegisterCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RegisterCACertificateError {
    fn description(&self) -> &str {
        match *self {
            RegisterCACertificateError::CertificateValidation(ref cause) => cause,
            RegisterCACertificateError::InternalFailure(ref cause) => cause,
            RegisterCACertificateError::InvalidRequest(ref cause) => cause,
            RegisterCACertificateError::LimitExceeded(ref cause) => cause,
            RegisterCACertificateError::RegistrationCodeValidation(ref cause) => cause,
            RegisterCACertificateError::ResourceAlreadyExists(ref cause) => cause,
            RegisterCACertificateError::ServiceUnavailable(ref cause) => cause,
            RegisterCACertificateError::Throttling(ref cause) => cause,
            RegisterCACertificateError::Unauthorized(ref cause) => cause,
            RegisterCACertificateError::Validation(ref cause) => cause,
            RegisterCACertificateError::Credentials(ref err) => err.description(),
            RegisterCACertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            RegisterCACertificateError::ParseError(ref cause) => cause,
            RegisterCACertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by RegisterCertificate
#[derive(Debug, PartialEq)]
pub enum RegisterCertificateError {
    /// <p>Unable to verify the CA certificate used to sign the device certificate you are attempting to register. This is happens when you have registered more than one CA certificate that has the same subject field and public key.</p>
    CertificateConflict(String),
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>The certificate is invalid.</p>
    CertificateValidation(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl RegisterCertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> RegisterCertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "CertificateConflictException" => {
                    return RegisterCertificateError::CertificateConflict(String::from(
                        error_message,
                    ))
                }
                "CertificateStateException" => {
                    return RegisterCertificateError::CertificateState(String::from(error_message))
                }
                "CertificateValidationException" => {
                    return RegisterCertificateError::CertificateValidation(String::from(
                        error_message,
                    ))
                }
                "InternalFailureException" => {
                    return RegisterCertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return RegisterCertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return RegisterCertificateError::ResourceAlreadyExists(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RegisterCertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return RegisterCertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return RegisterCertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return RegisterCertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return RegisterCertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for RegisterCertificateError {
    fn from(err: serde_json::error::Error) -> RegisterCertificateError {
        RegisterCertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for RegisterCertificateError {
    fn from(err: CredentialsError) -> RegisterCertificateError {
        RegisterCertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for RegisterCertificateError {
    fn from(err: HttpDispatchError) -> RegisterCertificateError {
        RegisterCertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for RegisterCertificateError {
    fn from(err: io::Error) -> RegisterCertificateError {
        RegisterCertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for RegisterCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RegisterCertificateError {
    fn description(&self) -> &str {
        match *self {
            RegisterCertificateError::CertificateConflict(ref cause) => cause,
            RegisterCertificateError::CertificateState(ref cause) => cause,
            RegisterCertificateError::CertificateValidation(ref cause) => cause,
            RegisterCertificateError::InternalFailure(ref cause) => cause,
            RegisterCertificateError::InvalidRequest(ref cause) => cause,
            RegisterCertificateError::ResourceAlreadyExists(ref cause) => cause,
            RegisterCertificateError::ServiceUnavailable(ref cause) => cause,
            RegisterCertificateError::Throttling(ref cause) => cause,
            RegisterCertificateError::Unauthorized(ref cause) => cause,
            RegisterCertificateError::Validation(ref cause) => cause,
            RegisterCertificateError::Credentials(ref err) => err.description(),
            RegisterCertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            RegisterCertificateError::ParseError(ref cause) => cause,
            RegisterCertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by RegisterThing
#[derive(Debug, PartialEq)]
pub enum RegisterThingError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource registration failed.</p>
    ResourceRegistrationFailure(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl RegisterThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> RegisterThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "ConflictingResourceUpdateException" => {
                    return RegisterThingError::ConflictingResourceUpdate(String::from(
                        error_message,
                    ))
                }
                "InternalFailureException" => {
                    return RegisterThingError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return RegisterThingError::InvalidRequest(String::from(error_message))
                }
                "ResourceRegistrationFailureException" => {
                    return RegisterThingError::ResourceRegistrationFailure(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RegisterThingError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return RegisterThingError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return RegisterThingError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return RegisterThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return RegisterThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for RegisterThingError {
    fn from(err: serde_json::error::Error) -> RegisterThingError {
        RegisterThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for RegisterThingError {
    fn from(err: CredentialsError) -> RegisterThingError {
        RegisterThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for RegisterThingError {
    fn from(err: HttpDispatchError) -> RegisterThingError {
        RegisterThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for RegisterThingError {
    fn from(err: io::Error) -> RegisterThingError {
        RegisterThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for RegisterThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RegisterThingError {
    fn description(&self) -> &str {
        match *self {
            RegisterThingError::ConflictingResourceUpdate(ref cause) => cause,
            RegisterThingError::InternalFailure(ref cause) => cause,
            RegisterThingError::InvalidRequest(ref cause) => cause,
            RegisterThingError::ResourceRegistrationFailure(ref cause) => cause,
            RegisterThingError::ServiceUnavailable(ref cause) => cause,
            RegisterThingError::Throttling(ref cause) => cause,
            RegisterThingError::Unauthorized(ref cause) => cause,
            RegisterThingError::Validation(ref cause) => cause,
            RegisterThingError::Credentials(ref err) => err.description(),
            RegisterThingError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            RegisterThingError::ParseError(ref cause) => cause,
            RegisterThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by RejectCertificateTransfer
#[derive(Debug, PartialEq)]
pub enum RejectCertificateTransferError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't revert the certificate transfer because the transfer is already complete.</p>
    TransferAlreadyCompleted(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl RejectCertificateTransferError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> RejectCertificateTransferError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return RejectCertificateTransferError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return RejectCertificateTransferError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RejectCertificateTransferError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RejectCertificateTransferError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return RejectCertificateTransferError::Throttling(String::from(error_message))
                }
                "TransferAlreadyCompletedException" => {
                    return RejectCertificateTransferError::TransferAlreadyCompleted(String::from(
                        error_message,
                    ))
                }
                "UnauthorizedException" => {
                    return RejectCertificateTransferError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return RejectCertificateTransferError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return RejectCertificateTransferError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for RejectCertificateTransferError {
    fn from(err: serde_json::error::Error) -> RejectCertificateTransferError {
        RejectCertificateTransferError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for RejectCertificateTransferError {
    fn from(err: CredentialsError) -> RejectCertificateTransferError {
        RejectCertificateTransferError::Credentials(err)
    }
}
impl From<HttpDispatchError> for RejectCertificateTransferError {
    fn from(err: HttpDispatchError) -> RejectCertificateTransferError {
        RejectCertificateTransferError::HttpDispatch(err)
    }
}
impl From<io::Error> for RejectCertificateTransferError {
    fn from(err: io::Error) -> RejectCertificateTransferError {
        RejectCertificateTransferError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for RejectCertificateTransferError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RejectCertificateTransferError {
    fn description(&self) -> &str {
        match *self {
            RejectCertificateTransferError::InternalFailure(ref cause) => cause,
            RejectCertificateTransferError::InvalidRequest(ref cause) => cause,
            RejectCertificateTransferError::ResourceNotFound(ref cause) => cause,
            RejectCertificateTransferError::ServiceUnavailable(ref cause) => cause,
            RejectCertificateTransferError::Throttling(ref cause) => cause,
            RejectCertificateTransferError::TransferAlreadyCompleted(ref cause) => cause,
            RejectCertificateTransferError::Unauthorized(ref cause) => cause,
            RejectCertificateTransferError::Validation(ref cause) => cause,
            RejectCertificateTransferError::Credentials(ref err) => err.description(),
            RejectCertificateTransferError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            RejectCertificateTransferError::ParseError(ref cause) => cause,
            RejectCertificateTransferError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by RemoveThingFromThingGroup
#[derive(Debug, PartialEq)]
pub enum RemoveThingFromThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl RemoveThingFromThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> RemoveThingFromThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return RemoveThingFromThingGroupError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return RemoveThingFromThingGroupError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RemoveThingFromThingGroupError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return RemoveThingFromThingGroupError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return RemoveThingFromThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return RemoveThingFromThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for RemoveThingFromThingGroupError {
    fn from(err: serde_json::error::Error) -> RemoveThingFromThingGroupError {
        RemoveThingFromThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for RemoveThingFromThingGroupError {
    fn from(err: CredentialsError) -> RemoveThingFromThingGroupError {
        RemoveThingFromThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for RemoveThingFromThingGroupError {
    fn from(err: HttpDispatchError) -> RemoveThingFromThingGroupError {
        RemoveThingFromThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for RemoveThingFromThingGroupError {
    fn from(err: io::Error) -> RemoveThingFromThingGroupError {
        RemoveThingFromThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for RemoveThingFromThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RemoveThingFromThingGroupError {
    fn description(&self) -> &str {
        match *self {
            RemoveThingFromThingGroupError::InternalFailure(ref cause) => cause,
            RemoveThingFromThingGroupError::InvalidRequest(ref cause) => cause,
            RemoveThingFromThingGroupError::ResourceNotFound(ref cause) => cause,
            RemoveThingFromThingGroupError::Throttling(ref cause) => cause,
            RemoveThingFromThingGroupError::Validation(ref cause) => cause,
            RemoveThingFromThingGroupError::Credentials(ref err) => err.description(),
            RemoveThingFromThingGroupError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            RemoveThingFromThingGroupError::ParseError(ref cause) => cause,
            RemoveThingFromThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ReplaceTopicRule
#[derive(Debug, PartialEq)]
pub enum ReplaceTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The Rule-SQL expression can't be parsed correctly.</p>
    SqlParse(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ReplaceTopicRuleError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ReplaceTopicRuleError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return ReplaceTopicRuleError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return ReplaceTopicRuleError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return ReplaceTopicRuleError::ServiceUnavailable(String::from(error_message))
                }
                "SqlParseException" => {
                    return ReplaceTopicRuleError::SqlParse(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return ReplaceTopicRuleError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return ReplaceTopicRuleError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return ReplaceTopicRuleError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ReplaceTopicRuleError {
    fn from(err: serde_json::error::Error) -> ReplaceTopicRuleError {
        ReplaceTopicRuleError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ReplaceTopicRuleError {
    fn from(err: CredentialsError) -> ReplaceTopicRuleError {
        ReplaceTopicRuleError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ReplaceTopicRuleError {
    fn from(err: HttpDispatchError) -> ReplaceTopicRuleError {
        ReplaceTopicRuleError::HttpDispatch(err)
    }
}
impl From<io::Error> for ReplaceTopicRuleError {
    fn from(err: io::Error) -> ReplaceTopicRuleError {
        ReplaceTopicRuleError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ReplaceTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ReplaceTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            ReplaceTopicRuleError::Internal(ref cause) => cause,
            ReplaceTopicRuleError::InvalidRequest(ref cause) => cause,
            ReplaceTopicRuleError::ServiceUnavailable(ref cause) => cause,
            ReplaceTopicRuleError::SqlParse(ref cause) => cause,
            ReplaceTopicRuleError::Unauthorized(ref cause) => cause,
            ReplaceTopicRuleError::Validation(ref cause) => cause,
            ReplaceTopicRuleError::Credentials(ref err) => err.description(),
            ReplaceTopicRuleError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            ReplaceTopicRuleError::ParseError(ref cause) => cause,
            ReplaceTopicRuleError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by SearchIndex
#[derive(Debug, PartialEq)]
pub enum SearchIndexError {
    /// <p>The index is not ready.</p>
    IndexNotReady(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl SearchIndexError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> SearchIndexError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "IndexNotReadyException" => {
                    return SearchIndexError::IndexNotReady(String::from(error_message))
                }
                "InternalFailureException" => {
                    return SearchIndexError::InternalFailure(String::from(error_message))
                }
                "InvalidQueryException" => {
                    return SearchIndexError::InvalidQuery(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return SearchIndexError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return SearchIndexError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return SearchIndexError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return SearchIndexError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return SearchIndexError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return SearchIndexError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return SearchIndexError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for SearchIndexError {
    fn from(err: serde_json::error::Error) -> SearchIndexError {
        SearchIndexError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for SearchIndexError {
    fn from(err: CredentialsError) -> SearchIndexError {
        SearchIndexError::Credentials(err)
    }
}
impl From<HttpDispatchError> for SearchIndexError {
    fn from(err: HttpDispatchError) -> SearchIndexError {
        SearchIndexError::HttpDispatch(err)
    }
}
impl From<io::Error> for SearchIndexError {
    fn from(err: io::Error) -> SearchIndexError {
        SearchIndexError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for SearchIndexError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SearchIndexError {
    fn description(&self) -> &str {
        match *self {
            SearchIndexError::IndexNotReady(ref cause) => cause,
            SearchIndexError::InternalFailure(ref cause) => cause,
            SearchIndexError::InvalidQuery(ref cause) => cause,
            SearchIndexError::InvalidRequest(ref cause) => cause,
            SearchIndexError::ResourceNotFound(ref cause) => cause,
            SearchIndexError::ServiceUnavailable(ref cause) => cause,
            SearchIndexError::Throttling(ref cause) => cause,
            SearchIndexError::Unauthorized(ref cause) => cause,
            SearchIndexError::Validation(ref cause) => cause,
            SearchIndexError::Credentials(ref err) => err.description(),
            SearchIndexError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            SearchIndexError::ParseError(ref cause) => cause,
            SearchIndexError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by SetDefaultAuthorizer
#[derive(Debug, PartialEq)]
pub enum SetDefaultAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl SetDefaultAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> SetDefaultAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return SetDefaultAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return SetDefaultAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "ResourceAlreadyExistsException" => {
                    return SetDefaultAuthorizerError::ResourceAlreadyExists(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return SetDefaultAuthorizerError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return SetDefaultAuthorizerError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return SetDefaultAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return SetDefaultAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return SetDefaultAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return SetDefaultAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for SetDefaultAuthorizerError {
    fn from(err: serde_json::error::Error) -> SetDefaultAuthorizerError {
        SetDefaultAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for SetDefaultAuthorizerError {
    fn from(err: CredentialsError) -> SetDefaultAuthorizerError {
        SetDefaultAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for SetDefaultAuthorizerError {
    fn from(err: HttpDispatchError) -> SetDefaultAuthorizerError {
        SetDefaultAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for SetDefaultAuthorizerError {
    fn from(err: io::Error) -> SetDefaultAuthorizerError {
        SetDefaultAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for SetDefaultAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetDefaultAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            SetDefaultAuthorizerError::InternalFailure(ref cause) => cause,
            SetDefaultAuthorizerError::InvalidRequest(ref cause) => cause,
            SetDefaultAuthorizerError::ResourceAlreadyExists(ref cause) => cause,
            SetDefaultAuthorizerError::ResourceNotFound(ref cause) => cause,
            SetDefaultAuthorizerError::ServiceUnavailable(ref cause) => cause,
            SetDefaultAuthorizerError::Throttling(ref cause) => cause,
            SetDefaultAuthorizerError::Unauthorized(ref cause) => cause,
            SetDefaultAuthorizerError::Validation(ref cause) => cause,
            SetDefaultAuthorizerError::Credentials(ref err) => err.description(),
            SetDefaultAuthorizerError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            SetDefaultAuthorizerError::ParseError(ref cause) => cause,
            SetDefaultAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by SetDefaultPolicyVersion
#[derive(Debug, PartialEq)]
pub enum SetDefaultPolicyVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl SetDefaultPolicyVersionError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> SetDefaultPolicyVersionError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return SetDefaultPolicyVersionError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return SetDefaultPolicyVersionError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return SetDefaultPolicyVersionError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return SetDefaultPolicyVersionError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return SetDefaultPolicyVersionError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return SetDefaultPolicyVersionError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return SetDefaultPolicyVersionError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return SetDefaultPolicyVersionError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for SetDefaultPolicyVersionError {
    fn from(err: serde_json::error::Error) -> SetDefaultPolicyVersionError {
        SetDefaultPolicyVersionError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for SetDefaultPolicyVersionError {
    fn from(err: CredentialsError) -> SetDefaultPolicyVersionError {
        SetDefaultPolicyVersionError::Credentials(err)
    }
}
impl From<HttpDispatchError> for SetDefaultPolicyVersionError {
    fn from(err: HttpDispatchError) -> SetDefaultPolicyVersionError {
        SetDefaultPolicyVersionError::HttpDispatch(err)
    }
}
impl From<io::Error> for SetDefaultPolicyVersionError {
    fn from(err: io::Error) -> SetDefaultPolicyVersionError {
        SetDefaultPolicyVersionError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for SetDefaultPolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetDefaultPolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            SetDefaultPolicyVersionError::InternalFailure(ref cause) => cause,
            SetDefaultPolicyVersionError::InvalidRequest(ref cause) => cause,
            SetDefaultPolicyVersionError::ResourceNotFound(ref cause) => cause,
            SetDefaultPolicyVersionError::ServiceUnavailable(ref cause) => cause,
            SetDefaultPolicyVersionError::Throttling(ref cause) => cause,
            SetDefaultPolicyVersionError::Unauthorized(ref cause) => cause,
            SetDefaultPolicyVersionError::Validation(ref cause) => cause,
            SetDefaultPolicyVersionError::Credentials(ref err) => err.description(),
            SetDefaultPolicyVersionError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            SetDefaultPolicyVersionError::ParseError(ref cause) => cause,
            SetDefaultPolicyVersionError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by SetLoggingOptions
#[derive(Debug, PartialEq)]
pub enum SetLoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl SetLoggingOptionsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> SetLoggingOptionsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return SetLoggingOptionsError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return SetLoggingOptionsError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return SetLoggingOptionsError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return SetLoggingOptionsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return SetLoggingOptionsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for SetLoggingOptionsError {
    fn from(err: serde_json::error::Error) -> SetLoggingOptionsError {
        SetLoggingOptionsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for SetLoggingOptionsError {
    fn from(err: CredentialsError) -> SetLoggingOptionsError {
        SetLoggingOptionsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for SetLoggingOptionsError {
    fn from(err: HttpDispatchError) -> SetLoggingOptionsError {
        SetLoggingOptionsError::HttpDispatch(err)
    }
}
impl From<io::Error> for SetLoggingOptionsError {
    fn from(err: io::Error) -> SetLoggingOptionsError {
        SetLoggingOptionsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for SetLoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetLoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            SetLoggingOptionsError::Internal(ref cause) => cause,
            SetLoggingOptionsError::InvalidRequest(ref cause) => cause,
            SetLoggingOptionsError::ServiceUnavailable(ref cause) => cause,
            SetLoggingOptionsError::Validation(ref cause) => cause,
            SetLoggingOptionsError::Credentials(ref err) => err.description(),
            SetLoggingOptionsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            SetLoggingOptionsError::ParseError(ref cause) => cause,
            SetLoggingOptionsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by SetV2LoggingLevel
#[derive(Debug, PartialEq)]
pub enum SetV2LoggingLevelError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource is not configured.</p>
    NotConfigured(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl SetV2LoggingLevelError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> SetV2LoggingLevelError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return SetV2LoggingLevelError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return SetV2LoggingLevelError::InvalidRequest(String::from(error_message))
                }
                "NotConfiguredException" => {
                    return SetV2LoggingLevelError::NotConfigured(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return SetV2LoggingLevelError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return SetV2LoggingLevelError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return SetV2LoggingLevelError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for SetV2LoggingLevelError {
    fn from(err: serde_json::error::Error) -> SetV2LoggingLevelError {
        SetV2LoggingLevelError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for SetV2LoggingLevelError {
    fn from(err: CredentialsError) -> SetV2LoggingLevelError {
        SetV2LoggingLevelError::Credentials(err)
    }
}
impl From<HttpDispatchError> for SetV2LoggingLevelError {
    fn from(err: HttpDispatchError) -> SetV2LoggingLevelError {
        SetV2LoggingLevelError::HttpDispatch(err)
    }
}
impl From<io::Error> for SetV2LoggingLevelError {
    fn from(err: io::Error) -> SetV2LoggingLevelError {
        SetV2LoggingLevelError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for SetV2LoggingLevelError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetV2LoggingLevelError {
    fn description(&self) -> &str {
        match *self {
            SetV2LoggingLevelError::Internal(ref cause) => cause,
            SetV2LoggingLevelError::InvalidRequest(ref cause) => cause,
            SetV2LoggingLevelError::NotConfigured(ref cause) => cause,
            SetV2LoggingLevelError::ServiceUnavailable(ref cause) => cause,
            SetV2LoggingLevelError::Validation(ref cause) => cause,
            SetV2LoggingLevelError::Credentials(ref err) => err.description(),
            SetV2LoggingLevelError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            SetV2LoggingLevelError::ParseError(ref cause) => cause,
            SetV2LoggingLevelError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by SetV2LoggingOptions
#[derive(Debug, PartialEq)]
pub enum SetV2LoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl SetV2LoggingOptionsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> SetV2LoggingOptionsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalException" => {
                    return SetV2LoggingOptionsError::Internal(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return SetV2LoggingOptionsError::InvalidRequest(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return SetV2LoggingOptionsError::ServiceUnavailable(String::from(error_message))
                }
                "ValidationException" => {
                    return SetV2LoggingOptionsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return SetV2LoggingOptionsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for SetV2LoggingOptionsError {
    fn from(err: serde_json::error::Error) -> SetV2LoggingOptionsError {
        SetV2LoggingOptionsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for SetV2LoggingOptionsError {
    fn from(err: CredentialsError) -> SetV2LoggingOptionsError {
        SetV2LoggingOptionsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for SetV2LoggingOptionsError {
    fn from(err: HttpDispatchError) -> SetV2LoggingOptionsError {
        SetV2LoggingOptionsError::HttpDispatch(err)
    }
}
impl From<io::Error> for SetV2LoggingOptionsError {
    fn from(err: io::Error) -> SetV2LoggingOptionsError {
        SetV2LoggingOptionsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for SetV2LoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetV2LoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            SetV2LoggingOptionsError::Internal(ref cause) => cause,
            SetV2LoggingOptionsError::InvalidRequest(ref cause) => cause,
            SetV2LoggingOptionsError::ServiceUnavailable(ref cause) => cause,
            SetV2LoggingOptionsError::Validation(ref cause) => cause,
            SetV2LoggingOptionsError::Credentials(ref err) => err.description(),
            SetV2LoggingOptionsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            SetV2LoggingOptionsError::ParseError(ref cause) => cause,
            SetV2LoggingOptionsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by StartOnDemandAuditTask
#[derive(Debug, PartialEq)]
pub enum StartOnDemandAuditTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl StartOnDemandAuditTaskError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> StartOnDemandAuditTaskError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return StartOnDemandAuditTaskError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return StartOnDemandAuditTaskError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return StartOnDemandAuditTaskError::LimitExceeded(String::from(error_message))
                }
                "ThrottlingException" => {
                    return StartOnDemandAuditTaskError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return StartOnDemandAuditTaskError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return StartOnDemandAuditTaskError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for StartOnDemandAuditTaskError {
    fn from(err: serde_json::error::Error) -> StartOnDemandAuditTaskError {
        StartOnDemandAuditTaskError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for StartOnDemandAuditTaskError {
    fn from(err: CredentialsError) -> StartOnDemandAuditTaskError {
        StartOnDemandAuditTaskError::Credentials(err)
    }
}
impl From<HttpDispatchError> for StartOnDemandAuditTaskError {
    fn from(err: HttpDispatchError) -> StartOnDemandAuditTaskError {
        StartOnDemandAuditTaskError::HttpDispatch(err)
    }
}
impl From<io::Error> for StartOnDemandAuditTaskError {
    fn from(err: io::Error) -> StartOnDemandAuditTaskError {
        StartOnDemandAuditTaskError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for StartOnDemandAuditTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StartOnDemandAuditTaskError {
    fn description(&self) -> &str {
        match *self {
            StartOnDemandAuditTaskError::InternalFailure(ref cause) => cause,
            StartOnDemandAuditTaskError::InvalidRequest(ref cause) => cause,
            StartOnDemandAuditTaskError::LimitExceeded(ref cause) => cause,
            StartOnDemandAuditTaskError::Throttling(ref cause) => cause,
            StartOnDemandAuditTaskError::Validation(ref cause) => cause,
            StartOnDemandAuditTaskError::Credentials(ref err) => err.description(),
            StartOnDemandAuditTaskError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            StartOnDemandAuditTaskError::ParseError(ref cause) => cause,
            StartOnDemandAuditTaskError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by StartThingRegistrationTask
#[derive(Debug, PartialEq)]
pub enum StartThingRegistrationTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl StartThingRegistrationTaskError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> StartThingRegistrationTaskError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return StartThingRegistrationTaskError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return StartThingRegistrationTaskError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return StartThingRegistrationTaskError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return StartThingRegistrationTaskError::Unauthorized(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return StartThingRegistrationTaskError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return StartThingRegistrationTaskError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for StartThingRegistrationTaskError {
    fn from(err: serde_json::error::Error) -> StartThingRegistrationTaskError {
        StartThingRegistrationTaskError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for StartThingRegistrationTaskError {
    fn from(err: CredentialsError) -> StartThingRegistrationTaskError {
        StartThingRegistrationTaskError::Credentials(err)
    }
}
impl From<HttpDispatchError> for StartThingRegistrationTaskError {
    fn from(err: HttpDispatchError) -> StartThingRegistrationTaskError {
        StartThingRegistrationTaskError::HttpDispatch(err)
    }
}
impl From<io::Error> for StartThingRegistrationTaskError {
    fn from(err: io::Error) -> StartThingRegistrationTaskError {
        StartThingRegistrationTaskError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for StartThingRegistrationTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StartThingRegistrationTaskError {
    fn description(&self) -> &str {
        match *self {
            StartThingRegistrationTaskError::InternalFailure(ref cause) => cause,
            StartThingRegistrationTaskError::InvalidRequest(ref cause) => cause,
            StartThingRegistrationTaskError::Throttling(ref cause) => cause,
            StartThingRegistrationTaskError::Unauthorized(ref cause) => cause,
            StartThingRegistrationTaskError::Validation(ref cause) => cause,
            StartThingRegistrationTaskError::Credentials(ref err) => err.description(),
            StartThingRegistrationTaskError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            StartThingRegistrationTaskError::ParseError(ref cause) => cause,
            StartThingRegistrationTaskError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by StopThingRegistrationTask
#[derive(Debug, PartialEq)]
pub enum StopThingRegistrationTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl StopThingRegistrationTaskError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> StopThingRegistrationTaskError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return StopThingRegistrationTaskError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return StopThingRegistrationTaskError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return StopThingRegistrationTaskError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return StopThingRegistrationTaskError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return StopThingRegistrationTaskError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return StopThingRegistrationTaskError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return StopThingRegistrationTaskError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for StopThingRegistrationTaskError {
    fn from(err: serde_json::error::Error) -> StopThingRegistrationTaskError {
        StopThingRegistrationTaskError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for StopThingRegistrationTaskError {
    fn from(err: CredentialsError) -> StopThingRegistrationTaskError {
        StopThingRegistrationTaskError::Credentials(err)
    }
}
impl From<HttpDispatchError> for StopThingRegistrationTaskError {
    fn from(err: HttpDispatchError) -> StopThingRegistrationTaskError {
        StopThingRegistrationTaskError::HttpDispatch(err)
    }
}
impl From<io::Error> for StopThingRegistrationTaskError {
    fn from(err: io::Error) -> StopThingRegistrationTaskError {
        StopThingRegistrationTaskError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for StopThingRegistrationTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StopThingRegistrationTaskError {
    fn description(&self) -> &str {
        match *self {
            StopThingRegistrationTaskError::InternalFailure(ref cause) => cause,
            StopThingRegistrationTaskError::InvalidRequest(ref cause) => cause,
            StopThingRegistrationTaskError::ResourceNotFound(ref cause) => cause,
            StopThingRegistrationTaskError::Throttling(ref cause) => cause,
            StopThingRegistrationTaskError::Unauthorized(ref cause) => cause,
            StopThingRegistrationTaskError::Validation(ref cause) => cause,
            StopThingRegistrationTaskError::Credentials(ref err) => err.description(),
            StopThingRegistrationTaskError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            StopThingRegistrationTaskError::ParseError(ref cause) => cause,
            StopThingRegistrationTaskError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by TestAuthorization
#[derive(Debug, PartialEq)]
pub enum TestAuthorizationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl TestAuthorizationError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> TestAuthorizationError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return TestAuthorizationError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return TestAuthorizationError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return TestAuthorizationError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return TestAuthorizationError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return TestAuthorizationError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return TestAuthorizationError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return TestAuthorizationError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return TestAuthorizationError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return TestAuthorizationError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for TestAuthorizationError {
    fn from(err: serde_json::error::Error) -> TestAuthorizationError {
        TestAuthorizationError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for TestAuthorizationError {
    fn from(err: CredentialsError) -> TestAuthorizationError {
        TestAuthorizationError::Credentials(err)
    }
}
impl From<HttpDispatchError> for TestAuthorizationError {
    fn from(err: HttpDispatchError) -> TestAuthorizationError {
        TestAuthorizationError::HttpDispatch(err)
    }
}
impl From<io::Error> for TestAuthorizationError {
    fn from(err: io::Error) -> TestAuthorizationError {
        TestAuthorizationError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for TestAuthorizationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TestAuthorizationError {
    fn description(&self) -> &str {
        match *self {
            TestAuthorizationError::InternalFailure(ref cause) => cause,
            TestAuthorizationError::InvalidRequest(ref cause) => cause,
            TestAuthorizationError::LimitExceeded(ref cause) => cause,
            TestAuthorizationError::ResourceNotFound(ref cause) => cause,
            TestAuthorizationError::ServiceUnavailable(ref cause) => cause,
            TestAuthorizationError::Throttling(ref cause) => cause,
            TestAuthorizationError::Unauthorized(ref cause) => cause,
            TestAuthorizationError::Validation(ref cause) => cause,
            TestAuthorizationError::Credentials(ref err) => err.description(),
            TestAuthorizationError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            TestAuthorizationError::ParseError(ref cause) => cause,
            TestAuthorizationError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by TestInvokeAuthorizer
#[derive(Debug, PartialEq)]
pub enum TestInvokeAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The response is invalid.</p>
    InvalidResponse(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl TestInvokeAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> TestInvokeAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return TestInvokeAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return TestInvokeAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "InvalidResponseException" => {
                    return TestInvokeAuthorizerError::InvalidResponse(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return TestInvokeAuthorizerError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return TestInvokeAuthorizerError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return TestInvokeAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return TestInvokeAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return TestInvokeAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return TestInvokeAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for TestInvokeAuthorizerError {
    fn from(err: serde_json::error::Error) -> TestInvokeAuthorizerError {
        TestInvokeAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for TestInvokeAuthorizerError {
    fn from(err: CredentialsError) -> TestInvokeAuthorizerError {
        TestInvokeAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for TestInvokeAuthorizerError {
    fn from(err: HttpDispatchError) -> TestInvokeAuthorizerError {
        TestInvokeAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for TestInvokeAuthorizerError {
    fn from(err: io::Error) -> TestInvokeAuthorizerError {
        TestInvokeAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for TestInvokeAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TestInvokeAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            TestInvokeAuthorizerError::InternalFailure(ref cause) => cause,
            TestInvokeAuthorizerError::InvalidRequest(ref cause) => cause,
            TestInvokeAuthorizerError::InvalidResponse(ref cause) => cause,
            TestInvokeAuthorizerError::ResourceNotFound(ref cause) => cause,
            TestInvokeAuthorizerError::ServiceUnavailable(ref cause) => cause,
            TestInvokeAuthorizerError::Throttling(ref cause) => cause,
            TestInvokeAuthorizerError::Unauthorized(ref cause) => cause,
            TestInvokeAuthorizerError::Validation(ref cause) => cause,
            TestInvokeAuthorizerError::Credentials(ref err) => err.description(),
            TestInvokeAuthorizerError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            TestInvokeAuthorizerError::ParseError(ref cause) => cause,
            TestInvokeAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by TransferCertificate
#[derive(Debug, PartialEq)]
pub enum TransferCertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't transfer the certificate because authorization policies are still attached.</p>
    TransferConflict(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl TransferCertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> TransferCertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "CertificateStateException" => {
                    return TransferCertificateError::CertificateState(String::from(error_message))
                }
                "InternalFailureException" => {
                    return TransferCertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return TransferCertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return TransferCertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return TransferCertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return TransferCertificateError::Throttling(String::from(error_message))
                }
                "TransferConflictException" => {
                    return TransferCertificateError::TransferConflict(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return TransferCertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return TransferCertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return TransferCertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for TransferCertificateError {
    fn from(err: serde_json::error::Error) -> TransferCertificateError {
        TransferCertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for TransferCertificateError {
    fn from(err: CredentialsError) -> TransferCertificateError {
        TransferCertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for TransferCertificateError {
    fn from(err: HttpDispatchError) -> TransferCertificateError {
        TransferCertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for TransferCertificateError {
    fn from(err: io::Error) -> TransferCertificateError {
        TransferCertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for TransferCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TransferCertificateError {
    fn description(&self) -> &str {
        match *self {
            TransferCertificateError::CertificateState(ref cause) => cause,
            TransferCertificateError::InternalFailure(ref cause) => cause,
            TransferCertificateError::InvalidRequest(ref cause) => cause,
            TransferCertificateError::ResourceNotFound(ref cause) => cause,
            TransferCertificateError::ServiceUnavailable(ref cause) => cause,
            TransferCertificateError::Throttling(ref cause) => cause,
            TransferCertificateError::TransferConflict(ref cause) => cause,
            TransferCertificateError::Unauthorized(ref cause) => cause,
            TransferCertificateError::Validation(ref cause) => cause,
            TransferCertificateError::Credentials(ref err) => err.description(),
            TransferCertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            TransferCertificateError::ParseError(ref cause) => cause,
            TransferCertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateAccountAuditConfiguration
#[derive(Debug, PartialEq)]
pub enum UpdateAccountAuditConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateAccountAuditConfigurationError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateAccountAuditConfigurationError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateAccountAuditConfigurationError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return UpdateAccountAuditConfigurationError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return UpdateAccountAuditConfigurationError::Throttling(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return UpdateAccountAuditConfigurationError::Validation(
                        error_message.to_string(),
                    )
                }
                _ => {}
            }
        }
        return UpdateAccountAuditConfigurationError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateAccountAuditConfigurationError {
    fn from(err: serde_json::error::Error) -> UpdateAccountAuditConfigurationError {
        UpdateAccountAuditConfigurationError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateAccountAuditConfigurationError {
    fn from(err: CredentialsError) -> UpdateAccountAuditConfigurationError {
        UpdateAccountAuditConfigurationError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateAccountAuditConfigurationError {
    fn from(err: HttpDispatchError) -> UpdateAccountAuditConfigurationError {
        UpdateAccountAuditConfigurationError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateAccountAuditConfigurationError {
    fn from(err: io::Error) -> UpdateAccountAuditConfigurationError {
        UpdateAccountAuditConfigurationError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateAccountAuditConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateAccountAuditConfigurationError {
    fn description(&self) -> &str {
        match *self {
            UpdateAccountAuditConfigurationError::InternalFailure(ref cause) => cause,
            UpdateAccountAuditConfigurationError::InvalidRequest(ref cause) => cause,
            UpdateAccountAuditConfigurationError::Throttling(ref cause) => cause,
            UpdateAccountAuditConfigurationError::Validation(ref cause) => cause,
            UpdateAccountAuditConfigurationError::Credentials(ref err) => err.description(),
            UpdateAccountAuditConfigurationError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateAccountAuditConfigurationError::ParseError(ref cause) => cause,
            UpdateAccountAuditConfigurationError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateAuthorizer
#[derive(Debug, PartialEq)]
pub enum UpdateAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateAuthorizerError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateAuthorizerError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateAuthorizerError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateAuthorizerError::InvalidRequest(String::from(error_message))
                }
                "LimitExceededException" => {
                    return UpdateAuthorizerError::LimitExceeded(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateAuthorizerError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return UpdateAuthorizerError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateAuthorizerError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateAuthorizerError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateAuthorizerError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateAuthorizerError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateAuthorizerError {
    fn from(err: serde_json::error::Error) -> UpdateAuthorizerError {
        UpdateAuthorizerError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateAuthorizerError {
    fn from(err: CredentialsError) -> UpdateAuthorizerError {
        UpdateAuthorizerError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateAuthorizerError {
    fn from(err: HttpDispatchError) -> UpdateAuthorizerError {
        UpdateAuthorizerError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateAuthorizerError {
    fn from(err: io::Error) -> UpdateAuthorizerError {
        UpdateAuthorizerError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            UpdateAuthorizerError::InternalFailure(ref cause) => cause,
            UpdateAuthorizerError::InvalidRequest(ref cause) => cause,
            UpdateAuthorizerError::LimitExceeded(ref cause) => cause,
            UpdateAuthorizerError::ResourceNotFound(ref cause) => cause,
            UpdateAuthorizerError::ServiceUnavailable(ref cause) => cause,
            UpdateAuthorizerError::Throttling(ref cause) => cause,
            UpdateAuthorizerError::Unauthorized(ref cause) => cause,
            UpdateAuthorizerError::Validation(ref cause) => cause,
            UpdateAuthorizerError::Credentials(ref err) => err.description(),
            UpdateAuthorizerError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            UpdateAuthorizerError::ParseError(ref cause) => cause,
            UpdateAuthorizerError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateCACertificate
#[derive(Debug, PartialEq)]
pub enum UpdateCACertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateCACertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateCACertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateCACertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateCACertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateCACertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return UpdateCACertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateCACertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateCACertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateCACertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateCACertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateCACertificateError {
    fn from(err: serde_json::error::Error) -> UpdateCACertificateError {
        UpdateCACertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateCACertificateError {
    fn from(err: CredentialsError) -> UpdateCACertificateError {
        UpdateCACertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateCACertificateError {
    fn from(err: HttpDispatchError) -> UpdateCACertificateError {
        UpdateCACertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateCACertificateError {
    fn from(err: io::Error) -> UpdateCACertificateError {
        UpdateCACertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateCACertificateError {
    fn description(&self) -> &str {
        match *self {
            UpdateCACertificateError::InternalFailure(ref cause) => cause,
            UpdateCACertificateError::InvalidRequest(ref cause) => cause,
            UpdateCACertificateError::ResourceNotFound(ref cause) => cause,
            UpdateCACertificateError::ServiceUnavailable(ref cause) => cause,
            UpdateCACertificateError::Throttling(ref cause) => cause,
            UpdateCACertificateError::Unauthorized(ref cause) => cause,
            UpdateCACertificateError::Validation(ref cause) => cause,
            UpdateCACertificateError::Credentials(ref err) => err.description(),
            UpdateCACertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateCACertificateError::ParseError(ref cause) => cause,
            UpdateCACertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateCertificate
#[derive(Debug, PartialEq)]
pub enum UpdateCertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateCertificateError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateCertificateError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "CertificateStateException" => {
                    return UpdateCertificateError::CertificateState(String::from(error_message))
                }
                "InternalFailureException" => {
                    return UpdateCertificateError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateCertificateError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateCertificateError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return UpdateCertificateError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateCertificateError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateCertificateError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateCertificateError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateCertificateError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateCertificateError {
    fn from(err: serde_json::error::Error) -> UpdateCertificateError {
        UpdateCertificateError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateCertificateError {
    fn from(err: CredentialsError) -> UpdateCertificateError {
        UpdateCertificateError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateCertificateError {
    fn from(err: HttpDispatchError) -> UpdateCertificateError {
        UpdateCertificateError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateCertificateError {
    fn from(err: io::Error) -> UpdateCertificateError {
        UpdateCertificateError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateCertificateError {
    fn description(&self) -> &str {
        match *self {
            UpdateCertificateError::CertificateState(ref cause) => cause,
            UpdateCertificateError::InternalFailure(ref cause) => cause,
            UpdateCertificateError::InvalidRequest(ref cause) => cause,
            UpdateCertificateError::ResourceNotFound(ref cause) => cause,
            UpdateCertificateError::ServiceUnavailable(ref cause) => cause,
            UpdateCertificateError::Throttling(ref cause) => cause,
            UpdateCertificateError::Unauthorized(ref cause) => cause,
            UpdateCertificateError::Validation(ref cause) => cause,
            UpdateCertificateError::Credentials(ref err) => err.description(),
            UpdateCertificateError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateCertificateError::ParseError(ref cause) => cause,
            UpdateCertificateError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateEventConfigurations
#[derive(Debug, PartialEq)]
pub enum UpdateEventConfigurationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateEventConfigurationsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateEventConfigurationsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateEventConfigurationsError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return UpdateEventConfigurationsError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return UpdateEventConfigurationsError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateEventConfigurationsError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateEventConfigurationsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateEventConfigurationsError {
    fn from(err: serde_json::error::Error) -> UpdateEventConfigurationsError {
        UpdateEventConfigurationsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateEventConfigurationsError {
    fn from(err: CredentialsError) -> UpdateEventConfigurationsError {
        UpdateEventConfigurationsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateEventConfigurationsError {
    fn from(err: HttpDispatchError) -> UpdateEventConfigurationsError {
        UpdateEventConfigurationsError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateEventConfigurationsError {
    fn from(err: io::Error) -> UpdateEventConfigurationsError {
        UpdateEventConfigurationsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateEventConfigurationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateEventConfigurationsError {
    fn description(&self) -> &str {
        match *self {
            UpdateEventConfigurationsError::InternalFailure(ref cause) => cause,
            UpdateEventConfigurationsError::InvalidRequest(ref cause) => cause,
            UpdateEventConfigurationsError::Throttling(ref cause) => cause,
            UpdateEventConfigurationsError::Validation(ref cause) => cause,
            UpdateEventConfigurationsError::Credentials(ref err) => err.description(),
            UpdateEventConfigurationsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateEventConfigurationsError::ParseError(ref cause) => cause,
            UpdateEventConfigurationsError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateIndexingConfiguration
#[derive(Debug, PartialEq)]
pub enum UpdateIndexingConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateIndexingConfigurationError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateIndexingConfigurationError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateIndexingConfigurationError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return UpdateIndexingConfigurationError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ServiceUnavailableException" => {
                    return UpdateIndexingConfigurationError::ServiceUnavailable(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return UpdateIndexingConfigurationError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateIndexingConfigurationError::Unauthorized(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return UpdateIndexingConfigurationError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateIndexingConfigurationError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateIndexingConfigurationError {
    fn from(err: serde_json::error::Error) -> UpdateIndexingConfigurationError {
        UpdateIndexingConfigurationError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateIndexingConfigurationError {
    fn from(err: CredentialsError) -> UpdateIndexingConfigurationError {
        UpdateIndexingConfigurationError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateIndexingConfigurationError {
    fn from(err: HttpDispatchError) -> UpdateIndexingConfigurationError {
        UpdateIndexingConfigurationError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateIndexingConfigurationError {
    fn from(err: io::Error) -> UpdateIndexingConfigurationError {
        UpdateIndexingConfigurationError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateIndexingConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateIndexingConfigurationError {
    fn description(&self) -> &str {
        match *self {
            UpdateIndexingConfigurationError::InternalFailure(ref cause) => cause,
            UpdateIndexingConfigurationError::InvalidRequest(ref cause) => cause,
            UpdateIndexingConfigurationError::ServiceUnavailable(ref cause) => cause,
            UpdateIndexingConfigurationError::Throttling(ref cause) => cause,
            UpdateIndexingConfigurationError::Unauthorized(ref cause) => cause,
            UpdateIndexingConfigurationError::Validation(ref cause) => cause,
            UpdateIndexingConfigurationError::Credentials(ref err) => err.description(),
            UpdateIndexingConfigurationError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateIndexingConfigurationError::ParseError(ref cause) => cause,
            UpdateIndexingConfigurationError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateRoleAlias
#[derive(Debug, PartialEq)]
pub enum UpdateRoleAliasError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateRoleAliasError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateRoleAliasError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateRoleAliasError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateRoleAliasError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateRoleAliasError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return UpdateRoleAliasError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateRoleAliasError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateRoleAliasError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateRoleAliasError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateRoleAliasError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateRoleAliasError {
    fn from(err: serde_json::error::Error) -> UpdateRoleAliasError {
        UpdateRoleAliasError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateRoleAliasError {
    fn from(err: CredentialsError) -> UpdateRoleAliasError {
        UpdateRoleAliasError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateRoleAliasError {
    fn from(err: HttpDispatchError) -> UpdateRoleAliasError {
        UpdateRoleAliasError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateRoleAliasError {
    fn from(err: io::Error) -> UpdateRoleAliasError {
        UpdateRoleAliasError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            UpdateRoleAliasError::InternalFailure(ref cause) => cause,
            UpdateRoleAliasError::InvalidRequest(ref cause) => cause,
            UpdateRoleAliasError::ResourceNotFound(ref cause) => cause,
            UpdateRoleAliasError::ServiceUnavailable(ref cause) => cause,
            UpdateRoleAliasError::Throttling(ref cause) => cause,
            UpdateRoleAliasError::Unauthorized(ref cause) => cause,
            UpdateRoleAliasError::Validation(ref cause) => cause,
            UpdateRoleAliasError::Credentials(ref err) => err.description(),
            UpdateRoleAliasError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            UpdateRoleAliasError::ParseError(ref cause) => cause,
            UpdateRoleAliasError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateScheduledAudit
#[derive(Debug, PartialEq)]
pub enum UpdateScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateScheduledAuditError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateScheduledAuditError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateScheduledAuditError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateScheduledAuditError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateScheduledAuditError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateScheduledAuditError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateScheduledAuditError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateScheduledAuditError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateScheduledAuditError {
    fn from(err: serde_json::error::Error) -> UpdateScheduledAuditError {
        UpdateScheduledAuditError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateScheduledAuditError {
    fn from(err: CredentialsError) -> UpdateScheduledAuditError {
        UpdateScheduledAuditError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateScheduledAuditError {
    fn from(err: HttpDispatchError) -> UpdateScheduledAuditError {
        UpdateScheduledAuditError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateScheduledAuditError {
    fn from(err: io::Error) -> UpdateScheduledAuditError {
        UpdateScheduledAuditError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            UpdateScheduledAuditError::InternalFailure(ref cause) => cause,
            UpdateScheduledAuditError::InvalidRequest(ref cause) => cause,
            UpdateScheduledAuditError::ResourceNotFound(ref cause) => cause,
            UpdateScheduledAuditError::Throttling(ref cause) => cause,
            UpdateScheduledAuditError::Validation(ref cause) => cause,
            UpdateScheduledAuditError::Credentials(ref err) => err.description(),
            UpdateScheduledAuditError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateScheduledAuditError::ParseError(ref cause) => cause,
            UpdateScheduledAuditError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateSecurityProfile
#[derive(Debug, PartialEq)]
pub enum UpdateSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateSecurityProfileError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateSecurityProfileError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateSecurityProfileError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateSecurityProfileError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateSecurityProfileError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateSecurityProfileError::Throttling(String::from(error_message))
                }
                "VersionConflictException" => {
                    return UpdateSecurityProfileError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateSecurityProfileError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateSecurityProfileError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateSecurityProfileError {
    fn from(err: serde_json::error::Error) -> UpdateSecurityProfileError {
        UpdateSecurityProfileError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateSecurityProfileError {
    fn from(err: CredentialsError) -> UpdateSecurityProfileError {
        UpdateSecurityProfileError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateSecurityProfileError {
    fn from(err: HttpDispatchError) -> UpdateSecurityProfileError {
        UpdateSecurityProfileError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateSecurityProfileError {
    fn from(err: io::Error) -> UpdateSecurityProfileError {
        UpdateSecurityProfileError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            UpdateSecurityProfileError::InternalFailure(ref cause) => cause,
            UpdateSecurityProfileError::InvalidRequest(ref cause) => cause,
            UpdateSecurityProfileError::ResourceNotFound(ref cause) => cause,
            UpdateSecurityProfileError::Throttling(ref cause) => cause,
            UpdateSecurityProfileError::VersionConflict(ref cause) => cause,
            UpdateSecurityProfileError::Validation(ref cause) => cause,
            UpdateSecurityProfileError::Credentials(ref err) => err.description(),
            UpdateSecurityProfileError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateSecurityProfileError::ParseError(ref cause) => cause,
            UpdateSecurityProfileError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateStream
#[derive(Debug, PartialEq)]
pub enum UpdateStreamError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateStreamError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateStreamError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateStreamError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateStreamError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateStreamError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return UpdateStreamError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateStreamError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateStreamError::Unauthorized(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateStreamError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateStreamError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateStreamError {
    fn from(err: serde_json::error::Error) -> UpdateStreamError {
        UpdateStreamError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateStreamError {
    fn from(err: CredentialsError) -> UpdateStreamError {
        UpdateStreamError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateStreamError {
    fn from(err: HttpDispatchError) -> UpdateStreamError {
        UpdateStreamError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateStreamError {
    fn from(err: io::Error) -> UpdateStreamError {
        UpdateStreamError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateStreamError {
    fn description(&self) -> &str {
        match *self {
            UpdateStreamError::InternalFailure(ref cause) => cause,
            UpdateStreamError::InvalidRequest(ref cause) => cause,
            UpdateStreamError::ResourceNotFound(ref cause) => cause,
            UpdateStreamError::ServiceUnavailable(ref cause) => cause,
            UpdateStreamError::Throttling(ref cause) => cause,
            UpdateStreamError::Unauthorized(ref cause) => cause,
            UpdateStreamError::Validation(ref cause) => cause,
            UpdateStreamError::Credentials(ref err) => err.description(),
            UpdateStreamError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            UpdateStreamError::ParseError(ref cause) => cause,
            UpdateStreamError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateThing
#[derive(Debug, PartialEq)]
pub enum UpdateThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateThingError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateThingError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateThingError::ResourceNotFound(String::from(error_message))
                }
                "ServiceUnavailableException" => {
                    return UpdateThingError::ServiceUnavailable(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateThingError::Throttling(String::from(error_message))
                }
                "UnauthorizedException" => {
                    return UpdateThingError::Unauthorized(String::from(error_message))
                }
                "VersionConflictException" => {
                    return UpdateThingError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateThingError {
    fn from(err: serde_json::error::Error) -> UpdateThingError {
        UpdateThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateThingError {
    fn from(err: CredentialsError) -> UpdateThingError {
        UpdateThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateThingError {
    fn from(err: HttpDispatchError) -> UpdateThingError {
        UpdateThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateThingError {
    fn from(err: io::Error) -> UpdateThingError {
        UpdateThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateThingError {
    fn description(&self) -> &str {
        match *self {
            UpdateThingError::InternalFailure(ref cause) => cause,
            UpdateThingError::InvalidRequest(ref cause) => cause,
            UpdateThingError::ResourceNotFound(ref cause) => cause,
            UpdateThingError::ServiceUnavailable(ref cause) => cause,
            UpdateThingError::Throttling(ref cause) => cause,
            UpdateThingError::Unauthorized(ref cause) => cause,
            UpdateThingError::VersionConflict(ref cause) => cause,
            UpdateThingError::Validation(ref cause) => cause,
            UpdateThingError::Credentials(ref err) => err.description(),
            UpdateThingError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            UpdateThingError::ParseError(ref cause) => cause,
            UpdateThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateThingGroup
#[derive(Debug, PartialEq)]
pub enum UpdateThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateThingGroupError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateThingGroupError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateThingGroupError::InternalFailure(String::from(error_message))
                }
                "InvalidRequestException" => {
                    return UpdateThingGroupError::InvalidRequest(String::from(error_message))
                }
                "ResourceNotFoundException" => {
                    return UpdateThingGroupError::ResourceNotFound(String::from(error_message))
                }
                "ThrottlingException" => {
                    return UpdateThingGroupError::Throttling(String::from(error_message))
                }
                "VersionConflictException" => {
                    return UpdateThingGroupError::VersionConflict(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateThingGroupError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateThingGroupError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateThingGroupError {
    fn from(err: serde_json::error::Error) -> UpdateThingGroupError {
        UpdateThingGroupError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateThingGroupError {
    fn from(err: CredentialsError) -> UpdateThingGroupError {
        UpdateThingGroupError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateThingGroupError {
    fn from(err: HttpDispatchError) -> UpdateThingGroupError {
        UpdateThingGroupError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateThingGroupError {
    fn from(err: io::Error) -> UpdateThingGroupError {
        UpdateThingGroupError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateThingGroupError {
    fn description(&self) -> &str {
        match *self {
            UpdateThingGroupError::InternalFailure(ref cause) => cause,
            UpdateThingGroupError::InvalidRequest(ref cause) => cause,
            UpdateThingGroupError::ResourceNotFound(ref cause) => cause,
            UpdateThingGroupError::Throttling(ref cause) => cause,
            UpdateThingGroupError::VersionConflict(ref cause) => cause,
            UpdateThingGroupError::Validation(ref cause) => cause,
            UpdateThingGroupError::Credentials(ref err) => err.description(),
            UpdateThingGroupError::HttpDispatch(ref dispatch_error) => dispatch_error.description(),
            UpdateThingGroupError::ParseError(ref cause) => cause,
            UpdateThingGroupError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by UpdateThingGroupsForThing
#[derive(Debug, PartialEq)]
pub enum UpdateThingGroupsForThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl UpdateThingGroupsForThingError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> UpdateThingGroupsForThingError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return UpdateThingGroupsForThingError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return UpdateThingGroupsForThingError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ResourceNotFoundException" => {
                    return UpdateThingGroupsForThingError::ResourceNotFound(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return UpdateThingGroupsForThingError::Throttling(String::from(error_message))
                }
                "ValidationException" => {
                    return UpdateThingGroupsForThingError::Validation(error_message.to_string())
                }
                _ => {}
            }
        }
        return UpdateThingGroupsForThingError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for UpdateThingGroupsForThingError {
    fn from(err: serde_json::error::Error) -> UpdateThingGroupsForThingError {
        UpdateThingGroupsForThingError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for UpdateThingGroupsForThingError {
    fn from(err: CredentialsError) -> UpdateThingGroupsForThingError {
        UpdateThingGroupsForThingError::Credentials(err)
    }
}
impl From<HttpDispatchError> for UpdateThingGroupsForThingError {
    fn from(err: HttpDispatchError) -> UpdateThingGroupsForThingError {
        UpdateThingGroupsForThingError::HttpDispatch(err)
    }
}
impl From<io::Error> for UpdateThingGroupsForThingError {
    fn from(err: io::Error) -> UpdateThingGroupsForThingError {
        UpdateThingGroupsForThingError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for UpdateThingGroupsForThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateThingGroupsForThingError {
    fn description(&self) -> &str {
        match *self {
            UpdateThingGroupsForThingError::InternalFailure(ref cause) => cause,
            UpdateThingGroupsForThingError::InvalidRequest(ref cause) => cause,
            UpdateThingGroupsForThingError::ResourceNotFound(ref cause) => cause,
            UpdateThingGroupsForThingError::Throttling(ref cause) => cause,
            UpdateThingGroupsForThingError::Validation(ref cause) => cause,
            UpdateThingGroupsForThingError::Credentials(ref err) => err.description(),
            UpdateThingGroupsForThingError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            UpdateThingGroupsForThingError::ParseError(ref cause) => cause,
            UpdateThingGroupsForThingError::Unknown(_) => "unknown error",
        }
    }
}
/// Errors returned by ValidateSecurityProfileBehaviors
#[derive(Debug, PartialEq)]
pub enum ValidateSecurityProfileBehaviorsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// An error occurred dispatching the HTTP request
    HttpDispatch(HttpDispatchError),
    /// An error was encountered with AWS credentials.
    Credentials(CredentialsError),
    /// A validation error occurred.  Details from AWS are provided.
    Validation(String),
    /// An error occurred parsing the response payload.
    ParseError(String),
    /// An unknown error occurred.  The raw HTTP response is provided.
    Unknown(BufferedHttpResponse),
}

impl ValidateSecurityProfileBehaviorsError {
    // see boto RestJSONParser impl for parsing errors
    // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L838-L850
    pub fn from_response(res: BufferedHttpResponse) -> ValidateSecurityProfileBehaviorsError {
        if let Ok(json) = from_slice::<SerdeJsonValue>(&res.body) {
            let error_type = match res.headers.get("x-amzn-errortype") {
                Some(raw_error_type) => raw_error_type
                    .split(':')
                    .next()
                    .unwrap_or_else(|| "Unknown"),
                _ => json
                    .get("code")
                    .or_else(|| json.get("Code"))
                    .and_then(|c| c.as_str())
                    .unwrap_or_else(|| "Unknown"),
            };

            // message can come in either "message" or "Message"
            // see boto BaseJSONParser impl for parsing message
            // https://github.com/boto/botocore/blob/4dff78c840403d1d17db9b3f800b20d3bd9fbf9f/botocore/parsers.py#L595-L598
            let error_message = json
                .get("message")
                .or_else(|| json.get("Message"))
                .and_then(|m| m.as_str())
                .unwrap_or("");

            match error_type {
                "InternalFailureException" => {
                    return ValidateSecurityProfileBehaviorsError::InternalFailure(String::from(
                        error_message,
                    ))
                }
                "InvalidRequestException" => {
                    return ValidateSecurityProfileBehaviorsError::InvalidRequest(String::from(
                        error_message,
                    ))
                }
                "ThrottlingException" => {
                    return ValidateSecurityProfileBehaviorsError::Throttling(String::from(
                        error_message,
                    ))
                }
                "ValidationException" => {
                    return ValidateSecurityProfileBehaviorsError::Validation(
                        error_message.to_string(),
                    )
                }
                _ => {}
            }
        }
        return ValidateSecurityProfileBehaviorsError::Unknown(res);
    }
}

impl From<serde_json::error::Error> for ValidateSecurityProfileBehaviorsError {
    fn from(err: serde_json::error::Error) -> ValidateSecurityProfileBehaviorsError {
        ValidateSecurityProfileBehaviorsError::ParseError(err.description().to_string())
    }
}
impl From<CredentialsError> for ValidateSecurityProfileBehaviorsError {
    fn from(err: CredentialsError) -> ValidateSecurityProfileBehaviorsError {
        ValidateSecurityProfileBehaviorsError::Credentials(err)
    }
}
impl From<HttpDispatchError> for ValidateSecurityProfileBehaviorsError {
    fn from(err: HttpDispatchError) -> ValidateSecurityProfileBehaviorsError {
        ValidateSecurityProfileBehaviorsError::HttpDispatch(err)
    }
}
impl From<io::Error> for ValidateSecurityProfileBehaviorsError {
    fn from(err: io::Error) -> ValidateSecurityProfileBehaviorsError {
        ValidateSecurityProfileBehaviorsError::HttpDispatch(HttpDispatchError::from(err))
    }
}
impl fmt::Display for ValidateSecurityProfileBehaviorsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ValidateSecurityProfileBehaviorsError {
    fn description(&self) -> &str {
        match *self {
            ValidateSecurityProfileBehaviorsError::InternalFailure(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::InvalidRequest(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::Throttling(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::Validation(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::Credentials(ref err) => err.description(),
            ValidateSecurityProfileBehaviorsError::HttpDispatch(ref dispatch_error) => {
                dispatch_error.description()
            }
            ValidateSecurityProfileBehaviorsError::ParseError(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::Unknown(_) => "unknown error",
        }
    }
}
/// Trait representing the capabilities of the AWS IoT API. AWS IoT clients implement this trait.
pub trait Iot {
    /// <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
    fn accept_certificate_transfer(
        &self,
        input: AcceptCertificateTransferRequest,
    ) -> RusotoFuture<(), AcceptCertificateTransferError>;

    /// <p>Adds a thing to a thing group.</p>
    fn add_thing_to_thing_group(
        &self,
        input: AddThingToThingGroupRequest,
    ) -> RusotoFuture<AddThingToThingGroupResponse, AddThingToThingGroupError>;

    /// <p><p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to &quot;CONTINUOUS&quot;.</p> </li> <li> <p>The job status must currently be &quot;IN_PROGRESS&quot;.</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul></p>
    fn associate_targets_with_job(
        &self,
        input: AssociateTargetsWithJobRequest,
    ) -> RusotoFuture<AssociateTargetsWithJobResponse, AssociateTargetsWithJobError>;

    /// <p>Attaches a policy to the specified target.</p>
    fn attach_policy(&self, input: AttachPolicyRequest) -> RusotoFuture<(), AttachPolicyError>;

    /// <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
    fn attach_principal_policy(
        &self,
        input: AttachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), AttachPrincipalPolicyError>;

    /// <p>Associates a Device Defender security profile with a thing group or with this account. Each thing group or account can have up to five security profiles associated with it.</p>
    fn attach_security_profile(
        &self,
        input: AttachSecurityProfileRequest,
    ) -> RusotoFuture<AttachSecurityProfileResponse, AttachSecurityProfileError>;

    /// <p>Attaches the specified principal to the specified thing.</p>
    fn attach_thing_principal(
        &self,
        input: AttachThingPrincipalRequest,
    ) -> RusotoFuture<AttachThingPrincipalResponse, AttachThingPrincipalError>;

    /// <p>Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.</p>
    fn cancel_audit_task(
        &self,
        input: CancelAuditTaskRequest,
    ) -> RusotoFuture<CancelAuditTaskResponse, CancelAuditTaskError>;

    /// <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
    fn cancel_certificate_transfer(
        &self,
        input: CancelCertificateTransferRequest,
    ) -> RusotoFuture<(), CancelCertificateTransferError>;

    /// <p>Cancels a job.</p>
    fn cancel_job(
        &self,
        input: CancelJobRequest,
    ) -> RusotoFuture<CancelJobResponse, CancelJobError>;

    /// <p>Cancels the execution of a job for a given thing.</p>
    fn cancel_job_execution(
        &self,
        input: CancelJobExecutionRequest,
    ) -> RusotoFuture<(), CancelJobExecutionError>;

    /// <p>Clears the default authorizer.</p>
    fn clear_default_authorizer(
        &self,
    ) -> RusotoFuture<ClearDefaultAuthorizerResponse, ClearDefaultAuthorizerError>;

    /// <p>Creates an authorizer.</p>
    fn create_authorizer(
        &self,
        input: CreateAuthorizerRequest,
    ) -> RusotoFuture<CreateAuthorizerResponse, CreateAuthorizerError>;

    /// <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
    fn create_certificate_from_csr(
        &self,
        input: CreateCertificateFromCsrRequest,
    ) -> RusotoFuture<CreateCertificateFromCsrResponse, CreateCertificateFromCsrError>;

    /// <p>Creates a job.</p>
    fn create_job(
        &self,
        input: CreateJobRequest,
    ) -> RusotoFuture<CreateJobResponse, CreateJobError>;

    /// <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
    fn create_keys_and_certificate(
        &self,
        input: CreateKeysAndCertificateRequest,
    ) -> RusotoFuture<CreateKeysAndCertificateResponse, CreateKeysAndCertificateError>;

    /// <p>Creates an AWS IoT OTAUpdate on a target group of things or groups.</p>
    fn create_ota_update(
        &self,
        input: CreateOTAUpdateRequest,
    ) -> RusotoFuture<CreateOTAUpdateResponse, CreateOTAUpdateError>;

    /// <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
    fn create_policy(
        &self,
        input: CreatePolicyRequest,
    ) -> RusotoFuture<CreatePolicyResponse, CreatePolicyError>;

    /// <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    fn create_policy_version(
        &self,
        input: CreatePolicyVersionRequest,
    ) -> RusotoFuture<CreatePolicyVersionResponse, CreatePolicyVersionError>;

    /// <p>Creates a role alias.</p>
    fn create_role_alias(
        &self,
        input: CreateRoleAliasRequest,
    ) -> RusotoFuture<CreateRoleAliasResponse, CreateRoleAliasError>;

    /// <p>Creates a scheduled audit that is run at a specified time interval.</p>
    fn create_scheduled_audit(
        &self,
        input: CreateScheduledAuditRequest,
    ) -> RusotoFuture<CreateScheduledAuditResponse, CreateScheduledAuditError>;

    /// <p>Creates a Device Defender security profile.</p>
    fn create_security_profile(
        &self,
        input: CreateSecurityProfileRequest,
    ) -> RusotoFuture<CreateSecurityProfileResponse, CreateSecurityProfileError>;

    /// <p>Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.</p>
    fn create_stream(
        &self,
        input: CreateStreamRequest,
    ) -> RusotoFuture<CreateStreamResponse, CreateStreamError>;

    /// <p><p>Creates a thing record in the registry.</p> <note> <p>This is a control plane operation. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing(
        &self,
        input: CreateThingRequest,
    ) -> RusotoFuture<CreateThingResponse, CreateThingError>;

    /// <p><p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing_group(
        &self,
        input: CreateThingGroupRequest,
    ) -> RusotoFuture<CreateThingGroupResponse, CreateThingGroupError>;

    /// <p>Creates a new thing type.</p>
    fn create_thing_type(
        &self,
        input: CreateThingTypeRequest,
    ) -> RusotoFuture<CreateThingTypeResponse, CreateThingTypeError>;

    /// <p>Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn create_topic_rule(
        &self,
        input: CreateTopicRuleRequest,
    ) -> RusotoFuture<(), CreateTopicRuleError>;

    /// <p>Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. </p>
    fn delete_account_audit_configuration(
        &self,
        input: DeleteAccountAuditConfigurationRequest,
    ) -> RusotoFuture<DeleteAccountAuditConfigurationResponse, DeleteAccountAuditConfigurationError>;

    /// <p>Deletes an authorizer.</p>
    fn delete_authorizer(
        &self,
        input: DeleteAuthorizerRequest,
    ) -> RusotoFuture<DeleteAuthorizerResponse, DeleteAuthorizerError>;

    /// <p>Deletes a registered CA certificate.</p>
    fn delete_ca_certificate(
        &self,
        input: DeleteCACertificateRequest,
    ) -> RusotoFuture<DeleteCACertificateResponse, DeleteCACertificateError>;

    /// <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
    fn delete_certificate(
        &self,
        input: DeleteCertificateRequest,
    ) -> RusotoFuture<(), DeleteCertificateError>;

    /// <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
    fn delete_job(&self, input: DeleteJobRequest) -> RusotoFuture<(), DeleteJobError>;

    /// <p>Deletes a job execution.</p>
    fn delete_job_execution(
        &self,
        input: DeleteJobExecutionRequest,
    ) -> RusotoFuture<(), DeleteJobExecutionError>;

    /// <p>Delete an OTA update.</p>
    fn delete_ota_update(
        &self,
        input: DeleteOTAUpdateRequest,
    ) -> RusotoFuture<DeleteOTAUpdateResponse, DeleteOTAUpdateError>;

    /// <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
    fn delete_policy(&self, input: DeletePolicyRequest) -> RusotoFuture<(), DeletePolicyError>;

    /// <p>Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.</p>
    fn delete_policy_version(
        &self,
        input: DeletePolicyVersionRequest,
    ) -> RusotoFuture<(), DeletePolicyVersionError>;

    /// <p>Deletes a CA certificate registration code.</p>
    fn delete_registration_code(
        &self,
    ) -> RusotoFuture<DeleteRegistrationCodeResponse, DeleteRegistrationCodeError>;

    /// <p>Deletes a role alias</p>
    fn delete_role_alias(
        &self,
        input: DeleteRoleAliasRequest,
    ) -> RusotoFuture<DeleteRoleAliasResponse, DeleteRoleAliasError>;

    /// <p>Deletes a scheduled audit.</p>
    fn delete_scheduled_audit(
        &self,
        input: DeleteScheduledAuditRequest,
    ) -> RusotoFuture<DeleteScheduledAuditResponse, DeleteScheduledAuditError>;

    /// <p>Deletes a Device Defender security profile.</p>
    fn delete_security_profile(
        &self,
        input: DeleteSecurityProfileRequest,
    ) -> RusotoFuture<DeleteSecurityProfileResponse, DeleteSecurityProfileError>;

    /// <p>Deletes a stream.</p>
    fn delete_stream(
        &self,
        input: DeleteStreamRequest,
    ) -> RusotoFuture<DeleteStreamResponse, DeleteStreamError>;

    /// <p>Deletes the specified thing.</p>
    fn delete_thing(
        &self,
        input: DeleteThingRequest,
    ) -> RusotoFuture<DeleteThingResponse, DeleteThingError>;

    /// <p>Deletes a thing group.</p>
    fn delete_thing_group(
        &self,
        input: DeleteThingGroupRequest,
    ) -> RusotoFuture<DeleteThingGroupResponse, DeleteThingGroupError>;

    /// <p>Deletes the specified thing type . You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.</p>
    fn delete_thing_type(
        &self,
        input: DeleteThingTypeRequest,
    ) -> RusotoFuture<DeleteThingTypeResponse, DeleteThingTypeError>;

    /// <p>Deletes the rule.</p>
    fn delete_topic_rule(
        &self,
        input: DeleteTopicRuleRequest,
    ) -> RusotoFuture<(), DeleteTopicRuleError>;

    /// <p>Deletes a logging level.</p>
    fn delete_v2_logging_level(
        &self,
        input: DeleteV2LoggingLevelRequest,
    ) -> RusotoFuture<(), DeleteV2LoggingLevelError>;

    /// <p>Deprecates a thing type. You can not associate new things with deprecated thing type.</p>
    fn deprecate_thing_type(
        &self,
        input: DeprecateThingTypeRequest,
    ) -> RusotoFuture<DeprecateThingTypeResponse, DeprecateThingTypeError>;

    /// <p>Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn describe_account_audit_configuration(
        &self,
    ) -> RusotoFuture<
        DescribeAccountAuditConfigurationResponse,
        DescribeAccountAuditConfigurationError,
    >;

    /// <p>Gets information about a Device Defender audit.</p>
    fn describe_audit_task(
        &self,
        input: DescribeAuditTaskRequest,
    ) -> RusotoFuture<DescribeAuditTaskResponse, DescribeAuditTaskError>;

    /// <p>Describes an authorizer.</p>
    fn describe_authorizer(
        &self,
        input: DescribeAuthorizerRequest,
    ) -> RusotoFuture<DescribeAuthorizerResponse, DescribeAuthorizerError>;

    /// <p>Describes a registered CA certificate.</p>
    fn describe_ca_certificate(
        &self,
        input: DescribeCACertificateRequest,
    ) -> RusotoFuture<DescribeCACertificateResponse, DescribeCACertificateError>;

    /// <p>Gets information about the specified certificate.</p>
    fn describe_certificate(
        &self,
        input: DescribeCertificateRequest,
    ) -> RusotoFuture<DescribeCertificateResponse, DescribeCertificateError>;

    /// <p>Describes the default authorizer.</p>
    fn describe_default_authorizer(
        &self,
    ) -> RusotoFuture<DescribeDefaultAuthorizerResponse, DescribeDefaultAuthorizerError>;

    /// <p>Returns a unique endpoint specific to the AWS account making the call.</p>
    fn describe_endpoint(
        &self,
        input: DescribeEndpointRequest,
    ) -> RusotoFuture<DescribeEndpointResponse, DescribeEndpointError>;

    /// <p>Describes event configurations.</p>
    fn describe_event_configurations(
        &self,
    ) -> RusotoFuture<DescribeEventConfigurationsResponse, DescribeEventConfigurationsError>;

    /// <p>Describes a search index.</p>
    fn describe_index(
        &self,
        input: DescribeIndexRequest,
    ) -> RusotoFuture<DescribeIndexResponse, DescribeIndexError>;

    /// <p>Describes a job.</p>
    fn describe_job(
        &self,
        input: DescribeJobRequest,
    ) -> RusotoFuture<DescribeJobResponse, DescribeJobError>;

    /// <p>Describes a job execution.</p>
    fn describe_job_execution(
        &self,
        input: DescribeJobExecutionRequest,
    ) -> RusotoFuture<DescribeJobExecutionResponse, DescribeJobExecutionError>;

    /// <p>Describes a role alias.</p>
    fn describe_role_alias(
        &self,
        input: DescribeRoleAliasRequest,
    ) -> RusotoFuture<DescribeRoleAliasResponse, DescribeRoleAliasError>;

    /// <p>Gets information about a scheduled audit.</p>
    fn describe_scheduled_audit(
        &self,
        input: DescribeScheduledAuditRequest,
    ) -> RusotoFuture<DescribeScheduledAuditResponse, DescribeScheduledAuditError>;

    /// <p>Gets information about a Device Defender security profile.</p>
    fn describe_security_profile(
        &self,
        input: DescribeSecurityProfileRequest,
    ) -> RusotoFuture<DescribeSecurityProfileResponse, DescribeSecurityProfileError>;

    /// <p>Gets information about a stream.</p>
    fn describe_stream(
        &self,
        input: DescribeStreamRequest,
    ) -> RusotoFuture<DescribeStreamResponse, DescribeStreamError>;

    /// <p>Gets information about the specified thing.</p>
    fn describe_thing(
        &self,
        input: DescribeThingRequest,
    ) -> RusotoFuture<DescribeThingResponse, DescribeThingError>;

    /// <p>Describe a thing group.</p>
    fn describe_thing_group(
        &self,
        input: DescribeThingGroupRequest,
    ) -> RusotoFuture<DescribeThingGroupResponse, DescribeThingGroupError>;

    /// <p>Describes a bulk thing provisioning task.</p>
    fn describe_thing_registration_task(
        &self,
        input: DescribeThingRegistrationTaskRequest,
    ) -> RusotoFuture<DescribeThingRegistrationTaskResponse, DescribeThingRegistrationTaskError>;

    /// <p>Gets information about the specified thing type.</p>
    fn describe_thing_type(
        &self,
        input: DescribeThingTypeRequest,
    ) -> RusotoFuture<DescribeThingTypeResponse, DescribeThingTypeError>;

    /// <p>Detaches a policy from the specified target.</p>
    fn detach_policy(&self, input: DetachPolicyRequest) -> RusotoFuture<(), DetachPolicyError>;

    /// <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
    fn detach_principal_policy(
        &self,
        input: DetachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), DetachPrincipalPolicyError>;

    /// <p>Disassociates a Device Defender security profile from a thing group or from this account.</p>
    fn detach_security_profile(
        &self,
        input: DetachSecurityProfileRequest,
    ) -> RusotoFuture<DetachSecurityProfileResponse, DetachSecurityProfileError>;

    /// <p>Detaches the specified principal from the specified thing.</p>
    fn detach_thing_principal(
        &self,
        input: DetachThingPrincipalRequest,
    ) -> RusotoFuture<DetachThingPrincipalResponse, DetachThingPrincipalError>;

    /// <p>Disables the rule.</p>
    fn disable_topic_rule(
        &self,
        input: DisableTopicRuleRequest,
    ) -> RusotoFuture<(), DisableTopicRuleError>;

    /// <p>Enables the rule.</p>
    fn enable_topic_rule(
        &self,
        input: EnableTopicRuleRequest,
    ) -> RusotoFuture<(), EnableTopicRuleError>;

    /// <p>Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.</p>
    fn get_effective_policies(
        &self,
        input: GetEffectivePoliciesRequest,
    ) -> RusotoFuture<GetEffectivePoliciesResponse, GetEffectivePoliciesError>;

    /// <p>Gets the search configuration.</p>
    fn get_indexing_configuration(
        &self,
    ) -> RusotoFuture<GetIndexingConfigurationResponse, GetIndexingConfigurationError>;

    /// <p>Gets a job document.</p>
    fn get_job_document(
        &self,
        input: GetJobDocumentRequest,
    ) -> RusotoFuture<GetJobDocumentResponse, GetJobDocumentError>;

    /// <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
    fn get_logging_options(
        &self,
    ) -> RusotoFuture<GetLoggingOptionsResponse, GetLoggingOptionsError>;

    /// <p>Gets an OTA update.</p>
    fn get_ota_update(
        &self,
        input: GetOTAUpdateRequest,
    ) -> RusotoFuture<GetOTAUpdateResponse, GetOTAUpdateError>;

    /// <p>Gets information about the specified policy with the policy document of the default version.</p>
    fn get_policy(
        &self,
        input: GetPolicyRequest,
    ) -> RusotoFuture<GetPolicyResponse, GetPolicyError>;

    /// <p>Gets information about the specified policy version.</p>
    fn get_policy_version(
        &self,
        input: GetPolicyVersionRequest,
    ) -> RusotoFuture<GetPolicyVersionResponse, GetPolicyVersionError>;

    /// <p>Gets a registration code used to register a CA certificate with AWS IoT.</p>
    fn get_registration_code(
        &self,
    ) -> RusotoFuture<GetRegistrationCodeResponse, GetRegistrationCodeError>;

    /// <p>Gets information about the rule.</p>
    fn get_topic_rule(
        &self,
        input: GetTopicRuleRequest,
    ) -> RusotoFuture<GetTopicRuleResponse, GetTopicRuleError>;

    /// <p>Gets the fine grained logging options.</p>
    fn get_v2_logging_options(
        &self,
    ) -> RusotoFuture<GetV2LoggingOptionsResponse, GetV2LoggingOptionsError>;

    /// <p>Lists the active violations for a given Device Defender security profile.</p>
    fn list_active_violations(
        &self,
        input: ListActiveViolationsRequest,
    ) -> RusotoFuture<ListActiveViolationsResponse, ListActiveViolationsError>;

    /// <p>Lists the policies attached to the specified thing group.</p>
    fn list_attached_policies(
        &self,
        input: ListAttachedPoliciesRequest,
    ) -> RusotoFuture<ListAttachedPoliciesResponse, ListAttachedPoliciesError>;

    /// <p>Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)</p>
    fn list_audit_findings(
        &self,
        input: ListAuditFindingsRequest,
    ) -> RusotoFuture<ListAuditFindingsResponse, ListAuditFindingsError>;

    /// <p>Lists the Device Defender audits that have been performed during a given time period.</p>
    fn list_audit_tasks(
        &self,
        input: ListAuditTasksRequest,
    ) -> RusotoFuture<ListAuditTasksResponse, ListAuditTasksError>;

    /// <p>Lists the authorizers registered in your account.</p>
    fn list_authorizers(
        &self,
        input: ListAuthorizersRequest,
    ) -> RusotoFuture<ListAuthorizersResponse, ListAuthorizersError>;

    /// <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_ca_certificates(
        &self,
        input: ListCACertificatesRequest,
    ) -> RusotoFuture<ListCACertificatesResponse, ListCACertificatesError>;

    /// <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_certificates(
        &self,
        input: ListCertificatesRequest,
    ) -> RusotoFuture<ListCertificatesResponse, ListCertificatesError>;

    /// <p>List the device certificates signed by the specified CA certificate.</p>
    fn list_certificates_by_ca(
        &self,
        input: ListCertificatesByCARequest,
    ) -> RusotoFuture<ListCertificatesByCAResponse, ListCertificatesByCAError>;

    /// <p>Lists the search indices.</p>
    fn list_indices(
        &self,
        input: ListIndicesRequest,
    ) -> RusotoFuture<ListIndicesResponse, ListIndicesError>;

    /// <p>Lists the job executions for a job.</p>
    fn list_job_executions_for_job(
        &self,
        input: ListJobExecutionsForJobRequest,
    ) -> RusotoFuture<ListJobExecutionsForJobResponse, ListJobExecutionsForJobError>;

    /// <p>Lists the job executions for the specified thing.</p>
    fn list_job_executions_for_thing(
        &self,
        input: ListJobExecutionsForThingRequest,
    ) -> RusotoFuture<ListJobExecutionsForThingResponse, ListJobExecutionsForThingError>;

    /// <p>Lists jobs.</p>
    fn list_jobs(&self, input: ListJobsRequest) -> RusotoFuture<ListJobsResponse, ListJobsError>;

    /// <p>Lists OTA updates.</p>
    fn list_ota_updates(
        &self,
        input: ListOTAUpdatesRequest,
    ) -> RusotoFuture<ListOTAUpdatesResponse, ListOTAUpdatesError>;

    /// <p>Lists certificates that are being transferred but not yet accepted.</p>
    fn list_outgoing_certificates(
        &self,
        input: ListOutgoingCertificatesRequest,
    ) -> RusotoFuture<ListOutgoingCertificatesResponse, ListOutgoingCertificatesError>;

    /// <p>Lists your policies.</p>
    fn list_policies(
        &self,
        input: ListPoliciesRequest,
    ) -> RusotoFuture<ListPoliciesResponse, ListPoliciesError>;

    /// <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
    fn list_policy_principals(
        &self,
        input: ListPolicyPrincipalsRequest,
    ) -> RusotoFuture<ListPolicyPrincipalsResponse, ListPolicyPrincipalsError>;

    /// <p>Lists the versions of the specified policy and identifies the default version.</p>
    fn list_policy_versions(
        &self,
        input: ListPolicyVersionsRequest,
    ) -> RusotoFuture<ListPolicyVersionsResponse, ListPolicyVersionsError>;

    /// <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
    fn list_principal_policies(
        &self,
        input: ListPrincipalPoliciesRequest,
    ) -> RusotoFuture<ListPrincipalPoliciesResponse, ListPrincipalPoliciesError>;

    /// <p>Lists the things associated with the specified principal.</p>
    fn list_principal_things(
        &self,
        input: ListPrincipalThingsRequest,
    ) -> RusotoFuture<ListPrincipalThingsResponse, ListPrincipalThingsError>;

    /// <p>Lists the role aliases registered in your account.</p>
    fn list_role_aliases(
        &self,
        input: ListRoleAliasesRequest,
    ) -> RusotoFuture<ListRoleAliasesResponse, ListRoleAliasesError>;

    /// <p>Lists all of your scheduled audits.</p>
    fn list_scheduled_audits(
        &self,
        input: ListScheduledAuditsRequest,
    ) -> RusotoFuture<ListScheduledAuditsResponse, ListScheduledAuditsError>;

    /// <p>Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.</p>
    fn list_security_profiles(
        &self,
        input: ListSecurityProfilesRequest,
    ) -> RusotoFuture<ListSecurityProfilesResponse, ListSecurityProfilesError>;

    /// <p>Lists the Device Defender security profiles attached to a target (thing group).</p>
    fn list_security_profiles_for_target(
        &self,
        input: ListSecurityProfilesForTargetRequest,
    ) -> RusotoFuture<ListSecurityProfilesForTargetResponse, ListSecurityProfilesForTargetError>;

    /// <p>Lists all of the streams in your AWS account.</p>
    fn list_streams(
        &self,
        input: ListStreamsRequest,
    ) -> RusotoFuture<ListStreamsResponse, ListStreamsError>;

    /// <p>List targets for the specified policy.</p>
    fn list_targets_for_policy(
        &self,
        input: ListTargetsForPolicyRequest,
    ) -> RusotoFuture<ListTargetsForPolicyResponse, ListTargetsForPolicyError>;

    /// <p>Lists the targets (thing groups) associated with a given Device Defender security profile.</p>
    fn list_targets_for_security_profile(
        &self,
        input: ListTargetsForSecurityProfileRequest,
    ) -> RusotoFuture<ListTargetsForSecurityProfileResponse, ListTargetsForSecurityProfileError>;

    /// <p>List the thing groups in your account.</p>
    fn list_thing_groups(
        &self,
        input: ListThingGroupsRequest,
    ) -> RusotoFuture<ListThingGroupsResponse, ListThingGroupsError>;

    /// <p>List the thing groups to which the specified thing belongs.</p>
    fn list_thing_groups_for_thing(
        &self,
        input: ListThingGroupsForThingRequest,
    ) -> RusotoFuture<ListThingGroupsForThingResponse, ListThingGroupsForThingError>;

    /// <p>Lists the principals associated with the specified thing.</p>
    fn list_thing_principals(
        &self,
        input: ListThingPrincipalsRequest,
    ) -> RusotoFuture<ListThingPrincipalsResponse, ListThingPrincipalsError>;

    /// <p>Information about the thing registration tasks.</p>
    fn list_thing_registration_task_reports(
        &self,
        input: ListThingRegistrationTaskReportsRequest,
    ) -> RusotoFuture<ListThingRegistrationTaskReportsResponse, ListThingRegistrationTaskReportsError>;

    /// <p>List bulk thing provisioning tasks.</p>
    fn list_thing_registration_tasks(
        &self,
        input: ListThingRegistrationTasksRequest,
    ) -> RusotoFuture<ListThingRegistrationTasksResponse, ListThingRegistrationTasksError>;

    /// <p>Lists the existing thing types.</p>
    fn list_thing_types(
        &self,
        input: ListThingTypesRequest,
    ) -> RusotoFuture<ListThingTypesResponse, ListThingTypesError>;

    /// <p>Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. </p>
    fn list_things(
        &self,
        input: ListThingsRequest,
    ) -> RusotoFuture<ListThingsResponse, ListThingsError>;

    /// <p>Lists the things in the specified group.</p>
    fn list_things_in_thing_group(
        &self,
        input: ListThingsInThingGroupRequest,
    ) -> RusotoFuture<ListThingsInThingGroupResponse, ListThingsInThingGroupError>;

    /// <p>Lists the rules for the specific topic.</p>
    fn list_topic_rules(
        &self,
        input: ListTopicRulesRequest,
    ) -> RusotoFuture<ListTopicRulesResponse, ListTopicRulesError>;

    /// <p>Lists logging levels.</p>
    fn list_v2_logging_levels(
        &self,
        input: ListV2LoggingLevelsRequest,
    ) -> RusotoFuture<ListV2LoggingLevelsResponse, ListV2LoggingLevelsError>;

    /// <p>Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior or thing (device).</p>
    fn list_violation_events(
        &self,
        input: ListViolationEventsRequest,
    ) -> RusotoFuture<ListViolationEventsResponse, ListViolationEventsError>;

    /// <p>Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.</p>
    fn register_ca_certificate(
        &self,
        input: RegisterCACertificateRequest,
    ) -> RusotoFuture<RegisterCACertificateResponse, RegisterCACertificateError>;

    /// <p>Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.</p>
    fn register_certificate(
        &self,
        input: RegisterCertificateRequest,
    ) -> RusotoFuture<RegisterCertificateResponse, RegisterCertificateError>;

    /// <p>Provisions a thing.</p>
    fn register_thing(
        &self,
        input: RegisterThingRequest,
    ) -> RusotoFuture<RegisterThingResponse, RegisterThingError>;

    /// <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
    fn reject_certificate_transfer(
        &self,
        input: RejectCertificateTransferRequest,
    ) -> RusotoFuture<(), RejectCertificateTransferError>;

    /// <p>Remove the specified thing from the specified group.</p>
    fn remove_thing_from_thing_group(
        &self,
        input: RemoveThingFromThingGroupRequest,
    ) -> RusotoFuture<RemoveThingFromThingGroupResponse, RemoveThingFromThingGroupError>;

    /// <p>Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn replace_topic_rule(
        &self,
        input: ReplaceTopicRuleRequest,
    ) -> RusotoFuture<(), ReplaceTopicRuleError>;

    /// <p>The query search index.</p>
    fn search_index(
        &self,
        input: SearchIndexRequest,
    ) -> RusotoFuture<SearchIndexResponse, SearchIndexError>;

    /// <p>Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.</p>
    fn set_default_authorizer(
        &self,
        input: SetDefaultAuthorizerRequest,
    ) -> RusotoFuture<SetDefaultAuthorizerResponse, SetDefaultAuthorizerError>;

    /// <p>Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.</p>
    fn set_default_policy_version(
        &self,
        input: SetDefaultPolicyVersionRequest,
    ) -> RusotoFuture<(), SetDefaultPolicyVersionError>;

    /// <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
    fn set_logging_options(
        &self,
        input: SetLoggingOptionsRequest,
    ) -> RusotoFuture<(), SetLoggingOptionsError>;

    /// <p>Sets the logging level.</p>
    fn set_v2_logging_level(
        &self,
        input: SetV2LoggingLevelRequest,
    ) -> RusotoFuture<(), SetV2LoggingLevelError>;

    /// <p>Sets the logging options for the V2 logging service.</p>
    fn set_v2_logging_options(
        &self,
        input: SetV2LoggingOptionsRequest,
    ) -> RusotoFuture<(), SetV2LoggingOptionsError>;

    /// <p>Starts an on-demand Device Defender audit.</p>
    fn start_on_demand_audit_task(
        &self,
        input: StartOnDemandAuditTaskRequest,
    ) -> RusotoFuture<StartOnDemandAuditTaskResponse, StartOnDemandAuditTaskError>;

    /// <p>Creates a bulk thing provisioning task.</p>
    fn start_thing_registration_task(
        &self,
        input: StartThingRegistrationTaskRequest,
    ) -> RusotoFuture<StartThingRegistrationTaskResponse, StartThingRegistrationTaskError>;

    /// <p>Cancels a bulk thing provisioning task.</p>
    fn stop_thing_registration_task(
        &self,
        input: StopThingRegistrationTaskRequest,
    ) -> RusotoFuture<StopThingRegistrationTaskResponse, StopThingRegistrationTaskError>;

    /// <p>Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_authorization(
        &self,
        input: TestAuthorizationRequest,
    ) -> RusotoFuture<TestAuthorizationResponse, TestAuthorizationError>;

    /// <p>Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_invoke_authorizer(
        &self,
        input: TestInvokeAuthorizerRequest,
    ) -> RusotoFuture<TestInvokeAuthorizerResponse, TestInvokeAuthorizerError>;

    /// <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
    fn transfer_certificate(
        &self,
        input: TransferCertificateRequest,
    ) -> RusotoFuture<TransferCertificateResponse, TransferCertificateError>;

    /// <p>Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn update_account_audit_configuration(
        &self,
        input: UpdateAccountAuditConfigurationRequest,
    ) -> RusotoFuture<UpdateAccountAuditConfigurationResponse, UpdateAccountAuditConfigurationError>;

    /// <p>Updates an authorizer.</p>
    fn update_authorizer(
        &self,
        input: UpdateAuthorizerRequest,
    ) -> RusotoFuture<UpdateAuthorizerResponse, UpdateAuthorizerError>;

    /// <p>Updates a registered CA certificate.</p>
    fn update_ca_certificate(
        &self,
        input: UpdateCACertificateRequest,
    ) -> RusotoFuture<(), UpdateCACertificateError>;

    /// <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
    fn update_certificate(
        &self,
        input: UpdateCertificateRequest,
    ) -> RusotoFuture<(), UpdateCertificateError>;

    /// <p>Updates the event configurations.</p>
    fn update_event_configurations(
        &self,
        input: UpdateEventConfigurationsRequest,
    ) -> RusotoFuture<UpdateEventConfigurationsResponse, UpdateEventConfigurationsError>;

    /// <p>Updates the search configuration.</p>
    fn update_indexing_configuration(
        &self,
        input: UpdateIndexingConfigurationRequest,
    ) -> RusotoFuture<UpdateIndexingConfigurationResponse, UpdateIndexingConfigurationError>;

    /// <p>Updates a role alias.</p>
    fn update_role_alias(
        &self,
        input: UpdateRoleAliasRequest,
    ) -> RusotoFuture<UpdateRoleAliasResponse, UpdateRoleAliasError>;

    /// <p>Updates a scheduled audit, including what checks are performed and how often the audit takes place.</p>
    fn update_scheduled_audit(
        &self,
        input: UpdateScheduledAuditRequest,
    ) -> RusotoFuture<UpdateScheduledAuditResponse, UpdateScheduledAuditError>;

    /// <p>Updates a Device Defender security profile.</p>
    fn update_security_profile(
        &self,
        input: UpdateSecurityProfileRequest,
    ) -> RusotoFuture<UpdateSecurityProfileResponse, UpdateSecurityProfileError>;

    /// <p>Updates an existing stream. The stream version will be incremented by one.</p>
    fn update_stream(
        &self,
        input: UpdateStreamRequest,
    ) -> RusotoFuture<UpdateStreamResponse, UpdateStreamError>;

    /// <p>Updates the data for a thing.</p>
    fn update_thing(
        &self,
        input: UpdateThingRequest,
    ) -> RusotoFuture<UpdateThingResponse, UpdateThingError>;

    /// <p>Update a thing group.</p>
    fn update_thing_group(
        &self,
        input: UpdateThingGroupRequest,
    ) -> RusotoFuture<UpdateThingGroupResponse, UpdateThingGroupError>;

    /// <p>Updates the groups to which the thing belongs.</p>
    fn update_thing_groups_for_thing(
        &self,
        input: UpdateThingGroupsForThingRequest,
    ) -> RusotoFuture<UpdateThingGroupsForThingResponse, UpdateThingGroupsForThingError>;

    /// <p>Validates a Device Defender security profile behaviors specification.</p>
    fn validate_security_profile_behaviors(
        &self,
        input: ValidateSecurityProfileBehaviorsRequest,
    ) -> RusotoFuture<ValidateSecurityProfileBehaviorsResponse, ValidateSecurityProfileBehaviorsError>;
}
/// A client for the AWS IoT API.
pub struct IotClient {
    client: Client,
    region: region::Region,
}

impl IotClient {
    /// Creates a client backed by the default tokio event loop.
    ///
    /// The client will use the default credentials provider and tls client.
    pub fn new(region: region::Region) -> IotClient {
        IotClient {
            client: Client::shared(),
            region: region,
        }
    }

    pub fn new_with<P, D>(
        request_dispatcher: D,
        credentials_provider: P,
        region: region::Region,
    ) -> IotClient
    where
        P: ProvideAwsCredentials + Send + Sync + 'static,
        P::Future: Send,
        D: DispatchSignedRequest + Send + Sync + 'static,
        D::Future: Send,
    {
        IotClient {
            client: Client::new_with(credentials_provider, request_dispatcher),
            region: region,
        }
    }
}

impl Iot for IotClient {
    /// <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
    fn accept_certificate_transfer(
        &self,
        input: AcceptCertificateTransferRequest,
    ) -> RusotoFuture<(), AcceptCertificateTransferError> {
        let request_uri = format!(
            "/accept-certificate-transfer/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(AcceptCertificateTransferError::from_response(response))
                }))
            }
        })
    }

    /// <p>Adds a thing to a thing group.</p>
    fn add_thing_to_thing_group(
        &self,
        input: AddThingToThingGroupRequest,
    ) -> RusotoFuture<AddThingToThingGroupResponse, AddThingToThingGroupError> {
        let request_uri = "/thing-groups/addThingToThingGroup";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<AddThingToThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AddThingToThingGroupError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p><p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to &quot;CONTINUOUS&quot;.</p> </li> <li> <p>The job status must currently be &quot;IN_PROGRESS&quot;.</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul></p>
    fn associate_targets_with_job(
        &self,
        input: AssociateTargetsWithJobRequest,
    ) -> RusotoFuture<AssociateTargetsWithJobResponse, AssociateTargetsWithJobError> {
        let request_uri = format!("/jobs/{job_id}/targets", job_id = input.job_id);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<AssociateTargetsWithJobResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(AssociateTargetsWithJobError::from_response(response))
                }))
            }
        })
    }

    /// <p>Attaches a policy to the specified target.</p>
    fn attach_policy(&self, input: AttachPolicyRequest) -> RusotoFuture<(), AttachPolicyError> {
        let request_uri = format!(
            "/target-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(AttachPolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
    fn attach_principal_policy(
        &self,
        input: AttachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), AttachPrincipalPolicyError> {
        let request_uri = format!(
            "/principal-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AttachPrincipalPolicyError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Associates a Device Defender security profile with a thing group or with this account. Each thing group or account can have up to five security profiles associated with it.</p>
    fn attach_security_profile(
        &self,
        input: AttachSecurityProfileRequest,
    ) -> RusotoFuture<AttachSecurityProfileResponse, AttachSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}/targets",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put(
            "securityProfileTargetArn",
            &input.security_profile_target_arn,
        );
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<AttachSecurityProfileResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AttachSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Attaches the specified principal to the specified thing.</p>
    fn attach_thing_principal(
        &self,
        input: AttachThingPrincipalRequest,
    ) -> RusotoFuture<AttachThingPrincipalResponse, AttachThingPrincipalError> {
        let request_uri = format!(
            "/things/{thing_name}/principals",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<AttachThingPrincipalResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AttachThingPrincipalError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.</p>
    fn cancel_audit_task(
        &self,
        input: CancelAuditTaskRequest,
    ) -> RusotoFuture<CancelAuditTaskResponse, CancelAuditTaskError> {
        let request_uri = format!("/audit/tasks/{task_id}/cancel", task_id = input.task_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CancelAuditTaskResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CancelAuditTaskError::from_response(response))),
                )
            }
        })
    }

    /// <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
    fn cancel_certificate_transfer(
        &self,
        input: CancelCertificateTransferRequest,
    ) -> RusotoFuture<(), CancelCertificateTransferError> {
        let request_uri = format!(
            "/cancel-certificate-transfer/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CancelCertificateTransferError::from_response(response))
                }))
            }
        })
    }

    /// <p>Cancels a job.</p>
    fn cancel_job(
        &self,
        input: CancelJobRequest,
    ) -> RusotoFuture<CancelJobResponse, CancelJobError> {
        let request_uri = format!("/jobs/{job_id}/cancel", job_id = input.job_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CancelJobResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CancelJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Cancels the execution of a job for a given thing.</p>
    fn cancel_job_execution(
        &self,
        input: CancelJobExecutionRequest,
    ) -> RusotoFuture<(), CancelJobExecutionError> {
        let request_uri = format!(
            "/things/{thing_name}/jobs/{job_id}/cancel",
            job_id = input.job_id,
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CancelJobExecutionError::from_response(response))),
                )
            }
        })
    }

    /// <p>Clears the default authorizer.</p>
    fn clear_default_authorizer(
        &self,
    ) -> RusotoFuture<ClearDefaultAuthorizerResponse, ClearDefaultAuthorizerError> {
        let request_uri = "/default-authorizer";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ClearDefaultAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ClearDefaultAuthorizerError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates an authorizer.</p>
    fn create_authorizer(
        &self,
        input: CreateAuthorizerRequest,
    ) -> RusotoFuture<CreateAuthorizerResponse, CreateAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
    fn create_certificate_from_csr(
        &self,
        input: CreateCertificateFromCsrRequest,
    ) -> RusotoFuture<CreateCertificateFromCsrResponse, CreateCertificateFromCsrError> {
        let request_uri = "/certificates";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<CreateCertificateFromCsrResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateCertificateFromCsrError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates a job.</p>
    fn create_job(
        &self,
        input: CreateJobRequest,
    ) -> RusotoFuture<CreateJobResponse, CreateJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateJobResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
    fn create_keys_and_certificate(
        &self,
        input: CreateKeysAndCertificateRequest,
    ) -> RusotoFuture<CreateKeysAndCertificateResponse, CreateKeysAndCertificateError> {
        let request_uri = "/keys-and-certificate";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<CreateKeysAndCertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateKeysAndCertificateError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates an AWS IoT OTAUpdate on a target group of things or groups.</p>
    fn create_ota_update(
        &self,
        input: CreateOTAUpdateRequest,
    ) -> RusotoFuture<CreateOTAUpdateResponse, CreateOTAUpdateError> {
        let request_uri = format!(
            "/otaUpdates/{ota_update_id}",
            ota_update_id = input.ota_update_id
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateOTAUpdateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateOTAUpdateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
    fn create_policy(
        &self,
        input: CreatePolicyRequest,
    ) -> RusotoFuture<CreatePolicyResponse, CreatePolicyError> {
        let request_uri = format!("/policies/{policy_name}", policy_name = input.policy_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreatePolicyResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreatePolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    fn create_policy_version(
        &self,
        input: CreatePolicyVersionRequest,
    ) -> RusotoFuture<CreatePolicyVersionResponse, CreatePolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_default {
            params.put("setAsDefault", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<CreatePolicyVersionResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreatePolicyVersionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a role alias.</p>
    fn create_role_alias(
        &self,
        input: CreateRoleAliasRequest,
    ) -> RusotoFuture<CreateRoleAliasResponse, CreateRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateRoleAliasResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a scheduled audit that is run at a specified time interval.</p>
    fn create_scheduled_audit(
        &self,
        input: CreateScheduledAuditRequest,
    ) -> RusotoFuture<CreateScheduledAuditResponse, CreateScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<CreateScheduledAuditResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreateScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a Device Defender security profile.</p>
    fn create_security_profile(
        &self,
        input: CreateSecurityProfileRequest,
    ) -> RusotoFuture<CreateSecurityProfileResponse, CreateSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<CreateSecurityProfileResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreateSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.</p>
    fn create_stream(
        &self,
        input: CreateStreamRequest,
    ) -> RusotoFuture<CreateStreamResponse, CreateStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateStreamResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p><p>Creates a thing record in the registry.</p> <note> <p>This is a control plane operation. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing(
        &self,
        input: CreateThingRequest,
    ) -> RusotoFuture<CreateThingResponse, CreateThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateThingError::from_response(response))),
                )
            }
        })
    }

    /// <p><p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing_group(
        &self,
        input: CreateThingGroupRequest,
    ) -> RusotoFuture<CreateThingGroupResponse, CreateThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a new thing type.</p>
    fn create_thing_type(
        &self,
        input: CreateThingTypeRequest,
    ) -> RusotoFuture<CreateThingTypeResponse, CreateThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<CreateThingTypeResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn create_topic_rule(
        &self,
        input: CreateTopicRuleRequest,
    ) -> RusotoFuture<(), CreateTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input.topic_rule_payload).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. </p>
    fn delete_account_audit_configuration(
        &self,
        input: DeleteAccountAuditConfigurationRequest,
    ) -> RusotoFuture<DeleteAccountAuditConfigurationResponse, DeleteAccountAuditConfigurationError>
    {
        let request_uri = "/audit/configuration";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.delete_scheduled_audits {
            params.put("deleteScheduledAudits", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DeleteAccountAuditConfigurationResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteAccountAuditConfigurationError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Deletes an authorizer.</p>
    fn delete_authorizer(
        &self,
        input: DeleteAuthorizerRequest,
    ) -> RusotoFuture<DeleteAuthorizerResponse, DeleteAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a registered CA certificate.</p>
    fn delete_ca_certificate(
        &self,
        input: DeleteCACertificateRequest,
    ) -> RusotoFuture<DeleteCACertificateResponse, DeleteCACertificateError> {
        let request_uri = format!(
            "/cacertificate/{ca_certificate_id}",
            ca_certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DeleteCACertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
    fn delete_certificate(
        &self,
        input: DeleteCertificateRequest,
    ) -> RusotoFuture<(), DeleteCertificateError> {
        let request_uri = format!(
            "/certificates/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.force_delete {
            params.put("forceDelete", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteCertificateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
    fn delete_job(&self, input: DeleteJobRequest) -> RusotoFuture<(), DeleteJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a job execution.</p>
    fn delete_job_execution(
        &self,
        input: DeleteJobExecutionRequest,
    ) -> RusotoFuture<(), DeleteJobExecutionError> {
        let request_uri = format!(
            "/things/{thing_name}/jobs/{job_id}/executionNumber/{execution_number}",
            execution_number = input.execution_number,
            job_id = input.job_id,
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteJobExecutionError::from_response(response))),
                )
            }
        })
    }

    /// <p>Delete an OTA update.</p>
    fn delete_ota_update(
        &self,
        input: DeleteOTAUpdateRequest,
    ) -> RusotoFuture<DeleteOTAUpdateResponse, DeleteOTAUpdateError> {
        let request_uri = format!(
            "/otaUpdates/{ota_update_id}",
            ota_update_id = input.ota_update_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteOTAUpdateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteOTAUpdateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
    fn delete_policy(&self, input: DeletePolicyRequest) -> RusotoFuture<(), DeletePolicyError> {
        let request_uri = format!("/policies/{policy_name}", policy_name = input.policy_name);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeletePolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.</p>
    fn delete_policy_version(
        &self,
        input: DeletePolicyVersionRequest,
    ) -> RusotoFuture<(), DeletePolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version/{policy_version_id}",
            policy_name = input.policy_name,
            policy_version_id = input.policy_version_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeletePolicyVersionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a CA certificate registration code.</p>
    fn delete_registration_code(
        &self,
    ) -> RusotoFuture<DeleteRegistrationCodeResponse, DeleteRegistrationCodeError> {
        let request_uri = "/registrationcode";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DeleteRegistrationCodeResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteRegistrationCodeError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a role alias</p>
    fn delete_role_alias(
        &self,
        input: DeleteRoleAliasRequest,
    ) -> RusotoFuture<DeleteRoleAliasResponse, DeleteRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteRoleAliasResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a scheduled audit.</p>
    fn delete_scheduled_audit(
        &self,
        input: DeleteScheduledAuditRequest,
    ) -> RusotoFuture<DeleteScheduledAuditResponse, DeleteScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DeleteScheduledAuditResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a Device Defender security profile.</p>
    fn delete_security_profile(
        &self,
        input: DeleteSecurityProfileRequest,
    ) -> RusotoFuture<DeleteSecurityProfileResponse, DeleteSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DeleteSecurityProfileResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a stream.</p>
    fn delete_stream(
        &self,
        input: DeleteStreamRequest,
    ) -> RusotoFuture<DeleteStreamResponse, DeleteStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteStreamResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified thing.</p>
    fn delete_thing(
        &self,
        input: DeleteThingRequest,
    ) -> RusotoFuture<DeleteThingResponse, DeleteThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a thing group.</p>
    fn delete_thing_group(
        &self,
        input: DeleteThingGroupRequest,
    ) -> RusotoFuture<DeleteThingGroupResponse, DeleteThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified thing type . You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.</p>
    fn delete_thing_type(
        &self,
        input: DeleteThingTypeRequest,
    ) -> RusotoFuture<DeleteThingTypeResponse, DeleteThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DeleteThingTypeResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the rule.</p>
    fn delete_topic_rule(
        &self,
        input: DeleteTopicRuleRequest,
    ) -> RusotoFuture<(), DeleteTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a logging level.</p>
    fn delete_v2_logging_level(
        &self,
        input: DeleteV2LoggingLevelRequest,
    ) -> RusotoFuture<(), DeleteV2LoggingLevelError> {
        let request_uri = "/v2LoggingLevel";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("targetName", &input.target_name);
        params.put("targetType", &input.target_type);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteV2LoggingLevelError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deprecates a thing type. You can not associate new things with deprecated thing type.</p>
    fn deprecate_thing_type(
        &self,
        input: DeprecateThingTypeRequest,
    ) -> RusotoFuture<DeprecateThingTypeResponse, DeprecateThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}/deprecate",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DeprecateThingTypeResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeprecateThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn describe_account_audit_configuration(
        &self,
    ) -> RusotoFuture<
        DescribeAccountAuditConfigurationResponse,
        DescribeAccountAuditConfigurationError,
    > {
        let request_uri = "/audit/configuration";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeAccountAuditConfigurationResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeAccountAuditConfigurationError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Gets information about a Device Defender audit.</p>
    fn describe_audit_task(
        &self,
        input: DescribeAuditTaskRequest,
    ) -> RusotoFuture<DescribeAuditTaskResponse, DescribeAuditTaskError> {
        let request_uri = format!("/audit/tasks/{task_id}", task_id = input.task_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeAuditTaskResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeAuditTaskError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes an authorizer.</p>
    fn describe_authorizer(
        &self,
        input: DescribeAuthorizerRequest,
    ) -> RusotoFuture<DescribeAuthorizerResponse, DescribeAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a registered CA certificate.</p>
    fn describe_ca_certificate(
        &self,
        input: DescribeCACertificateRequest,
    ) -> RusotoFuture<DescribeCACertificateResponse, DescribeCACertificateError> {
        let request_uri = format!(
            "/cacertificate/{ca_certificate_id}",
            ca_certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeCACertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about the specified certificate.</p>
    fn describe_certificate(
        &self,
        input: DescribeCertificateRequest,
    ) -> RusotoFuture<DescribeCertificateResponse, DescribeCertificateError> {
        let request_uri = format!(
            "/certificates/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeCertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeCertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Describes the default authorizer.</p>
    fn describe_default_authorizer(
        &self,
    ) -> RusotoFuture<DescribeDefaultAuthorizerResponse, DescribeDefaultAuthorizerError> {
        let request_uri = "/default-authorizer";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeDefaultAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeDefaultAuthorizerError::from_response(response))
                }))
            }
        })
    }

    /// <p>Returns a unique endpoint specific to the AWS account making the call.</p>
    fn describe_endpoint(
        &self,
        input: DescribeEndpointRequest,
    ) -> RusotoFuture<DescribeEndpointResponse, DescribeEndpointError> {
        let request_uri = "/endpoint";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.endpoint_type {
            params.put("endpointType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DescribeEndpointResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeEndpointError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes event configurations.</p>
    fn describe_event_configurations(
        &self,
    ) -> RusotoFuture<DescribeEventConfigurationsResponse, DescribeEventConfigurationsError> {
        let request_uri = "/event-configurations";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeEventConfigurationsResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeEventConfigurationsError::from_response(response))
                }))
            }
        })
    }

    /// <p>Describes a search index.</p>
    fn describe_index(
        &self,
        input: DescribeIndexRequest,
    ) -> RusotoFuture<DescribeIndexResponse, DescribeIndexError> {
        let request_uri = format!("/indices/{index_name}", index_name = input.index_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DescribeIndexResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeIndexError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a job.</p>
    fn describe_job(
        &self,
        input: DescribeJobRequest,
    ) -> RusotoFuture<DescribeJobResponse, DescribeJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DescribeJobResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a job execution.</p>
    fn describe_job_execution(
        &self,
        input: DescribeJobExecutionRequest,
    ) -> RusotoFuture<DescribeJobExecutionResponse, DescribeJobExecutionError> {
        let request_uri = format!(
            "/things/{thing_name}/jobs/{job_id}",
            job_id = input.job_id,
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.execution_number {
            params.put("executionNumber", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeJobExecutionResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeJobExecutionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Describes a role alias.</p>
    fn describe_role_alias(
        &self,
        input: DescribeRoleAliasRequest,
    ) -> RusotoFuture<DescribeRoleAliasResponse, DescribeRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeRoleAliasResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about a scheduled audit.</p>
    fn describe_scheduled_audit(
        &self,
        input: DescribeScheduledAuditRequest,
    ) -> RusotoFuture<DescribeScheduledAuditResponse, DescribeScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeScheduledAuditResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about a Device Defender security profile.</p>
    fn describe_security_profile(
        &self,
        input: DescribeSecurityProfileRequest,
    ) -> RusotoFuture<DescribeSecurityProfileResponse, DescribeSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeSecurityProfileResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeSecurityProfileError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets information about a stream.</p>
    fn describe_stream(
        &self,
        input: DescribeStreamRequest,
    ) -> RusotoFuture<DescribeStreamResponse, DescribeStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DescribeStreamResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the specified thing.</p>
    fn describe_thing(
        &self,
        input: DescribeThingRequest,
    ) -> RusotoFuture<DescribeThingResponse, DescribeThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<DescribeThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describe a thing group.</p>
    fn describe_thing_group(
        &self,
        input: DescribeThingGroupRequest,
    ) -> RusotoFuture<DescribeThingGroupResponse, DescribeThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a bulk thing provisioning task.</p>
    fn describe_thing_registration_task(
        &self,
        input: DescribeThingRegistrationTaskRequest,
    ) -> RusotoFuture<DescribeThingRegistrationTaskResponse, DescribeThingRegistrationTaskError>
    {
        let request_uri = format!(
            "/thing-registration-tasks/{task_id}",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeThingRegistrationTaskResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeThingRegistrationTaskError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets information about the specified thing type.</p>
    fn describe_thing_type(
        &self,
        input: DescribeThingTypeRequest,
    ) -> RusotoFuture<DescribeThingTypeResponse, DescribeThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DescribeThingTypeResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Detaches a policy from the specified target.</p>
    fn detach_policy(&self, input: DetachPolicyRequest) -> RusotoFuture<(), DetachPolicyError> {
        let request_uri = format!(
            "/target-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DetachPolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
    fn detach_principal_policy(
        &self,
        input: DetachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), DetachPrincipalPolicyError> {
        let request_uri = format!(
            "/principal-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DetachPrincipalPolicyError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Disassociates a Device Defender security profile from a thing group or from this account.</p>
    fn detach_security_profile(
        &self,
        input: DetachSecurityProfileRequest,
    ) -> RusotoFuture<DetachSecurityProfileResponse, DetachSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}/targets",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put(
            "securityProfileTargetArn",
            &input.security_profile_target_arn,
        );
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DetachSecurityProfileResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DetachSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Detaches the specified principal from the specified thing.</p>
    fn detach_thing_principal(
        &self,
        input: DetachThingPrincipalRequest,
    ) -> RusotoFuture<DetachThingPrincipalResponse, DetachThingPrincipalError> {
        let request_uri = format!(
            "/things/{thing_name}/principals",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<DetachThingPrincipalResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DetachThingPrincipalError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Disables the rule.</p>
    fn disable_topic_rule(
        &self,
        input: DisableTopicRuleRequest,
    ) -> RusotoFuture<(), DisableTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}/disable", rule_name = input.rule_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DisableTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Enables the rule.</p>
    fn enable_topic_rule(
        &self,
        input: EnableTopicRuleRequest,
    ) -> RusotoFuture<(), EnableTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}/enable", rule_name = input.rule_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(EnableTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.</p>
    fn get_effective_policies(
        &self,
        input: GetEffectivePoliciesRequest,
    ) -> RusotoFuture<GetEffectivePoliciesResponse, GetEffectivePoliciesError> {
        let request_uri = "/effective-policies";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.thing_name {
            params.put("thingName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<GetEffectivePoliciesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(GetEffectivePoliciesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets the search configuration.</p>
    fn get_indexing_configuration(
        &self,
    ) -> RusotoFuture<GetIndexingConfigurationResponse, GetIndexingConfigurationError> {
        let request_uri = "/indexing/config";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<GetIndexingConfigurationResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(GetIndexingConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets a job document.</p>
    fn get_job_document(
        &self,
        input: GetJobDocumentRequest,
    ) -> RusotoFuture<GetJobDocumentResponse, GetJobDocumentError> {
        let request_uri = format!("/jobs/{job_id}/job-document", job_id = input.job_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<GetJobDocumentResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetJobDocumentError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
    fn get_logging_options(
        &self,
    ) -> RusotoFuture<GetLoggingOptionsResponse, GetLoggingOptionsError> {
        let request_uri = "/loggingOptions";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<GetLoggingOptionsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetLoggingOptionsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets an OTA update.</p>
    fn get_ota_update(
        &self,
        input: GetOTAUpdateRequest,
    ) -> RusotoFuture<GetOTAUpdateResponse, GetOTAUpdateError> {
        let request_uri = format!(
            "/otaUpdates/{ota_update_id}",
            ota_update_id = input.ota_update_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<GetOTAUpdateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetOTAUpdateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the specified policy with the policy document of the default version.</p>
    fn get_policy(
        &self,
        input: GetPolicyRequest,
    ) -> RusotoFuture<GetPolicyResponse, GetPolicyError> {
        let request_uri = format!("/policies/{policy_name}", policy_name = input.policy_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<GetPolicyResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetPolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the specified policy version.</p>
    fn get_policy_version(
        &self,
        input: GetPolicyVersionRequest,
    ) -> RusotoFuture<GetPolicyVersionResponse, GetPolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version/{policy_version_id}",
            policy_name = input.policy_name,
            policy_version_id = input.policy_version_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<GetPolicyVersionResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetPolicyVersionError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets a registration code used to register a CA certificate with AWS IoT.</p>
    fn get_registration_code(
        &self,
    ) -> RusotoFuture<GetRegistrationCodeResponse, GetRegistrationCodeError> {
        let request_uri = "/registrationcode";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<GetRegistrationCodeResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(GetRegistrationCodeError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about the rule.</p>
    fn get_topic_rule(
        &self,
        input: GetTopicRuleRequest,
    ) -> RusotoFuture<GetTopicRuleResponse, GetTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<GetTopicRuleResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets the fine grained logging options.</p>
    fn get_v2_logging_options(
        &self,
    ) -> RusotoFuture<GetV2LoggingOptionsResponse, GetV2LoggingOptionsError> {
        let request_uri = "/v2LoggingOptions";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<GetV2LoggingOptionsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(GetV2LoggingOptionsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the active violations for a given Device Defender security profile.</p>
    fn list_active_violations(
        &self,
        input: ListActiveViolationsRequest,
    ) -> RusotoFuture<ListActiveViolationsResponse, ListActiveViolationsError> {
        let request_uri = "/active-violations";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.security_profile_name {
            params.put("securityProfileName", x);
        }
        if let Some(ref x) = input.thing_name {
            params.put("thingName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListActiveViolationsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListActiveViolationsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the policies attached to the specified thing group.</p>
    fn list_attached_policies(
        &self,
        input: ListAttachedPoliciesRequest,
    ) -> RusotoFuture<ListAttachedPoliciesResponse, ListAttachedPoliciesError> {
        let request_uri = format!("/attached-policies/{target}", target = input.target);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListAttachedPoliciesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListAttachedPoliciesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)</p>
    fn list_audit_findings(
        &self,
        input: ListAuditFindingsRequest,
    ) -> RusotoFuture<ListAuditFindingsResponse, ListAuditFindingsError> {
        let request_uri = "/audit/findings";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListAuditFindingsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListAuditFindingsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the Device Defender audits that have been performed during a given time period.</p>
    fn list_audit_tasks(
        &self,
        input: ListAuditTasksRequest,
    ) -> RusotoFuture<ListAuditTasksResponse, ListAuditTasksError> {
        let request_uri = "/audit/tasks";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("endTime", &input.end_time);
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("startTime", &input.start_time);
        if let Some(ref x) = input.task_status {
            params.put("taskStatus", x);
        }
        if let Some(ref x) = input.task_type {
            params.put("taskType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListAuditTasksResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListAuditTasksError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the authorizers registered in your account.</p>
    fn list_authorizers(
        &self,
        input: ListAuthorizersRequest,
    ) -> RusotoFuture<ListAuthorizersResponse, ListAuthorizersError> {
        let request_uri = "/authorizers/";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListAuthorizersResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListAuthorizersError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_ca_certificates(
        &self,
        input: ListCACertificatesRequest,
    ) -> RusotoFuture<ListCACertificatesResponse, ListCACertificatesError> {
        let request_uri = "/cacertificates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListCACertificatesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListCACertificatesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_certificates(
        &self,
        input: ListCertificatesRequest,
    ) -> RusotoFuture<ListCertificatesResponse, ListCertificatesError> {
        let request_uri = "/certificates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListCertificatesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListCertificatesError::from_response(response))),
                )
            }
        })
    }

    /// <p>List the device certificates signed by the specified CA certificate.</p>
    fn list_certificates_by_ca(
        &self,
        input: ListCertificatesByCARequest,
    ) -> RusotoFuture<ListCertificatesByCAResponse, ListCertificatesByCAError> {
        let request_uri = format!(
            "/certificates-by-ca/{ca_certificate_id}",
            ca_certificate_id = input.ca_certificate_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListCertificatesByCAResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListCertificatesByCAError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the search indices.</p>
    fn list_indices(
        &self,
        input: ListIndicesRequest,
    ) -> RusotoFuture<ListIndicesResponse, ListIndicesError> {
        let request_uri = "/indices";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListIndicesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListIndicesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the job executions for a job.</p>
    fn list_job_executions_for_job(
        &self,
        input: ListJobExecutionsForJobRequest,
    ) -> RusotoFuture<ListJobExecutionsForJobResponse, ListJobExecutionsForJobError> {
        let request_uri = format!("/jobs/{job_id}/things", job_id = input.job_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListJobExecutionsForJobResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListJobExecutionsForJobError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the job executions for the specified thing.</p>
    fn list_job_executions_for_thing(
        &self,
        input: ListJobExecutionsForThingRequest,
    ) -> RusotoFuture<ListJobExecutionsForThingResponse, ListJobExecutionsForThingError> {
        let request_uri = format!("/things/{thing_name}/jobs", thing_name = input.thing_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListJobExecutionsForThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListJobExecutionsForThingError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists jobs.</p>
    fn list_jobs(&self, input: ListJobsRequest) -> RusotoFuture<ListJobsResponse, ListJobsError> {
        let request_uri = "/jobs";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        if let Some(ref x) = input.target_selection {
            params.put("targetSelection", x);
        }
        if let Some(ref x) = input.thing_group_id {
            params.put("thingGroupId", x);
        }
        if let Some(ref x) = input.thing_group_name {
            params.put("thingGroupName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListJobsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListJobsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists OTA updates.</p>
    fn list_ota_updates(
        &self,
        input: ListOTAUpdatesRequest,
    ) -> RusotoFuture<ListOTAUpdatesResponse, ListOTAUpdatesError> {
        let request_uri = "/otaUpdates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.ota_update_status {
            params.put("otaUpdateStatus", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListOTAUpdatesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListOTAUpdatesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists certificates that are being transferred but not yet accepted.</p>
    fn list_outgoing_certificates(
        &self,
        input: ListOutgoingCertificatesRequest,
    ) -> RusotoFuture<ListOutgoingCertificatesResponse, ListOutgoingCertificatesError> {
        let request_uri = "/certificates-out-going";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListOutgoingCertificatesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListOutgoingCertificatesError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists your policies.</p>
    fn list_policies(
        &self,
        input: ListPoliciesRequest,
    ) -> RusotoFuture<ListPoliciesResponse, ListPoliciesError> {
        let request_uri = "/policies";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListPoliciesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListPoliciesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
    fn list_policy_principals(
        &self,
        input: ListPolicyPrincipalsRequest,
    ) -> RusotoFuture<ListPolicyPrincipalsResponse, ListPolicyPrincipalsError> {
        let request_uri = "/policy-principals";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-policy", &input.policy_name);
        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListPolicyPrincipalsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListPolicyPrincipalsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the versions of the specified policy and identifies the default version.</p>
    fn list_policy_versions(
        &self,
        input: ListPolicyVersionsRequest,
    ) -> RusotoFuture<ListPolicyVersionsResponse, ListPolicyVersionsError> {
        let request_uri = format!(
            "/policies/{policy_name}/version",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListPolicyVersionsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListPolicyVersionsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
    fn list_principal_policies(
        &self,
        input: ListPrincipalPoliciesRequest,
    ) -> RusotoFuture<ListPrincipalPoliciesResponse, ListPrincipalPoliciesError> {
        let request_uri = "/principal-policies";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-principal", &input.principal);
        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListPrincipalPoliciesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListPrincipalPoliciesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the things associated with the specified principal.</p>
    fn list_principal_things(
        &self,
        input: ListPrincipalThingsRequest,
    ) -> RusotoFuture<ListPrincipalThingsResponse, ListPrincipalThingsError> {
        let request_uri = "/principals/things";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-principal", &input.principal);
        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListPrincipalThingsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListPrincipalThingsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the role aliases registered in your account.</p>
    fn list_role_aliases(
        &self,
        input: ListRoleAliasesRequest,
    ) -> RusotoFuture<ListRoleAliasesResponse, ListRoleAliasesError> {
        let request_uri = "/role-aliases";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListRoleAliasesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListRoleAliasesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists all of your scheduled audits.</p>
    fn list_scheduled_audits(
        &self,
        input: ListScheduledAuditsRequest,
    ) -> RusotoFuture<ListScheduledAuditsResponse, ListScheduledAuditsError> {
        let request_uri = "/audit/scheduledaudits";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListScheduledAuditsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListScheduledAuditsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.</p>
    fn list_security_profiles(
        &self,
        input: ListSecurityProfilesRequest,
    ) -> RusotoFuture<ListSecurityProfilesResponse, ListSecurityProfilesError> {
        let request_uri = "/security-profiles";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListSecurityProfilesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListSecurityProfilesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the Device Defender security profiles attached to a target (thing group).</p>
    fn list_security_profiles_for_target(
        &self,
        input: ListSecurityProfilesForTargetRequest,
    ) -> RusotoFuture<ListSecurityProfilesForTargetResponse, ListSecurityProfilesForTargetError>
    {
        let request_uri = "/security-profiles-for-target";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        params.put(
            "securityProfileTargetArn",
            &input.security_profile_target_arn,
        );
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListSecurityProfilesForTargetResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListSecurityProfilesForTargetError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists all of the streams in your AWS account.</p>
    fn list_streams(
        &self,
        input: ListStreamsRequest,
    ) -> RusotoFuture<ListStreamsResponse, ListStreamsError> {
        let request_uri = "/streams";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListStreamsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListStreamsError::from_response(response))),
                )
            }
        })
    }

    /// <p>List targets for the specified policy.</p>
    fn list_targets_for_policy(
        &self,
        input: ListTargetsForPolicyRequest,
    ) -> RusotoFuture<ListTargetsForPolicyResponse, ListTargetsForPolicyError> {
        let request_uri = format!(
            "/policy-targets/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListTargetsForPolicyResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListTargetsForPolicyError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the targets (thing groups) associated with a given Device Defender security profile.</p>
    fn list_targets_for_security_profile(
        &self,
        input: ListTargetsForSecurityProfileRequest,
    ) -> RusotoFuture<ListTargetsForSecurityProfileResponse, ListTargetsForSecurityProfileError>
    {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}/targets",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListTargetsForSecurityProfileResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListTargetsForSecurityProfileError::from_response(response))
                }))
            }
        })
    }

    /// <p>List the thing groups in your account.</p>
    fn list_thing_groups(
        &self,
        input: ListThingGroupsRequest,
    ) -> RusotoFuture<ListThingGroupsResponse, ListThingGroupsError> {
        let request_uri = "/thing-groups";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.name_prefix_filter {
            params.put("namePrefixFilter", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.parent_group {
            params.put("parentGroup", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListThingGroupsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListThingGroupsError::from_response(response))),
                )
            }
        })
    }

    /// <p>List the thing groups to which the specified thing belongs.</p>
    fn list_thing_groups_for_thing(
        &self,
        input: ListThingGroupsForThingRequest,
    ) -> RusotoFuture<ListThingGroupsForThingResponse, ListThingGroupsForThingError> {
        let request_uri = format!(
            "/things/{thing_name}/thing-groups",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListThingGroupsForThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingGroupsForThingError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the principals associated with the specified thing.</p>
    fn list_thing_principals(
        &self,
        input: ListThingPrincipalsRequest,
    ) -> RusotoFuture<ListThingPrincipalsResponse, ListThingPrincipalsError> {
        let request_uri = format!(
            "/things/{thing_name}/principals",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListThingPrincipalsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListThingPrincipalsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Information about the thing registration tasks.</p>
    fn list_thing_registration_task_reports(
        &self,
        input: ListThingRegistrationTaskReportsRequest,
    ) -> RusotoFuture<ListThingRegistrationTaskReportsResponse, ListThingRegistrationTaskReportsError>
    {
        let request_uri = format!(
            "/thing-registration-tasks/{task_id}/reports",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("reportType", &input.report_type);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListThingRegistrationTaskReportsResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingRegistrationTaskReportsError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>List bulk thing provisioning tasks.</p>
    fn list_thing_registration_tasks(
        &self,
        input: ListThingRegistrationTasksRequest,
    ) -> RusotoFuture<ListThingRegistrationTasksResponse, ListThingRegistrationTasksError> {
        let request_uri = "/thing-registration-tasks";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListThingRegistrationTasksResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingRegistrationTasksError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the existing thing types.</p>
    fn list_thing_types(
        &self,
        input: ListThingTypesRequest,
    ) -> RusotoFuture<ListThingTypesResponse, ListThingTypesError> {
        let request_uri = "/thing-types";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.thing_type_name {
            params.put("thingTypeName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListThingTypesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListThingTypesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. </p>
    fn list_things(
        &self,
        input: ListThingsRequest,
    ) -> RusotoFuture<ListThingsResponse, ListThingsError> {
        let request_uri = "/things";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.attribute_name {
            params.put("attributeName", x);
        }
        if let Some(ref x) = input.attribute_value {
            params.put("attributeValue", x);
        }
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.thing_type_name {
            params.put("thingTypeName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListThingsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListThingsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the things in the specified group.</p>
    fn list_things_in_thing_group(
        &self,
        input: ListThingsInThingGroupRequest,
    ) -> RusotoFuture<ListThingsInThingGroupResponse, ListThingsInThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}/things",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListThingsInThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListThingsInThingGroupError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the rules for the specific topic.</p>
    fn list_topic_rules(
        &self,
        input: ListTopicRulesRequest,
    ) -> RusotoFuture<ListTopicRulesResponse, ListTopicRulesError> {
        let request_uri = "/rules";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.rule_disabled {
            params.put("ruleDisabled", x);
        }
        if let Some(ref x) = input.topic {
            params.put("topic", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<ListTopicRulesResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListTopicRulesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists logging levels.</p>
    fn list_v2_logging_levels(
        &self,
        input: ListV2LoggingLevelsRequest,
    ) -> RusotoFuture<ListV2LoggingLevelsResponse, ListV2LoggingLevelsError> {
        let request_uri = "/v2LoggingLevel";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.target_type {
            params.put("targetType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListV2LoggingLevelsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListV2LoggingLevelsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior or thing (device).</p>
    fn list_violation_events(
        &self,
        input: ListViolationEventsRequest,
    ) -> RusotoFuture<ListViolationEventsResponse, ListViolationEventsError> {
        let request_uri = "/violation-events";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("endTime", &input.end_time);
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.security_profile_name {
            params.put("securityProfileName", x);
        }
        params.put("startTime", &input.start_time);
        if let Some(ref x) = input.thing_name {
            params.put("thingName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ListViolationEventsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListViolationEventsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.</p>
    fn register_ca_certificate(
        &self,
        input: RegisterCACertificateRequest,
    ) -> RusotoFuture<RegisterCACertificateResponse, RegisterCACertificateError> {
        let request_uri = "/cacertificate";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.allow_auto_registration {
            params.put("allowAutoRegistration", x);
        }
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<RegisterCACertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(RegisterCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.</p>
    fn register_certificate(
        &self,
        input: RegisterCertificateRequest,
    ) -> RusotoFuture<RegisterCertificateResponse, RegisterCertificateError> {
        let request_uri = "/certificate/register";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<RegisterCertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(RegisterCertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Provisions a thing.</p>
    fn register_thing(
        &self,
        input: RegisterThingRequest,
    ) -> RusotoFuture<RegisterThingResponse, RegisterThingError> {
        let request_uri = "/things";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<RegisterThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(RegisterThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
    fn reject_certificate_transfer(
        &self,
        input: RejectCertificateTransferRequest,
    ) -> RusotoFuture<(), RejectCertificateTransferError> {
        let request_uri = format!(
            "/reject-certificate-transfer/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(RejectCertificateTransferError::from_response(response))
                }))
            }
        })
    }

    /// <p>Remove the specified thing from the specified group.</p>
    fn remove_thing_from_thing_group(
        &self,
        input: RemoveThingFromThingGroupRequest,
    ) -> RusotoFuture<RemoveThingFromThingGroupResponse, RemoveThingFromThingGroupError> {
        let request_uri = "/thing-groups/removeThingFromThingGroup";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<RemoveThingFromThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(RemoveThingFromThingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn replace_topic_rule(
        &self,
        input: ReplaceTopicRuleRequest,
    ) -> RusotoFuture<(), ReplaceTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input.topic_rule_payload).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ReplaceTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>The query search index.</p>
    fn search_index(
        &self,
        input: SearchIndexRequest,
    ) -> RusotoFuture<SearchIndexResponse, SearchIndexError> {
        let request_uri = "/indices/search";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<SearchIndexResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(SearchIndexError::from_response(response))),
                )
            }
        })
    }

    /// <p>Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.</p>
    fn set_default_authorizer(
        &self,
        input: SetDefaultAuthorizerRequest,
    ) -> RusotoFuture<SetDefaultAuthorizerResponse, SetDefaultAuthorizerError> {
        let request_uri = "/default-authorizer";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<SetDefaultAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(SetDefaultAuthorizerError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.</p>
    fn set_default_policy_version(
        &self,
        input: SetDefaultPolicyVersionRequest,
    ) -> RusotoFuture<(), SetDefaultPolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version/{policy_version_id}",
            policy_name = input.policy_name,
            policy_version_id = input.policy_version_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(SetDefaultPolicyVersionError::from_response(response))
                }))
            }
        })
    }

    /// <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
    fn set_logging_options(
        &self,
        input: SetLoggingOptionsRequest,
    ) -> RusotoFuture<(), SetLoggingOptionsError> {
        let request_uri = "/loggingOptions";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input.logging_options_payload).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(SetLoggingOptionsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Sets the logging level.</p>
    fn set_v2_logging_level(
        &self,
        input: SetV2LoggingLevelRequest,
    ) -> RusotoFuture<(), SetV2LoggingLevelError> {
        let request_uri = "/v2LoggingLevel";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(SetV2LoggingLevelError::from_response(response))),
                )
            }
        })
    }

    /// <p>Sets the logging options for the V2 logging service.</p>
    fn set_v2_logging_options(
        &self,
        input: SetV2LoggingOptionsRequest,
    ) -> RusotoFuture<(), SetV2LoggingOptionsError> {
        let request_uri = "/v2LoggingOptions";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(SetV2LoggingOptionsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Starts an on-demand Device Defender audit.</p>
    fn start_on_demand_audit_task(
        &self,
        input: StartOnDemandAuditTaskRequest,
    ) -> RusotoFuture<StartOnDemandAuditTaskResponse, StartOnDemandAuditTaskError> {
        let request_uri = "/audit/tasks";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<StartOnDemandAuditTaskResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(StartOnDemandAuditTaskError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a bulk thing provisioning task.</p>
    fn start_thing_registration_task(
        &self,
        input: StartThingRegistrationTaskRequest,
    ) -> RusotoFuture<StartThingRegistrationTaskResponse, StartThingRegistrationTaskError> {
        let request_uri = "/thing-registration-tasks";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<StartThingRegistrationTaskResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(StartThingRegistrationTaskError::from_response(response))
                }))
            }
        })
    }

    /// <p>Cancels a bulk thing provisioning task.</p>
    fn stop_thing_registration_task(
        &self,
        input: StopThingRegistrationTaskRequest,
    ) -> RusotoFuture<StopThingRegistrationTaskResponse, StopThingRegistrationTaskError> {
        let request_uri = format!(
            "/thing-registration-tasks/{task_id}/cancel",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<StopThingRegistrationTaskResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(StopThingRegistrationTaskError::from_response(response))
                }))
            }
        })
    }

    /// <p>Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_authorization(
        &self,
        input: TestAuthorizationRequest,
    ) -> RusotoFuture<TestAuthorizationResponse, TestAuthorizationError> {
        let request_uri = "/test-authorization";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.client_id {
            params.put("clientId", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<TestAuthorizationResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(TestAuthorizationError::from_response(response))),
                )
            }
        })
    }

    /// <p>Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_invoke_authorizer(
        &self,
        input: TestInvokeAuthorizerRequest,
    ) -> RusotoFuture<TestInvokeAuthorizerResponse, TestInvokeAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}/test",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<TestInvokeAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(TestInvokeAuthorizerError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
    fn transfer_certificate(
        &self,
        input: TransferCertificateRequest,
    ) -> RusotoFuture<TransferCertificateResponse, TransferCertificateError> {
        let request_uri = format!(
            "/transfer-certificate/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        params.put("targetAwsAccount", &input.target_aws_account);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<TransferCertificateResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(TransferCertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn update_account_audit_configuration(
        &self,
        input: UpdateAccountAuditConfigurationRequest,
    ) -> RusotoFuture<UpdateAccountAuditConfigurationResponse, UpdateAccountAuditConfigurationError>
    {
        let request_uri = "/audit/configuration";

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<UpdateAccountAuditConfigurationResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateAccountAuditConfigurationError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Updates an authorizer.</p>
    fn update_authorizer(
        &self,
        input: UpdateAuthorizerRequest,
    ) -> RusotoFuture<UpdateAuthorizerResponse, UpdateAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<UpdateAuthorizerResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates a registered CA certificate.</p>
    fn update_ca_certificate(
        &self,
        input: UpdateCACertificateRequest,
    ) -> RusotoFuture<(), UpdateCACertificateError> {
        let request_uri = format!(
            "/cacertificate/{ca_certificate_id}",
            ca_certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.new_auto_registration_status {
            params.put("newAutoRegistrationStatus", x);
        }
        if let Some(ref x) = input.new_status {
            params.put("newStatus", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
    fn update_certificate(
        &self,
        input: UpdateCertificateRequest,
    ) -> RusotoFuture<(), UpdateCertificateError> {
        let request_uri = format!(
            "/certificates/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("newStatus", &input.new_status);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let result = ::std::mem::drop(response);

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateCertificateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates the event configurations.</p>
    fn update_event_configurations(
        &self,
        input: UpdateEventConfigurationsRequest,
    ) -> RusotoFuture<UpdateEventConfigurationsResponse, UpdateEventConfigurationsError> {
        let request_uri = "/event-configurations";

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<UpdateEventConfigurationsResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateEventConfigurationsError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates the search configuration.</p>
    fn update_indexing_configuration(
        &self,
        input: UpdateIndexingConfigurationRequest,
    ) -> RusotoFuture<UpdateIndexingConfigurationResponse, UpdateIndexingConfigurationError> {
        let request_uri = "/indexing/config";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<UpdateIndexingConfigurationResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateIndexingConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates a role alias.</p>
    fn update_role_alias(
        &self,
        input: UpdateRoleAliasRequest,
    ) -> RusotoFuture<UpdateRoleAliasResponse, UpdateRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<UpdateRoleAliasResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates a scheduled audit, including what checks are performed and how often the audit takes place.</p>
    fn update_scheduled_audit(
        &self,
        input: UpdateScheduledAuditRequest,
    ) -> RusotoFuture<UpdateScheduledAuditResponse, UpdateScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<UpdateScheduledAuditResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates a Device Defender security profile.</p>
    fn update_security_profile(
        &self,
        input: UpdateSecurityProfileRequest,
    ) -> RusotoFuture<UpdateSecurityProfileResponse, UpdateSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<UpdateSecurityProfileResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates an existing stream. The stream version will be incremented by one.</p>
    fn update_stream(
        &self,
        input: UpdateStreamRequest,
    ) -> RusotoFuture<UpdateStreamResponse, UpdateStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<UpdateStreamResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates the data for a thing.</p>
    fn update_thing(
        &self,
        input: UpdateThingRequest,
    ) -> RusotoFuture<UpdateThingResponse, UpdateThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<UpdateThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Update a thing group.</p>
    fn update_thing_group(
        &self,
        input: UpdateThingGroupRequest,
    ) -> RusotoFuture<UpdateThingGroupResponse, UpdateThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result = serde_json::from_slice::<UpdateThingGroupResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates the groups to which the thing belongs.</p>
    fn update_thing_groups_for_thing(
        &self,
        input: UpdateThingGroupsForThingRequest,
    ) -> RusotoFuture<UpdateThingGroupsForThingResponse, UpdateThingGroupsForThingError> {
        let request_uri = "/thing-groups/updateThingGroupsForThing";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<UpdateThingGroupsForThingResponse>(&body).unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateThingGroupsForThingError::from_response(response))
                }))
            }
        })
    }

    /// <p>Validates a Device Defender security profile behaviors specification.</p>
    fn validate_security_profile_behaviors(
        &self,
        input: ValidateSecurityProfileBehaviorsRequest,
    ) -> RusotoFuture<ValidateSecurityProfileBehaviorsResponse, ValidateSecurityProfileBehaviorsError>
    {
        let request_uri = "/security-profile-behaviors/validate";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().map(|response| {
                    let mut body = response.body;

                    if body == b"null" {
                        body = b"{}".to_vec();
                    }

                    debug!("Response body: {:?}", body);
                    debug!("Response status: {}", response.status);
                    let result =
                        serde_json::from_slice::<ValidateSecurityProfileBehaviorsResponse>(&body)
                            .unwrap();

                    result
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ValidateSecurityProfileBehaviorsError::from_response(
                        response,
                    ))
                }))
            }
        })
    }
}

#[cfg(test)]
mod protocol_tests {}
